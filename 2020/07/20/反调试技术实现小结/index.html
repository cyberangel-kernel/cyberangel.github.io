<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>反调试技术实现小结 | Cyberangel-blog</title><meta name="author" content="Cyberangel"><meta name="copyright" content="Cyberangel"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="文章略微改动自：https:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-1180416-1-1.html  前言随着软件逆向工程技术的快速发展，针对各种软件的分析破解技术层出不穷，动态调试技术也在不断的发展中，那么在这种环境下，就非常需要反调试技术了，反调试成了一种防止破解的一种手段，很好得使用反调试，可以保护软件。接下来，给大家分享一下我实现过的反调试技术及对应的反反调式技术。 Being">
<meta property="og:type" content="article">
<meta property="og:title" content="反调试技术实现小结">
<meta property="og:url" content="https://cyberangel.cn/2020/07/20/%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%B0%8F%E7%BB%93/index.html">
<meta property="og:site_name" content="Cyberangel-blog">
<meta property="og:description" content="文章略微改动自：https:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-1180416-1-1.html  前言随着软件逆向工程技术的快速发展，针对各种软件的分析破解技术层出不穷，动态调试技术也在不断的发展中，那么在这种环境下，就非常需要反调试技术了，反调试成了一种防止破解的一种手段，很好得使用反调试，可以保护软件。接下来，给大家分享一下我实现过的反调试技术及对应的反反调式技术。 Being">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-07-20T02:54:36.000Z">
<meta property="article:modified_time" content="2021-07-04T09:57:18.924Z">
<meta property="article:author" content="Cyberangel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cyberangel.cn/2020/07/20/%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%B0%8F%E7%BB%93/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '反调试技术实现小结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-04 17:57:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Cyberangel-blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">317</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Cyberangel-blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">反调试技术实现小结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-20T02:54:36.000Z" title="发表于 2020-07-20 10:54:36">2020-07-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-04T09:57:18.924Z" title="更新于 2021-07-04 17:57:18">2021-07-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="反调试技术实现小结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>文章略微改动自：<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1180416-1-1.html">https://www.52pojie.cn/thread-1180416-1-1.html</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着软件逆向工程技术的快速发展，针对各种软件的分析破解技术层出不穷，动态调试技术也在不断的发展中，那么在这种环境下，就非常需要反调试技术了，<strong>反调试成了一种防止破解的一种手段，很好得使用反调试，可以保护软件。</strong>接下来，给大家分享一下我实现过的反调试技术及对应的反反调式技术。</p>
<h1 id="BeingDebugged-判断法"><a href="#BeingDebugged-判断法" class="headerlink" title="BeingDebugged 判断法"></a>BeingDebugged 判断法</h1><p>1.在 PEB 结构中，有 BeingDebugged 成员，当程序处于调式状态时，该成员的值会变为 1，否则为 0.根据这个特性可以判断程序是否处于调式状态，<strong>fs 寄存器偏移 0x18 处指向 TEB 结构，TEB 结构偏移 0x30 处指向 PEB 结构，PEB 结构偏移 0x2 处即为 BeingDebugged 成员</strong>，TEB 和 PEB 结构如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TEB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ........</span><br><span class="line">    PVOID ThreadLocalStoragePointer;    <span class="comment">// 2Ch</span></span><br><span class="line">    PPEB Peb;                           <span class="comment">// 30h  &lt;--------</span></span><br><span class="line">    ULONG LastErrorValue;               <span class="comment">// 34h</span></span><br><span class="line">    ULONG CountOfOwnedCriticalSections; <span class="comment">// 38h</span></span><br><span class="line">    PVOID CsrClientThread;              <span class="comment">// 3Ch</span></span><br><span class="line">    PVOID Win32ThreadInfo;              <span class="comment">// 40h</span></span><br><span class="line">    ULONG Win32ClientInfo[<span class="number">0x1F</span>];        <span class="comment">// 44h</span></span><br><span class="line">    PVOID WOW32Reserved;                <span class="comment">// C0h</span></span><br><span class="line">    ULONG CurrentLocale;                <span class="comment">// C4h</span></span><br><span class="line">    ULONG FpSoftwareStatusRegister;     <span class="comment">// C8h</span></span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UCHAR InheritedAddressSpace;                     <span class="comment">// 00h</span></span><br><span class="line">    UCHAR ReadImageFileExecOptions;                  <span class="comment">// 01h</span></span><br><span class="line">    UCHAR BeingDebugged;                             <span class="comment">// 02h &lt;-----------</span></span><br><span class="line">    UCHAR Spare;                                     <span class="comment">// 03h</span></span><br><span class="line">    PVOID Mutant;                                    <span class="comment">// 04h</span></span><br><span class="line">    PVOID ImageBaseAddress;                          <span class="comment">// 08h</span></span><br><span class="line">    PPEB_LDR_DATA Ldr;                               <span class="comment">// 0Ch &lt;-------------</span></span><br><span class="line">    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;  <span class="comment">// 10h</span></span><br><span class="line">    PVOID SubSystemData;                             <span class="comment">// 14h</span></span><br><span class="line">    PVOID ProcessHeap;                               <span class="comment">// 18h</span></span><br><span class="line">   ................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.实现反调试技术，我使用了裸函数，一般的函数，IDE 都会使用编译器和链接器进行处理，使其附加上一些汇编代码，而对裸函数不会进行任何处理，在 VC 中编写一个空的裸函数，发现调式时，按 f11,直接步过该函数。<br>意味着 C 编译器对裸函数将生成不含函数框架的纯汇编代码，内部的汇编代码要自己实现。</p>
<hr>
<p>什么是裸函数：<br>简而言之，<del>就是没有穿衣服的函数</del>（不是）<br>裸函数的定义如下：<br>_declspec(naked)修饰可以生成一个“裸”函数， 使用后 C 编译器将生成不含函数框架的纯汇编代码，裸函数中什么都没有，所以也不能使用局部变量，<strong>只能全部用内嵌汇编实现</strong>。也就是说，裸函数中只能使用汇编语言来编写代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __declspec(naked) Function() &#123;</span><br><span class="line">         ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>declspec(naked) 的介绍：<br>　　_declspec(naked)，就是告诉编译器，在编译的时候，不要优化代码，通俗的说就是，没代码，完全要自己写<br>比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAKED __declspec(naked)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> NAKED <span class="title">code</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用__declspec(naked)关键字定义函数:<br>　　 1，使用 naked 关键字必须自己构建 EBP 指针 (如果用到了的话);<br>　　 2，必须自己使用 RET 或 RET n 指令返回 (除非你不返回);<br>　　_delcspec(naked)用在驱动编写，C 语言内嵌汇编完成一些特定功能。</p>
<hr>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1595215193689-68848236-1dd4-4c63-959f-25c281252d50.png#align=left&display=inline&height=89&margin=%5Bobject%20Object%5D&originHeight=89&originWidth=439&size=0&status=done&style=none&width=439">**</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1595215193764-f6349461-ac74-452b-afd6-3b7c78e3d9a1.png#align=left&display=inline&height=124&margin=%5Bobject%20Object%5D&originHeight=124&originWidth=605&size=0&status=done&style=none&width=605"> 3.根据第一步的分析，可以写出如下反调试代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __declspec(naked) Getdebugging()</span><br><span class="line">&#123;</span><br><span class="line">_asm&#123;</span><br><span class="line">push ebp</span><br><span class="line"><span class="comment">//申请堆空间</span></span><br><span class="line">mov ebp, esp</span><br><span class="line">sub esp, <span class="number">0x40</span></span><br><span class="line"><span class="comment">//保护现场</span></span><br><span class="line">push edi</span><br><span class="line">push esi</span><br><span class="line">push ebx</span><br><span class="line"><span class="comment">//缓冲区初始化</span></span><br><span class="line">lea edi, dword ptr ds : [ebp - <span class="number">0x40</span>]</span><br><span class="line">mov ecx, <span class="number">0x10</span></span><br><span class="line">mov eax, <span class="number">0xCCCCCCCC</span></span><br><span class="line">rep stos</span><br><span class="line"></span><br><span class="line"><span class="comment">//关键操作</span></span><br><span class="line">mov eax, dword ptr fs : [<span class="number">0x18</span>]</span><br><span class="line">mov eax, dword ptr ds : [eax+<span class="number">0x30</span>]</span><br><span class="line">movzx eax, byte ptr ds : [eax + <span class="number">0x2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复现场</span></span><br><span class="line">pop ebx</span><br><span class="line">pop esi</span><br><span class="line">pop edi</span><br><span class="line"></span><br><span class="line"><span class="comment">//降低堆栈空间</span></span><br><span class="line">mov esp, ebp</span><br><span class="line">pop ebp</span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Getdebugging())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;debugging&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1595215509064-184f7fa2-d5ba-4a6f-b50d-d059f9b34f6b.png#align=left&display=inline&height=614&margin=%5Bobject%20Object%5D&originHeight=614&originWidth=903&size=0&status=done&style=none&width=903"> 2.解决方案 1.寄存器修改法<br>当程序运行完 movzx eax, byte ptr ds : [eax + 0x2]时，修改寄存器的值或者运行完 Getdebugging 函数后，双击修改 ZF 标志位的值<img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1595215538181-983b1a60-ea6b-4303-9826-fce9aa060249.png#align=left&display=inline&height=267&margin=%5Bobject%20Object%5D&originHeight=267&originWidth=718&size=0&status=done&style=none&width=718"> 2.内存补丁法<br>找到 movzx eax, byte ptr ds : [eax + 0x2]地址，使用 WriteProcessMemory 函数 NOP 掉，或者 NOP 掉关键跳。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;pid;</span><br><span class="line"></span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line"></span><br><span class="line">BYTE buff[] = &#123; <span class="number">0x90</span>,<span class="number">0x90</span>,<span class="number">0x90</span>,<span class="number">0x90</span>,<span class="number">0x90</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (WriteProcessMemory(hProcess, (LPVOID)ProModAddr, buff, len, <span class="literal">NULL</span>))</span><br><span class="line">    MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;success！&quot;</span>), TEXT(<span class="string">&quot;标题&quot;</span>), MB_OKCANCEL);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;fail！&quot;</span>), TEXT(<span class="string">&quot;标题&quot;</span>), MB_OKCANCEL);</span><br></pre></td></tr></table></figure>

<h1 id="扫描-Ldr-成员内存法"><a href="#扫描-Ldr-成员内存法" class="headerlink" title="扫描 Ldr 成员内存法"></a>扫描 Ldr 成员内存法</h1><p>1.在调式进程时，内存中会出现一些特殊的标记，也就是未使用的堆内存全部填充着 0xFEEEFEEE，这一特征可以用来判断程序是否处于调式状态。在 PEB 结构中，可以看到 Ldr 成员，该成员指向了一个在堆内存中的结构，通过该成员可以对堆内存进行扫描，进而来判断进程是否被调式。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1595215693699-905896b7-57f3-4798-80c4-c07dcf2e57fa.png#align=left&display=inline&height=254&margin=%5Bobject%20Object%5D&originHeight=254&originWidth=698&size=0&status=done&style=none&width=698"> 2.那么根据分析，可以写出如下的反调试代码，在获取 Ldr 成员的值(地址值)后，通过地址叠加的方式扫描内存并读取内存，判断堆内存中是否含有 0xFEEEFEEE，含有则退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">DWORD __declspec(naked) GetLdr()</span><br><span class="line">&#123;</span><br><span class="line">    _asm&#123;</span><br><span class="line">        push ebp</span><br><span class="line">            <span class="comment">//申请堆空间</span></span><br><span class="line">            mov ebp, esp</span><br><span class="line">            sub esp, <span class="number">0x40</span></span><br><span class="line"></span><br><span class="line">            push edi</span><br><span class="line">            push esi</span><br><span class="line">            push ebx</span><br><span class="line"></span><br><span class="line">            lea edi, dword ptr ds : [ebp - <span class="number">0x40</span>]</span><br><span class="line">            mov ecx, <span class="number">0x10</span></span><br><span class="line">            mov eax, <span class="number">0xCCCCCCCC</span></span><br><span class="line">            rep stos</span><br><span class="line"></span><br><span class="line">            mov eax, dword ptr fs : [<span class="number">0x18</span>]</span><br><span class="line">            mov eax, dword ptr ds : [eax+<span class="number">0x30</span>]</span><br><span class="line">            mov eax, dword ptr ds : [eax + <span class="number">0xC</span>]</span><br><span class="line"></span><br><span class="line">            pop ebx</span><br><span class="line">            pop esi</span><br><span class="line">            pop edi</span><br><span class="line">            mov esp, ebp</span><br><span class="line">            pop ebp</span><br><span class="line">            ret</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isDebugging</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD LdrAddr = GetLdr();</span><br><span class="line">    <span class="comment">//byte b1 = 0, b2 = 0;</span></span><br><span class="line">    DWORD b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pid = GetCurrentProcessId();</span><br><span class="line">    HANDLE hpro = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="number">0x1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ReadProcessMemory(hpro, (LPVOID)LdrAddr, &amp;b, <span class="number">4</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//判断内存中是否含有0xFEEEFEEE</span></span><br><span class="line">        <span class="keyword">if</span> (b==<span class="number">0xFEEEFEEE</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        LdrAddr += <span class="number">4</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDebugging())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;debugging&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.解决方案 1.内存填充法<br>把内存中，含有 0xFEEEFEEE 的内容全部填充为 NULL，即可，实现的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;pid;</span><br><span class="line"></span><br><span class="line">   HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line"></span><br><span class="line">   BYTE buff[] = &#123; <span class="number">0x90</span>,<span class="number">0x90</span>,<span class="number">0x90</span>,<span class="number">0x90</span>&#125;;</span><br><span class="line">   DWORD LdrAddr = GetLdr();</span><br><span class="line">   <span class="keyword">while</span> (i&lt;<span class="number">0x1000</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       ReadProcessMemory(hpro, (LPVOID)LdrAddr, &amp;b, <span class="number">4</span>, <span class="literal">NULL</span>);</span><br><span class="line">       <span class="keyword">if</span> (b==<span class="number">0xFEEEFEEE</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          WriteProcessMemory(hProcess, (LPVOID)LdrAddr, buff, <span class="number">4</span>,<span class="literal">NULL</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       LdrAddr += <span class="number">4</span>;</span><br><span class="line">       i++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>2.PE 文件修改法 1.有时为了方便破解程序，需要去除程序的 ASLR 功能，某些程序之所以有 ASLR 功能，是因为多了 IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 标志，去除该标志就能去除 ASLR 功能。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1595216018714-f2760ff1-495b-439d-bedc-3b4071d0cd99.png#align=left&display=inline&height=131&margin=%5Bobject%20Object%5D&originHeight=131&originWidth=1283&size=0&status=done&style=none&width=1283"> 2.用二进制工具打开程序，在 0x136 处把 40 81 修改成 00 81 即可去除 ASLR 功能。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1595216030432-6ffd489f-65ee-4d56-9524-e1781e89842a.png#align=left&display=inline&height=143&margin=%5Bobject%20Object%5D&originHeight=143&originWidth=813&size=0&status=done&style=none&width=813"> 3.用 OD 运行程序发现循环关键跳，把该跳 NOP 掉即可，在 OD 中看到该跳的地址为 3B82C4，而代码段的起始地址为 3b1000，那么该跳指令在 PE 中的地址为：3B82C4-3b1000+400=76C4</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1595216041809-a17a759b-65f0-484f-941d-ad5ed43d1a07.png#align=left&display=inline&height=134&margin=%5Bobject%20Object%5D&originHeight=134&originWidth=737&size=0&status=done&style=none&width=737"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1595216058292-c5550e99-496f-4a0d-9c1d-29b3a639ddf0.png#align=left&display=inline&height=89&margin=%5Bobject%20Object%5D&originHeight=89&originWidth=441&size=0&status=done&style=none&width=441"></p>
<h1 id="数据隐藏代码法"><a href="#数据隐藏代码法" class="headerlink" title="数据隐藏代码法"></a>数据隐藏代码法</h1><p>1.在每个进程中都存在堆结构，堆中存储了许多有关进程的信息，Windows 系统堆结构如下所示。其中有两个字段：Flags 和 Force Flags,当程序处于非调式状态时，两个字段的值分别为 2 和 0.根据这个特征可以写出反调试代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;_HEAP&#x27;</span> : [ <span class="number">0x588</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;Entry&#x27;</span> : [ <span class="number">0x0</span>, [<span class="string">&#x27;_HEAP_ENTRY&#x27;</span>]],</span><br><span class="line">    <span class="string">&#x27;Signature&#x27;</span> : [ <span class="number">0x8</span>, [<span class="string">&#x27;unsigned long&#x27;</span>]],</span><br><span class="line">    <span class="string">&#x27;Flags&#x27;</span> : [ <span class="number">0xc</span>, [<span class="string">&#x27;unsigned long&#x27;</span>]],</span><br><span class="line">    <span class="string">&#x27;ForceFlags&#x27;</span> : [ <span class="number">0x10</span>, [<span class="string">&#x27;unsigned long&#x27;</span>]],</span><br><span class="line">    <span class="string">&#x27;VirtualMemoryThreshold&#x27;</span> : [ <span class="number">0x14</span>, [<span class="string">&#x27;unsigned long&#x27;</span>]],</span><br><span class="line">    <span class="string">&#x27;SegmentReserve&#x27;</span> : [ <span class="number">0x18</span>, [<span class="string">&#x27;unsigned long&#x27;</span>]],</span><br><span class="line">    <span class="string">&#x27;SegmentCommit&#x27;</span> : [ <span class="number">0x1c</span>, [<span class="string">&#x27;unsigned long&#x27;</span>]],</span><br><span class="line">    <span class="string">&#x27;DeCommitFreeBlockThreshold&#x27;</span> : [ <span class="number">0x20</span>, [<span class="string">&#x27;unsigned long&#x27;</span>]],</span><br><span class="line">    <span class="string">&#x27;DeCommitTotalFreeThreshold&#x27;</span> : [ <span class="number">0x24</span>, [<span class="string">&#x27;unsigned long&#x27;</span>]],</span><br><span class="line">.............</span><br></pre></td></tr></table></figure>

<p>2.在 PEB 结构中，可以看到 ProcessHeap 字段，该结构指向堆结构，那么通过偏移就可以获取这两个字段的值，实现的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;_PEB&#x27;</span> : [ <span class="number">0x210</span>, &#123;</span><br><span class="line">........</span><br><span class="line">    <span class="string">&#x27;SubSystemData&#x27;</span> : [ <span class="number">0x14</span>, [<span class="string">&#x27;pointer&#x27;</span>, [<span class="string">&#x27;void&#x27;</span>]]],</span><br><span class="line">    <span class="string">&#x27;ProcessHeap&#x27;</span> : [ <span class="number">0x18</span>, [<span class="string">&#x27;pointer&#x27;</span>, [<span class="string">&#x27;void&#x27;</span>]]],</span><br><span class="line">.............</span><br></pre></td></tr></table></figure>

<p>3.实现反调试的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">DWORD __declspec(naked) isDebugging()</span><br><span class="line">&#123;</span><br><span class="line">    _asm&#123;</span><br><span class="line">            push ebp</span><br><span class="line">            mov ebp, esp</span><br><span class="line">            sub esp, <span class="number">0x40</span></span><br><span class="line">            push edi</span><br><span class="line">            push esi</span><br><span class="line">            push ebx</span><br><span class="line">            lea edi, dword ptr ds : [ebp - <span class="number">0x40</span>]</span><br><span class="line">            mov ecx, <span class="number">0x10</span></span><br><span class="line">            mov eax, <span class="number">0xCCCCCCCC</span></span><br><span class="line">            rep stos</span><br><span class="line">            mov eax, dword ptr fs : [<span class="number">0x18</span>]</span><br><span class="line">            mov eax, dword ptr ds : [eax + <span class="number">0x30</span>]</span><br><span class="line">            mov eax, dword ptr ds : [eax + <span class="number">0x18</span>]</span><br><span class="line">            mov ebx,eax</span><br><span class="line">            <span class="comment">//Flags值</span></span><br><span class="line">            mov eax, dword ptr ds : [ebx + <span class="number">0xC</span>]</span><br><span class="line">            cmp al,<span class="number">0x2</span></span><br><span class="line">            jne _AL</span><br><span class="line">            <span class="comment">//Force Flags值</span></span><br><span class="line">            mov eax, dword ptr ds : [ebx + <span class="number">0x10</span>]</span><br><span class="line">            cmp al, <span class="number">0x0</span></span><br><span class="line">            jne _AL</span><br><span class="line">            jmp _BL</span><br><span class="line">            _AL:</span><br><span class="line">               mov eax,<span class="number">0</span></span><br><span class="line">               jmp _AL1</span><br><span class="line">            _BL:</span><br><span class="line">               mov eax, <span class="number">1</span></span><br><span class="line">           _AL1:</span><br><span class="line">            <span class="comment">//恢复现场</span></span><br><span class="line">            pop ebx</span><br><span class="line">            pop esi</span><br><span class="line">            pop edi</span><br><span class="line"></span><br><span class="line">            <span class="comment">//降低堆栈空间</span></span><br><span class="line">            mov esp, ebp</span><br><span class="line">            pop ebp</span><br><span class="line">            ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isDebugging())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;debugging&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>4.在 VC 中直接运行，没有输出 debugging，而在 VC 中调式，则输出 debugging，所以可以检测出反调试。当该程序处于调式状态时，在内存中可以看到 Flags 和 Force Flags 字段的值分别为：50000062 和 40000060</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1595216281299-4e1d705d-0b89-4ae1-a190-6d6c1800fc7b.png#align=left&display=inline&height=260&margin=%5Bobject%20Object%5D&originHeight=260&originWidth=614&size=0&status=done&style=none&width=614"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1595216286154-444680cc-b023-4537-985a-f006cebfe1bb.png#align=left&display=inline&height=214&margin=%5Bobject%20Object%5D&originHeight=214&originWidth=626&size=0&status=done&style=none&width=626"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1595216291138-457158ac-a541-450f-8ffe-6b498daf926d.png#align=left&display=inline&height=117&margin=%5Bobject%20Object%5D&originHeight=117&originWidth=637&size=0&status=done&style=none&width=637"> 5.在不同的 Windows 版本中，堆结构可能不同，在 Windows 7/10 系统中，堆结构如下。那么在实现反调试时，需要修改堆结构中的偏移。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;_HEAP&#x27;</span> : [ <span class="number">0x2a0</span>, &#123;</span><br><span class="line"> ........</span><br><span class="line">    <span class="string">&#x27;NumberOfUnCommittedRanges&#x27;</span> : [ <span class="number">0x54</span>, [<span class="string">&#x27;unsigned long&#x27;</span>]],</span><br><span class="line">    <span class="string">&#x27;SegmentAllocatorBackTraceIndex&#x27;</span> : [ <span class="number">0x58</span>, [<span class="string">&#x27;unsigned short&#x27;</span>]],</span><br><span class="line">    <span class="string">&#x27;Reserved&#x27;</span> : [ <span class="number">0x5a</span>, [<span class="string">&#x27;unsigned short&#x27;</span>]],</span><br><span class="line">    <span class="string">&#x27;UCRSegmentList&#x27;</span> : [ <span class="number">0x60</span>, [<span class="string">&#x27;_LIST_ENTRY&#x27;</span>]],</span><br><span class="line">    <span class="string">&#x27;Flags&#x27;</span> : [ <span class="number">0x70</span>, [<span class="string">&#x27;unsigned long&#x27;</span>]],</span><br><span class="line">    <span class="string">&#x27;ForceFlags&#x27;</span> : [ <span class="number">0x74</span>, [<span class="string">&#x27;unsigned long&#x27;</span>]],</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>6.接着在内存中，可以看到 isDebugging 对应的 shellcode，如果把 shellcode 赋值给 unsigned char 数组，结合指针的使用，该数组能起到函数的作用，这样做的好处就是防止被反反调式。实现的代码如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1595216351867-adb85a26-bcc7-46f8-9d9a-b270c3528126.png#align=left&display=inline&height=144&margin=%5Bobject%20Object%5D&originHeight=144&originWidth=626&size=0&status=done&style=none&width=626"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> code[]=&#123;<span class="number">0x55</span>,<span class="number">0x8B</span>,<span class="number">0xEC</span>,<span class="number">0x83</span>,<span class="number">0xEC</span>,<span class="number">0x40</span> ,<span class="number">0x57</span> ,<span class="number">0x56</span>,<span class="number">0x53</span> ,<span class="number">0x3E</span> ,<span class="number">0x8D</span> ,<span class="number">0x7D</span> ,<span class="number">0xC0</span> ,<span class="number">0xB9</span> ,<span class="number">0x10</span> ,<span class="number">0x00</span></span><br><span class="line">,<span class="number">0x00</span> ,<span class="number">0x00</span> ,<span class="number">0xB8</span> ,<span class="number">0xCC</span> ,<span class="number">0xCC</span> ,<span class="number">0xCC</span> ,<span class="number">0xCC</span> ,<span class="number">0xF3</span> ,<span class="number">0xAA</span> ,<span class="number">0x64</span> ,<span class="number">0xA1</span> ,<span class="number">0x18</span> ,<span class="number">0x00</span> ,<span class="number">0x00</span> ,<span class="number">0x00</span> ,<span class="number">0x3E</span></span><br><span class="line">,<span class="number">0x8B</span> ,<span class="number">0x40</span> ,<span class="number">0x30</span> ,<span class="number">0x3E</span> ,<span class="number">0x8B</span> ,<span class="number">0x40</span> ,<span class="number">0x18</span> ,<span class="number">0x8B</span>,<span class="number">0xD8</span> ,<span class="number">0x3E</span>,<span class="number">0x8B</span> ,<span class="number">0x43</span> ,<span class="number">0x0C</span> ,<span class="number">0x3C</span>,<span class="number">0x02</span> ,<span class="number">0x75</span></span><br><span class="line">,<span class="number">0x0A</span> ,<span class="number">0x3E</span> ,<span class="number">0x8B</span> ,<span class="number">0x43</span> ,<span class="number">0x10</span> ,<span class="number">0x3C</span> ,<span class="number">0x00</span> ,<span class="number">0x75</span>,<span class="number">0x02</span> ,<span class="number">0xEB</span>,<span class="number">0x07</span> ,<span class="number">0xB8</span>,<span class="number">0x00</span> ,<span class="number">0x00</span>,<span class="number">0x00</span> ,<span class="number">0x00</span></span><br><span class="line">,<span class="number">0xEB</span> ,<span class="number">0x05</span> ,<span class="number">0xB8</span> ,<span class="number">0x01</span> ,<span class="number">0x00</span> ,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x5B</span> ,<span class="number">0x5E</span>,<span class="number">0x5F</span> ,<span class="number">0x8B</span> ,<span class="number">0xE5</span>,<span class="number">0x5D</span> ,<span class="number">0xC3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> (*pfun)();</span><br><span class="line"></span><br><span class="line">    pfun=(<span class="keyword">int</span> (*)())&amp;code;  <span class="comment">//默认是__cdecl约定</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x=pfun();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;debugging&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SEH-反调试法"><a href="#SEH-反调试法" class="headerlink" title="SEH 反调试法"></a>SEH 反调试法</h1><p>1.SEH 是 Windows 系统提供的异常处理机制，当发生异常时，可通过程序中的异常处理函数来进行处理，那么在程序运行时，往程序中加载异常处理函数，如果异常处理函数中有反调式功能代码，那么触发异常就可以起到反调式效果。Windows 系统常见的异常如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXCEPTION_ACCESS_VIOLATION  <span class="comment">//本文用到的异常</span></span><br><span class="line">EXCEPTION_STACK_OVERFLOW</span><br><span class="line">EXCEPTION_HEAP_OVERFLOW</span><br><span class="line">EXCEPTION_INT_OVERFLOW</span><br><span class="line">EXCEPTION_SINGLE_STEP</span><br><span class="line">.........</span><br></pre></td></tr></table></figure>

<p>2.程序都是从 OEP(ImageBase+AddressOfEntryPoint)开始运行，为了让程序运行反调试代码，修改 AddressOfEntryPoint 值，运行完反调试检测代码后，修改 EIP 的值，让程序从原来的 OEP 开始运行。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1595216435301-fbe2a108-47fd-46f5-804d-47ace175e6fe.png#align=left&display=inline&height=103&margin=%5Bobject%20Object%5D&originHeight=103&originWidth=266&size=0&status=done&style=none&width=266"> 3.在反调试代码中，先添加 SEH 处理器，触发异常，程序跳转到 SEH 处理程序，执行反调式功能，添加的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0040106</span>C &gt;/$  <span class="number">68</span> B8104000   push seh_add1<span class="number">.004010B</span>8                   ;  SE 处理程序安装; SE handler installation</span><br><span class="line"><span class="number">00401071</span>  |.  <span class="number">64</span>:FF35 <span class="number">00000</span>&gt;push dword ptr fs:[<span class="number">0</span>]                    ;  添加SEH异常处理器</span><br><span class="line"><span class="number">00401078</span>  |.  <span class="number">64</span>:<span class="number">8925</span> <span class="number">00000</span>&gt;mov dword ptr fs:[<span class="number">0</span>],esp</span><br><span class="line"><span class="number">0040107F</span>  |.  <span class="number">90</span>            nop</span><br><span class="line"><span class="number">00401080</span>  |.  <span class="number">90</span>            nop</span><br><span class="line"><span class="number">00401081</span>  |.  <span class="number">90</span>            nop</span><br><span class="line"><span class="number">00401082</span>  |.  <span class="number">90</span>            nop</span><br><span class="line"><span class="number">00401083</span>  |.  <span class="number">33</span>C0          <span class="keyword">xor</span> eax,eax</span><br><span class="line"><span class="number">00401085</span>  |.  C700 <span class="number">01000000</span> mov dword ptr ds:[eax],<span class="number">0x1</span></span><br><span class="line"><span class="number">0040108B</span>  |.  <span class="number">90</span>            nop</span><br><span class="line"><span class="number">0040108</span>C  |.  <span class="number">0000</span>          add byte ptr ds:[eax],al</span><br><span class="line"><span class="number">0040108</span>E  |.  <span class="number">6</span>A <span class="number">00</span>         push <span class="number">0x0</span>                                 ; /Style = MB_OK|MB_APPLMODAL</span><br><span class="line"><span class="number">00401090</span>  |.  <span class="number">6</span>A <span class="number">00</span>         push <span class="number">0x0</span>                                 ; |Title = <span class="literal">NULL</span></span><br><span class="line"><span class="number">00401092</span>  |.  <span class="number">68</span> <span class="number">20304000</span>   push seh_add1<span class="number">.00403020</span>                   ; |Text = <span class="string">&quot;Debugging&quot;</span></span><br><span class="line"><span class="number">00401097</span>  |.  <span class="number">6</span>A <span class="number">00</span>         push <span class="number">0x0</span>                                 ; |hOwner = <span class="literal">NULL</span></span><br><span class="line"><span class="number">00401099</span>      E8 C2FFFFFF   call &lt;jmp.&amp;USER32.MessageBoxA&gt;</span><br><span class="line"><span class="number">0040109</span>E  |.  <span class="number">64</span>:<span class="number">8F</span>05 <span class="number">00000</span>&gt;pop dword ptr fs:[<span class="number">0</span>]                     ;  删除SEH程序</span><br><span class="line"><span class="number">004010</span>A5  |.  <span class="number">83</span>C4 <span class="number">04</span>       add esp,<span class="number">0x4</span></span><br><span class="line"><span class="number">004010</span>A8  |.  <span class="number">6</span>A <span class="number">00</span>         push <span class="number">0x0</span>                                 ; /ExitCode = <span class="number">0x0</span></span><br><span class="line"><span class="number">004010</span>AA      E8 B7FFFFFF   call &lt;jmp.&amp;KERNEL32.ExitProcess&gt;</span><br><span class="line"><span class="number">004010</span>AF   .  C3            retn</span><br><span class="line"><span class="number">004010B</span>0      <span class="number">90</span>            nop</span><br><span class="line"><span class="number">004010B</span>1      <span class="number">90</span>            nop</span><br><span class="line"><span class="number">004010B</span>2      <span class="number">90</span>            nop</span><br><span class="line"><span class="number">004010B</span>3      <span class="number">90</span>            nop</span><br><span class="line"><span class="number">004010B</span>4      <span class="number">90</span>            nop</span><br><span class="line"><span class="number">004010B</span>5      <span class="number">90</span>            nop</span><br><span class="line"><span class="number">004010B</span>6      <span class="number">90</span>            nop</span><br><span class="line"><span class="number">004010B</span>7      <span class="number">90</span>            nop</span><br><span class="line"><span class="number">004010B</span>8  /$  <span class="number">8B</span>7424 <span class="number">0</span>C     mov esi,dword ptr ss:[esp+<span class="number">0xC</span>]           ;  结构异常处理程序; Structured exception handler</span><br><span class="line"><span class="number">004010B</span>C  |.  <span class="number">64</span>:A1 <span class="number">3000000</span>&gt;mov eax,dword ptr fs:[<span class="number">0x30</span>]</span><br><span class="line"><span class="number">004010</span>C2  |.  <span class="number">8078</span> <span class="number">02</span> <span class="number">01</span>    cmp byte ptr ds:[eax+<span class="number">0x2</span>],<span class="number">0x1</span>            ;  判断BeingDebugged的值是否为<span class="number">1</span></span><br><span class="line"><span class="number">004010</span>C6  |.  <span class="number">75</span> <span class="number">0</span>C         jnz <span class="keyword">short</span> seh_add1<span class="number">.004010</span>D4              ;  没有处于调式状态时，进行跳转</span><br><span class="line"><span class="number">004010</span>C8  |.  C786 B8000000&gt;mov dword ptr ds:[esi+<span class="number">0xB8</span>],seh_add1<span class="number">.004</span>&gt;;  把EIP修改为<span class="number">40108</span>e,弹出消息提示框</span><br><span class="line"><span class="number">004010</span>D2  |.  EB <span class="number">0</span>A         jmp <span class="keyword">short</span> seh_add1<span class="number">.004010</span>DE</span><br><span class="line"><span class="number">004010</span>D4  |&gt;  C786 B8000000&gt;mov dword ptr ds:[esi+<span class="number">0xB8</span>],seh_add1<span class="number">.004</span>&gt;;  把EIP修改为原OEP</span><br><span class="line"><span class="number">004010</span>DE  |&gt;  <span class="number">33</span>C0          <span class="keyword">xor</span> eax,eax</span><br><span class="line"><span class="number">004010E0</span>  \.  C3            retn[mw_shl_code=<span class="keyword">asm</span>,<span class="literal">true</span>]<span class="number">0040106</span>C &gt;/$  <span class="number">68</span> B8104000   push seh_add1<span class="number">.004010B</span>8                   ;  SE 处理程序安装; SE handler installation</span><br><span class="line"><span class="number">00401071</span>  |.  <span class="number">64</span>:FF35 <span class="number">00000</span>&gt;push dword ptr fs:[<span class="number">0</span>]                    ;  添加SEH异常处理器</span><br><span class="line"><span class="number">00401078</span>  |.  <span class="number">64</span>:<span class="number">8925</span> <span class="number">00000</span>&gt;mov dword ptr fs:[<span class="number">0</span>],esp</span><br><span class="line"><span class="number">0040107F</span>  |.  <span class="number">90</span>            nop</span><br><span class="line"><span class="number">00401080</span>  |.  <span class="number">90</span>            nop</span><br><span class="line"><span class="number">00401081</span>  |.  <span class="number">90</span>            nop</span><br><span class="line"><span class="number">00401082</span>  |.  <span class="number">90</span>            nop</span><br><span class="line"><span class="number">00401083</span>  |.  <span class="number">33</span>C0          <span class="keyword">xor</span> eax,eax</span><br><span class="line"><span class="number">00401085</span>  |.  C700 <span class="number">01000000</span> mov dword ptr ds:[eax],<span class="number">0x1</span></span><br><span class="line"><span class="number">0040108B</span>  |.  <span class="number">90</span>            nop</span><br><span class="line"><span class="number">0040108</span>C  |.  <span class="number">0000</span>          add byte ptr ds:[eax],al</span><br><span class="line"><span class="number">0040108</span>E  |.  <span class="number">6</span>A <span class="number">00</span>         push <span class="number">0x0</span>                                 ; /Style = MB_OK|MB_APPLMODAL</span><br><span class="line"><span class="number">00401090</span>  |.  <span class="number">6</span>A <span class="number">00</span>         push <span class="number">0x0</span>                                 ; |Title = <span class="literal">NULL</span></span><br><span class="line"><span class="number">00401092</span>  |.  <span class="number">68</span> <span class="number">20304000</span>   push seh_add1<span class="number">.00403020</span>                   ; |Text = <span class="string">&quot;Debugging&quot;</span></span><br><span class="line"><span class="number">00401097</span>  |.  <span class="number">6</span>A <span class="number">00</span>         push <span class="number">0x0</span>                                 ; |hOwner = <span class="literal">NULL</span></span><br><span class="line"><span class="number">00401099</span>      E8 C2FFFFFF   call &lt;jmp.&amp;USER32.MessageBoxA&gt;</span><br><span class="line"><span class="number">0040109</span>E  |.  <span class="number">64</span>:<span class="number">8F</span>05 <span class="number">00000</span>&gt;pop dword ptr fs:[<span class="number">0</span>]                     ;  删除SEH程序</span><br><span class="line"><span class="number">004010</span>A5  |.  <span class="number">83</span>C4 <span class="number">04</span>       add esp,<span class="number">0x4</span></span><br><span class="line"><span class="number">004010</span>A8  |.  <span class="number">6</span>A <span class="number">00</span>         push <span class="number">0x0</span>                                 ; /ExitCode = <span class="number">0x0</span></span><br><span class="line"><span class="number">004010</span>AA      E8 B7FFFFFF   call &lt;jmp.&amp;KERNEL32.ExitProcess&gt;</span><br><span class="line"><span class="number">004010</span>AF   .  C3            retn</span><br><span class="line"><span class="number">004010B</span>0      <span class="number">90</span>            nop</span><br><span class="line"><span class="number">004010B</span>1      <span class="number">90</span>            nop</span><br><span class="line"><span class="number">004010B</span>2      <span class="number">90</span>            nop</span><br><span class="line"><span class="number">004010B</span>3      <span class="number">90</span>            nop</span><br><span class="line"><span class="number">004010B</span>4      <span class="number">90</span>            nop</span><br><span class="line"><span class="number">004010B</span>5      <span class="number">90</span>            nop</span><br><span class="line"><span class="number">004010B</span>6      <span class="number">90</span>            nop</span><br><span class="line"><span class="number">004010B</span>7      <span class="number">90</span>            nop</span><br><span class="line"><span class="number">004010B</span>8  /$  <span class="number">8B</span>7424 <span class="number">0</span>C     mov esi,dword ptr ss:[esp+<span class="number">0xC</span>]           ;  结构异常处理程序; Structured exception handler</span><br><span class="line"><span class="number">004010B</span>C  |.  <span class="number">64</span>:A1 <span class="number">3000000</span>&gt;mov eax,dword ptr fs:[<span class="number">0x30</span>]</span><br><span class="line"><span class="number">004010</span>C2  |.  <span class="number">8078</span> <span class="number">02</span> <span class="number">01</span>    cmp byte ptr ds:[eax+<span class="number">0x2</span>],<span class="number">0x1</span>            ;  判断BeingDebugged的值是否为<span class="number">1</span></span><br><span class="line"><span class="number">004010</span>C6  |.  <span class="number">75</span> <span class="number">0</span>C         jnz <span class="keyword">short</span> seh_add1<span class="number">.004010</span>D4              ;  没有处于调式状态时，进行跳转</span><br><span class="line"><span class="number">004010</span>C8  |.  C786 B8000000&gt;mov dword ptr ds:[esi+<span class="number">0xB8</span>],seh_add1<span class="number">.004</span>&gt;;  把EIP修改为<span class="number">40108</span>e,弹出消息提示框</span><br><span class="line"><span class="number">004010</span>D2  |.  EB <span class="number">0</span>A         jmp <span class="keyword">short</span> seh_add1<span class="number">.004010</span>DE</span><br><span class="line"><span class="number">004010</span>D4  |&gt;  C786 B8000000&gt;mov dword ptr ds:[esi+<span class="number">0xB8</span>],seh_add1<span class="number">.004</span>&gt;;  把EIP修改为原OEP</span><br><span class="line"><span class="number">004010</span>DE  |&gt;  <span class="number">33</span>C0          <span class="keyword">xor</span> eax,eax</span><br><span class="line"><span class="number">004010E0</span>  \.  C3            retn</span><br></pre></td></tr></table></figure>

<p>4.在内存窗口，可以看到该汇编代码对应的 shellcode。通过手动的方式添加反调试代码必然麻烦，那么就需要开发一个工具来实现 seh 反调试的添加功能.该工具的实现思路是：加载 PE 文件到内存中-&gt;在代码段处查找空白代码区,记录该区的地址-》搜索空白代码区，添加 debugging 字符串-&gt;计算调用函数的汇编代码-》修改 shellcode，导出 PE 文件到磁盘中。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1595216435393-22a18548-b2a2-4e6c-9369-20f33dff1b16.png#align=left&display=inline&height=210&margin=%5Bobject%20Object%5D&originHeight=210&originWidth=764&size=0&status=done&style=none&width=764"> 5.工具实现的重要的代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">CAllToolDlg::PEFileToMemory</span><span class="params">(LPSTR lpszFile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *pFile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    LPVOID pFileBuffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">errno_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(err = fopen_s(&amp;pFile, lpszFile, <span class="string">&quot;wr+&quot;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 无法打开 EXE 文件! &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取文件大小</span></span><br><span class="line">    fseek(pFile, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    fileSize = ftell(pFile);</span><br><span class="line">    fseek(pFile, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="comment">//分配缓冲区</span></span><br><span class="line">    pFileBuffer = <span class="built_in">malloc</span>(fileSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将文件数据读取到缓冲区</span></span><br><span class="line">    <span class="keyword">size_t</span> n = fread(pFileBuffer, fileSize, <span class="number">1</span>, pFile);</span><br><span class="line">    <span class="keyword">if</span> (!n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 读取数据失败! &quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(pFileBuffer);</span><br><span class="line">        fclose(pFile);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    fclose(pFile);</span><br><span class="line">    <span class="keyword">return</span> pFileBuffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索代码段空白代码</span></span><br><span class="line"><span class="function">DWORD <span class="title">CAllToolDlg::FindEmptyCodeAndModifyShellCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//把exe文件加载进内存</span></span><br><span class="line">    <span class="comment">//pFileBuffer = PEFileToMemory(strpath);</span></span><br><span class="line">    DWORD* DPointer = (DWORD*)pFileBuffer;</span><br><span class="line">    BYTE* BPointer = (BYTE*)pFileBuffer;</span><br><span class="line">    DWORD ImageBase = *(DPointer + <span class="number">59</span>);</span><br><span class="line">    DWORD AddrEP = *(DPointer + <span class="number">56</span>);</span><br><span class="line">    <span class="comment">//修改OEP的值</span></span><br><span class="line">    ModifyShellCode(ImageBase + AddrEP, <span class="number">0x6E</span>);</span><br><span class="line">    <span class="comment">//记录空白代码区的起始地址</span></span><br><span class="line">    DWORD BeginAddr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找出空白代码区的起始地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0x1000</span>; j &lt; <span class="number">0x1000</span>/<span class="number">4</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(DPointer + j) == <span class="number">0x0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">30</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            BeginAddr = j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//AddressOfEntryPoint修改后的值</span></span><br><span class="line">    DWORD AfterAddrEP = BeginAddr*<span class="number">4</span> + <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改AddressOfEntryPoint</span></span><br><span class="line">    *(DPointer + <span class="number">56</span>) = AfterAddrEP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取MessageBoxA和EXitProcess的十六进制编码并修改</span></span><br><span class="line">    DWORD MessageBoxA = AddrMessageBoxA - (<span class="number">0x400000</span> + AfterAddrEP + <span class="number">0x2D</span> + <span class="number">0x5</span>);</span><br><span class="line">    ModifyShellCode(MessageBoxA,<span class="number">0x2E</span>);</span><br><span class="line">    DWORD EXitProcess = AddrEXitProcess  - (<span class="number">0x400000</span> + AfterAddrEP + <span class="number">0x3E</span> + <span class="number">0x5</span>);</span><br><span class="line">    ModifyShellCode(EXitProcess, <span class="number">0x3F</span>);</span><br><span class="line">    <span class="keyword">return</span> AfterAddrEP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//搜索数据段空白数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CAllToolDlg::FindEmptyDataAndAddData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    DWORD BeginAddr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0x3000</span>; j &lt; <span class="number">0x1000</span>/<span class="number">4</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(DPointer + j) == <span class="number">0x0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">3</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            BeginAddr = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改内存数据</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(BPointer + i + BeginAddr) = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD AddrData = <span class="number">0x3000</span> + BeginAddr * <span class="number">4</span> + <span class="number">0x400000</span>;</span><br><span class="line">    ModifyShellCode(AddrData, <span class="number">0x28</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CAllToolDlg::WriterToPEFileAndDisk</span><span class="params">(DWORD Addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(BPointer + i + Addr) = ShellCode[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入磁盘中</span></span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;seh_add.exe&quot;</span>, ios::out | ios::trunc)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!out.is_open())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件创建失败！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index&lt;fileSize; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; *(BPointer + index);</span><br><span class="line">    &#125;</span><br><span class="line">    out.close();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1595216435286-eeb4a16c-7a4a-4e09-9c81-a853b61cefdc.png#align=left&display=inline&height=226&margin=%5Bobject%20Object%5D&originHeight=226&originWidth=767&size=0&status=done&style=none&width=767"><br>解决方案：<br>NOP 掉异常的代码<br>把触发异常的代码 NOP 掉，就能阻止反调试代码的运行，思路为：1.在 OD 中手动修改后另存；2.使用内存修改的方式，nop 掉触发异常的代码，大致代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hpro = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">WriteProcessMemory(hpro, (LPVOID)Addr, buff, <span class="number">4</span>,<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>

<h1 id="TLS-反调试"><a href="#TLS-反调试" class="headerlink" title="TLS 反调试"></a>TLS 反调试</h1><p>1.在 C++开发中，会经常遇到 TLS(线程局部存储)回调函数。该函数有一个非常大的特点就是在线程运行前要先运行该函数，那么只需要在 TLS 回调函数中，写上反调试功能的代码，就可以有反调试功能，而不需要修改 OEP，来执行反调试代码。使用 PEView 打开某程序，在 PE 扩展头中，如果 TLS Table 项中两个字段值都为 0， 则该程序没使用 TLS 回调函数，否则就用了。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1595216435323-d136a28c-833a-4d85-89e4-b397c15cc95f.png#align=left&display=inline&height=129&margin=%5Bobject%20Object%5D&originHeight=129&originWidth=714&size=0&status=done&style=none&width=714"> 2.接着我往程序中添加 TLS 反调试功能，需要修改和读取、添加的值如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">读取值：</span><br><span class="line">节表数量：Word(value(<span class="number">0x3C</span>)+<span class="number">0x4</span>+<span class="number">0x02</span>)</span><br><span class="line">PE扩展头的地址：value(<span class="number">0x3C</span>)+<span class="number">0x4</span>+<span class="number">0x14</span></span><br><span class="line">最后节表位置：addr(PE扩展头)+<span class="number">0xE0</span>+<span class="number">0x28</span>*(节表数量<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">修改值：</span><br><span class="line">PE扩展头修改的字段及偏移：</span><br><span class="line"></span><br><span class="line">TLS表偏移：<span class="number">0xA8</span></span><br><span class="line">RVA(偏移:<span class="number">0xA8</span>):ReadDword(最后节表+<span class="number">0xC</span>)+<span class="number">0x200</span>+<span class="number">0x1000</span>*(节表数量<span class="number">-1</span>)</span><br><span class="line">Size(偏移：<span class="number">0xAC</span>):-&gt;<span class="number">0x18</span></span><br><span class="line"></span><br><span class="line">最后节表结构修改的字段及偏移：</span><br><span class="line">SizeOfRawData(+<span class="number">0x8</span>):+<span class="number">0x200</span></span><br><span class="line">PointerToRawData(+<span class="number">0xC</span>):+<span class="number">0x200</span></span><br><span class="line">Characteristics(+<span class="number">0x1C</span>):<span class="number">40</span>-&gt;E0</span><br><span class="line"></span><br><span class="line">在PE文件末尾添加<span class="number">0x200</span>空白区域，写入的数据如下：</span><br><span class="line">偏移            值</span><br><span class="line"><span class="number">0x0</span>              <span class="number">0x400000</span>+TLS表.Size+TLS表.RVA</span><br><span class="line"><span class="number">0x4</span>               上面的值+<span class="number">0x4</span></span><br><span class="line"><span class="number">0x8</span>               上面的值+<span class="number">0x4</span></span><br><span class="line"><span class="number">0xC</span>               上面的值+<span class="number">0x4</span></span><br><span class="line"><span class="number">0x10</span>               <span class="number">0</span></span><br><span class="line"><span class="number">0x14</span>               <span class="number">0</span></span><br><span class="line"><span class="number">0x24</span>              <span class="number">0x400000</span>+TLS表.RVA+<span class="number">0x30</span>  <span class="comment">//TLS回调函数地址</span></span><br></pre></td></tr></table></figure>

<p>3.从上面可以看出，在 PE 文件末尾添加的是结构体_IMAGE_TLS_DIRECTORY32 中的内部字段值，该结构体如下，看出 TLS 回调函数要加载到 PE 文件中地址为：TLS 表.RVA+0x30 的地方。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_TLS_DIRECTORY32</span> &#123;</span></span><br><span class="line">  DWORD StartAddressOfRawData;</span><br><span class="line">  DWORD EndAddressOfRawData;</span><br><span class="line">  PDWORD AddressOfIndex;</span><br><span class="line">  PIMAGE_TLS_CALLBACK *AddressOfCallBacks;</span><br><span class="line">  DWORD SizeOfZeroFill;</span><br><span class="line">  DWORD Characteristics;</span><br><span class="line">  &#125; IMAGE_TLS_DIRECTORY32;</span><br></pre></td></tr></table></figure>

<p>4.先在 OD 的”0x400000+TLS 表.RVA+0x30”处添加反调试代码，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0040</span>C230    <span class="number">837</span>C24 <span class="number">08</span> <span class="number">01</span>    cmp dword ptr ss:[esp+<span class="number">0x8</span>],<span class="number">0x1</span></span><br><span class="line"><span class="number">0040</span>C235    <span class="number">75</span> <span class="number">28</span>           jnz  <span class="number">0040</span>C25F</span><br><span class="line"><span class="number">0040</span>C237    <span class="number">64</span>:A1 <span class="number">30000000</span>  mov eax,dword ptr fs:[<span class="number">0x30</span>]</span><br><span class="line"><span class="number">0040</span>C23D    <span class="number">8078</span> <span class="number">02</span> <span class="number">00</span>      cmp byte ptr ds:[eax+<span class="number">0x2</span>],<span class="number">0x0</span>                  ; 判断是否处于调式状态</span><br><span class="line"><span class="number">0040</span>C241    <span class="number">74</span> <span class="number">1</span>C           je  <span class="number">0040</span>C25F</span><br><span class="line"><span class="number">0040</span>C243    <span class="number">6</span>A <span class="number">00</span>           push <span class="number">0x0</span></span><br><span class="line"><span class="number">0040</span>C245    <span class="number">68</span> <span class="number">70</span>C24000     push <span class="number">0x0</span></span><br><span class="line"><span class="number">0040</span>C24A    <span class="number">68</span> <span class="number">80</span>C24000     push <span class="number">0040</span>C280                         ; ASCII <span class="string">&quot;Debugging&quot;</span></span><br><span class="line"><span class="number">0040</span>C24F    <span class="number">6</span>A <span class="number">00</span>           push <span class="number">0x0</span></span><br><span class="line"><span class="number">0040</span>C251    FF15 E8804000   call dword ptr ds:[&lt;&amp;USER32.MessageBoxA&gt;]      ; user32.MessageBoxA</span><br><span class="line"><span class="number">0040</span>C257    <span class="number">6</span>A <span class="number">01</span>           push <span class="number">0x1</span></span><br><span class="line"><span class="number">0040</span>C259    FF15 <span class="number">28804000</span>   call dword ptr ds:[&lt;&amp;KERNEL32.ExitProcess&gt;]    ; kernel32.ExitProcess</span><br><span class="line"><span class="number">0040</span>C25F    C2 <span class="number">0</span>C00         retn <span class="number">0xC</span></span><br></pre></td></tr></table></figure>

<p>5.接着把上面代码对应的 shellcode，复制粘贴出来添加到 PE 文件中，接着开发工具来往程序中添加 TLS 反调试，实现的思路跟 SEH 反调试差不多，实现的代码(与 SEH 反调试类似的代码已省略)如下：。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取字段值</span></span><br><span class="line"><span class="function">VOID <span class="title">CAllToolDlg::ReadFieldValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pFileBuffer = PEFileToMemory(strPath);</span><br><span class="line">    <span class="keyword">if</span> (!pFileBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件读取失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否是有效的MZ标志</span></span><br><span class="line">    <span class="keyword">if</span> (*((PWORD)pFileBuffer) != IMAGE_DOS_SIGNATURE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不是有效的MZ标志\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(pFileBuffer);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer;</span><br><span class="line">    <span class="comment">//PE扩展头的地址</span></span><br><span class="line">    PEOptionalAddress = pDosHeader-&gt;e_lfanew+<span class="number">0x4</span>+<span class="number">0x14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否是有效的PE标志</span></span><br><span class="line">    <span class="keyword">if</span> (*((PDWORD)((DWORD)pFileBuffer + pDosHeader-&gt;e_lfanew)) != IMAGE_NT_SIGNATURE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不是有效的PE标志\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(pFileBuffer);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pFileBuffer + pDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">//节表数量</span></span><br><span class="line">    NumberOfSection = pPEHeader-&gt;NumberOfSections;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后节表位置</span></span><br><span class="line">    LastSectionAddr = PEOptionalAddress + pPEHeader-&gt;SizeOfOptionalHeader + (NumberOfSection - <span class="number">1</span>) * <span class="number">0x28</span>;</span><br><span class="line"></span><br><span class="line">    DWORD* DPointer = (DWORD*)pFileBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//PointerToRawData值</span></span><br><span class="line">    LastPointerToRawDataV = *(DPointer + LastSectionAddr+<span class="number">0xC</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改字段值</span></span><br><span class="line"><span class="function">VOID <span class="title">CAllToolDlg::ModifyMemoryValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改TLS表中的RVA值</span></span><br><span class="line">    *(DPointer + PEOptionalAddress + <span class="number">0xA8</span>) = LastPointerToRawDataV + <span class="number">0x200</span> + (NumberOfSection - <span class="number">1</span>) * <span class="number">0x28</span>;</span><br><span class="line">    <span class="comment">//修改TLS表中的Size值,_IMAGE_TLS_DIRECTORY32结构大小</span></span><br><span class="line">    *(DPointer + PEOptionalAddress + <span class="number">0xAC</span>) = <span class="number">0x18</span>;</span><br><span class="line">    <span class="comment">//SizeOfRawData值加0x200</span></span><br><span class="line">    *(DPointer + LastSectionAddr + <span class="number">0x8</span>) = *(DPointer + LastSectionAddr + <span class="number">0x8</span>) + <span class="number">0x200</span>;</span><br><span class="line">    <span class="comment">//PointerToRawData值加0x200</span></span><br><span class="line">    *(DPointer + LastSectionAddr + <span class="number">0xC</span>) = LastPointerToRawDataV + <span class="number">0x200</span>;</span><br><span class="line">    <span class="comment">//修改Characteristics值</span></span><br><span class="line">    *(BPointer + LastSectionAddr + <span class="number">0x1C</span>) = <span class="number">0xE0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给TLS结构体赋值</span></span><br><span class="line"><span class="function">VOID <span class="title">CAllToolDlg::WriterToNewTls</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD Value = <span class="number">0x400000</span> + <span class="number">0x18</span> + *(DPointer + PEOptionalAddress + <span class="number">0xA8</span>);</span><br><span class="line">    *(DPointer + fileSize + <span class="number">0x200</span>) = Value;</span><br><span class="line">    *(DPointer + fileSize + <span class="number">0x204</span>) = Value+<span class="number">0x4</span>;</span><br><span class="line">    *(DPointer + fileSize + <span class="number">0x208</span>) = Value + <span class="number">0x8</span>;</span><br><span class="line">    *(DPointer + fileSize + <span class="number">0x20C</span>) = Value + <span class="number">0xC</span>;</span><br><span class="line">    *(DPointer + fileSize + <span class="number">0x224</span>) = <span class="number">0x400000</span> +  *(DPointer + PEOptionalAddress + <span class="number">0xA8</span>)+<span class="number">0x30</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//往PE文件中写入TLS回调函数,同WriterToPEFileAndDisk</span></span><br></pre></td></tr></table></figure>

<p>解决方案：<br>删除 TLS 回调功能<br>TLS 表中的 RVA 处存放的是 TLS 结构体信息，Size 字段记录的是 TLS 结构体的大小，把这两个字段的值设成 0，就能删除 TLS 回调函数。实现的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改TLS表中的RVA值</span></span><br><span class="line">*(DPointer + PEOptionalAddress + <span class="number">0xA8</span>) = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//修改TLS表中的Size值</span></span><br><span class="line">*(DPointer + PEOptionalAddress + <span class="number">0xAC</span>) = <span class="number">0</span>;</span><br><span class="line">再写入磁盘中，就删除了。</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Cyberangel</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cyberangel.cn/2020/07/20/%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%B0%8F%E7%BB%93/">https://cyberangel.cn/2020/07/20/%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%B0%8F%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cyberangel.cn" target="_blank">Cyberangel-blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/20/%E5%9C%A8Visual%20Studio%E4%B8%AD%E7%BC%96%E5%86%99C++%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">在Visual Studio中编写C++内嵌汇编语言</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/16/angr%E5%AD%A6%E4%B9%A0%EF%BC%884%EF%BC%89%EF%BC%9A%E8%A1%A5%E5%85%85%EF%BC%881%EF%BC%89--%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%90%AFPIE%E4%BF%9D%E6%8A%A4/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">angr学习（4）：补充（1）--程序开启PIE保护</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Cyberangel</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">317</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BeingDebugged-%E5%88%A4%E6%96%AD%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">BeingDebugged 判断法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F-Ldr-%E6%88%90%E5%91%98%E5%86%85%E5%AD%98%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">扫描 Ldr 成员内存法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%9A%90%E8%97%8F%E4%BB%A3%E7%A0%81%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">数据隐藏代码法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SEH-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">SEH 反调试法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TLS-%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-number">6.</span> <span class="toc-text">TLS 反调试</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/06/10/%E5%88%A9%E7%94%A8mprotect%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E6%AE%B5%E6%9D%83%E9%99%90%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C/" title="利用mprotect修改程序段权限为可执行"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="利用mprotect修改程序段权限为可执行"/></a><div class="content"><a class="title" href="/2021/06/10/%E5%88%A9%E7%94%A8mprotect%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E6%AE%B5%E6%9D%83%E9%99%90%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C/" title="利用mprotect修改程序段权限为可执行">利用mprotect修改程序段权限为可执行</a><time datetime="2021-06-10T07:59:46.000Z" title="发表于 2021-06-10 15:59:46">2021-06-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/31/SROP%EF%BC%881%EF%BC%89--%E4%BB%8E%E4%B8%A4%E9%81%93%E9%A2%98%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86SROP%20attack/" title="SROP（1）--从两道题重新认识SROP attack"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SROP（1）--从两道题重新认识SROP attack"/></a><div class="content"><a class="title" href="/2021/05/31/SROP%EF%BC%881%EF%BC%89--%E4%BB%8E%E4%B8%A4%E9%81%93%E9%A2%98%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86SROP%20attack/" title="SROP（1）--从两道题重新认识SROP attack">SROP（1）--从两道题重新认识SROP attack</a><time datetime="2021-05-31T02:14:53.000Z" title="发表于 2021-05-31 10:14:53">2021-05-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/18/how2heap(14)-unsortedbin%20attack/" title="how2heap(14)-unsortedbin attack"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="how2heap(14)-unsortedbin attack"/></a><div class="content"><a class="title" href="/2021/05/18/how2heap(14)-unsortedbin%20attack/" title="how2heap(14)-unsortedbin attack">how2heap(14)-unsortedbin attack</a><time datetime="2021-05-18T07:48:53.000Z" title="发表于 2021-05-18 15:48:53">2021-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/17/how2heap(13)-tcache_stashing_unlink_attack/" title="how2heap(13)-tcache_stashing_unlink_attack"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="how2heap(13)-tcache_stashing_unlink_attack"/></a><div class="content"><a class="title" href="/2021/05/17/how2heap(13)-tcache_stashing_unlink_attack/" title="how2heap(13)-tcache_stashing_unlink_attack">how2heap(13)-tcache_stashing_unlink_attack</a><time datetime="2021-05-17T02:16:40.000Z" title="发表于 2021-05-17 10:16:40">2021-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/14/how2heap(12)-house%20of%20lore/" title="how2heap(12)-house of lore"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="how2heap(12)-house of lore"/></a><div class="content"><a class="title" href="/2021/05/14/how2heap(12)-house%20of%20lore/" title="how2heap(12)-house of lore">how2heap(12)-house of lore</a><time datetime="2021-05-14T08:02:54.000Z" title="发表于 2021-05-14 16:02:54">2021-05-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Cyberangel</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>