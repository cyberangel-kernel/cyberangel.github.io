<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++期末复习试卷（5套） | Cyberangel-blog</title><meta name="author" content="Cyberangel"><meta name="copyright" content="Cyberangel"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="第一套：1 在用 class 定义一个类时，数据成员和成员函数的默认访问权限是   private         。2 定义内联函数用关键字   inline          。3 在 while 语句中可以使用   break           语句终止循环。.4 在 C++中，标准输入操作是由标准输入流对象   cin        完成的。5 设有语句”chars[]&#x3D;”china\0">
<meta property="og:type" content="article">
<meta property="og:title" content="C++期末复习试卷（5套）">
<meta property="og:url" content="https://cyberangel.cn/2020/01/07/C++%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E8%AF%95%E5%8D%B7%EF%BC%885%E5%A5%97%EF%BC%89/index.html">
<meta property="og:site_name" content="Cyberangel-blog">
<meta property="og:description" content="第一套：1 在用 class 定义一个类时，数据成员和成员函数的默认访问权限是   private         。2 定义内联函数用关键字   inline          。3 在 while 语句中可以使用   break           语句终止循环。.4 在 C++中，标准输入操作是由标准输入流对象   cin        完成的。5 设有语句”chars[]&#x3D;”china\0">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-01-07T15:30:21.000Z">
<meta property="article:modified_time" content="2021-07-04T09:57:27.783Z">
<meta property="article:author" content="Cyberangel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cyberangel.cn/2020/01/07/C++%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E8%AF%95%E5%8D%B7%EF%BC%885%E5%A5%97%EF%BC%89/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++期末复习试卷（5套）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-04 17:57:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Cyberangel-blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">317</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Cyberangel-blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++期末复习试卷（5套）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-01-07T15:30:21.000Z" title="发表于 2020-01-07 23:30:21">2020-01-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-04T09:57:27.783Z" title="更新于 2021-07-04 17:57:27">2021-07-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++期末复习试卷（5套）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><span class="disqus-comment-count"><a href="https://cyberangel.cn/2020/01/07/C++%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E8%AF%95%E5%8D%B7%EF%BC%885%E5%A5%97%EF%BC%89/#disqus_thread"></a></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第一套："><a href="#第一套：" class="headerlink" title="第一套："></a>第一套：</h1><p>1 在用 class 定义一个类时，数据成员和成员函数的默认访问权限是   private         <br>。<br>2 定义内联函数用关键字   inline          <br>。<br>3 在 while 语句中可以使用   break           <br>语句终止循环。.<br>4 在 C++中，标准输入操作是由标准输入流对象   cin        <br>完成的。<br>5 设有语句”char<br>s[]=”china\0nanjin”;int m=strlen(s);”则 m 的值为**<em>5</em>**     <br>。<br>6 在函数中调用自己的函数称为     <br>递归         <br>函数。<br>7 假定有如下定义：int <em>p；，为 p 动态分配内存且为该内存赋值为整数 10 的语句是_int <em>p=new int(10);<strong>_<strong>。<br>8 含有纯虚函数的类称为</strong>_抽象类</strong></em></em><strong>_<strong><strong>*<em><strong>。<br>9 假设：int<br>a[12]={1,4,7,10,2,5,8,11,3,6,9,12}，i=9; 试问 a[a[i]]对应的元素数值是   8              。<br>10 在二叉树中，如果一个节点没有后继节点，那么这种节点称为—叶子—              节点。<br>1<br>下列说法不正确的是（ D         ）。<br>A    在 main 函数中包含了 C 程序的入口和出口  <br>B    C 语言又被称作为函数的语言<br>C    C 程序的工作过程是编辑、编译、连接、运行<br>D    以上说法均不正确<br>2 已知：int a, &amp;ra=a;关于 ra 的描述中正确的是（    C       ）<br>A    ra 是 int 型变量 a 的地址值               B<br>a 是 int 型变量 ra 的地址值<br>C    ra 是 int 型变量 a 的引用                 D       ra 是 int 型变量 a 的指针<br>3 关于析构函数的描述，说法正确的是（  D        ）<br>A    析构函数可以有一个或多个参数//析构函数无任何参数        B 析构函数的定义只能在类体内（析构函数只能有一个，不能带参数，析构函数不能被重载，构造函数可以被重载，应该说有了类才能产生一个析构函数）<br>C    析构函数名与类名相同                D    析构函数不能重载<br>4 若有语句 int a=5;则执行语句 a+=a*=10;后，a 的值为（    B        ）<br>A    55           B    100               C          60                     D             105<br>5 int fun(int,int);不可与下列哪个函数构成重载（    B       ）<br>A   <br>int fun(int,int,int); (找不到任何一个函数的参数与调用的实参匹配，此时编译器会发出无法匹配的错误)                          B    double<br>fun(int,int);      <br>C   <br>double fun(double,double);                  D    double<br>fun(int,double);<br>6 若有说明语句“int a[5],*p=a;”,则对数组元素的正确引用是（  C  ）。<br>A    a[p]            B  p[a]              C     *(p+2)         D     p+2<br>7 下面程序的输出结果是（   D   ）。<br><strong>#include&lt;stdio.h&gt;**</strong>//*</strong>*注意**<strong>C++*</strong>*的惰性</em>*<br><strong>int main() **<br><strong>{</strong><br>**             int<br>a=-1, b=4, k;</strong><br>**             k=(++a&lt;=0)&amp;&amp;(b–&lt;=0);</strong><br>**             printf(“%d,%d,%d\n”,k,a,b);</strong><br>**              return 0;</strong><br><strong>}</strong><br>A    1,1,2      B     0,1,2           C    1,0,3            D    0,0,3<br>8 C++类体系中，不能被派生类继承的有<strong>D___</strong><br>A 虚函数 (不能被派生类继承的有构造函数，拷贝构造函数，赋值函数，析构函数)                            B 赋值操作函数<br>C 静态成员函数                        D 构造函数<br>9 下列虚基类的声明中，正确的是（ A    ）。(class 派生类名:virtual 继承方式 基类名)<br>A class B: virtual public<br>A          B class B: public virtual A<br>C virtual class B: public<br>A          D class virtual B: public A<br>10 下列说法中错误的是（  C        ）。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
</table>
<p>A  构成数组的所有元素的数据类型必须是相同的<br>B  用指针法引用数组元素允许数组元素的下标越界<br>C  一维数组元素的下标依次是 1、2、3……（从 0 开始）<br>D  定义数组时的长度可以是整型常量表达式<br>1 析构函数是一个没有返回值类型的成员函数。                                          （  对    ）<br>2 在 C++语言中，标识符 Max 和 MAX 是不一样的。                                 （   对      ）<br>3 switch 语句中必须有 break 语句。                                                         （    错      ）<br>4 设有定义一维数组如下：int a[5],*p=a;则表达式 p=p+1 是合法的。         （    对 a=a+1 不合法      ）<br>5 说明函数原型时不需要指明每个参数的类型，只需要说明每个参数的名字。（   错       ）<br>函数声明由函数返回类型、函数名和形参列表组成。形参列表必须包括形参类型,但是不必对形参命名。这三个元素被称为函数原型<br>6 派生类是从基类派生出来，它不能生成新的派生类。                               （    错      ）<br>7 函数重载可以实现动态多态，虚函数可以实现静态多态。               （  错        ）<br>8 类型向上兼容原则是指派生类指针可以指向基类对象。                          （    错      ）<br>9 构造函数的函数名和类名相同。                                                           （   对       ）<br>10 构造函数和析构函数都不能重载。                                                     （   错      ）<br>构造函数可以被重载，析构函数不能被重载<br>1        <br>写出下面程序的运行结果<br><strong>#include<iostream></strong><br><strong>using namespace std;</strong><br><strong>void fun(char p[], int n)</strong><br><strong>{   **<br><strong>int i=0, number_count=0;</strong><br>**              for(i=0;<br>i&lt;n; i++)</strong><br>**                     if(p[i]</p>
<blockquote>
<p>= ‘a’ &amp;&amp; p[i] &lt;= ‘z’)**<br>**                            number_count++;**<br>**              cout&lt;&lt;number_count&lt;&lt;endl;**<br><strong>}</strong><br>** **<br><strong>int main()</strong><br><em><em>{   **<br><strong>int len;</strong><br>**          char<br><em>s =”ab123cde568” ;**<br>**              len=strlen(s);</em></em><br>**              fun(s,len);</em>*<br>**              return<br>0;**<br><strong>}</strong></p>
</blockquote>
<p>结果:5</p>
<p>2     写出下面程序的运行结果<br>      <strong>#include &lt;stdio.h&gt;</strong><br><strong>void swap(int  a,     int      b)</strong><br><strong>{</strong><br>**              int c;**<br>**              c = a;**<br>**              a = b;**<br>**              b = c;**<br><strong>}</strong><br>** **<br><strong>int main()</strong><br><strong>{</strong><br>**              int x,y;**<br>**              x = 1;**<br>**              y = 2;**<br>**              swap(x,y);**<br>**              printf(“x = %d, y =<br>%d\n”,x,y);**<br>**              return 0;**<br><strong>}</strong></p>
<p>结果:x=1,y=2//值传递形参的改变对实参无任何影响</p>
<p>3     写出下面程序的运行结果<br><strong>#include<iostream></strong><br><strong>using namespace std;</strong><br><strong>class B1</strong><br><strong>{</strong><br><strong>public:</strong><br>**              B1()**<br><strong>{</strong><br><strong>cout&lt;&lt;”constuctor B1”&lt;&lt;endl;</strong><br><strong>}</strong><br><strong>};</strong><br>** **<br><strong>class B2:public B1</strong><br><strong>{</strong><br><strong>public:</strong><br><strong>B2()</strong><br><strong>{</strong><br><strong>cout&lt;&lt;”constuctor B2”&lt;&lt;endl;</strong><br><strong>}</strong><br><strong>~B2()</strong><br><strong>{</strong><br><strong>cout&lt;&lt;”destructor B2”&lt;&lt;endl;</strong><br><strong>}</strong><br><strong>};</strong><br><strong>{ int main()   **<br>**              B2<br>obj;</strong><br>**              return<br>0;**<br><strong>} **<br>** **<br>      结果:</strong>  constuctor B1**<br><strong>constuctor B2</strong><br><strong>destructor B2”</strong></p>
<p>4     写出下面程序的运行结果     <br>**#include “stdio.h”  <br>**<br>**int main()   **<br><strong>{   **<br>**          int<br>m[][3]={1,4,7,2,5,8,3,6,9};  **<br>**          int<br>i;   **<br>**          int<br>(*p)[3];   **<br>**          p<br>= m;   **<br>**          for(i<br>= 0; i &lt; 3; i++)   **<br>**          {   **<br>**                    printf(“%d<br>“, p[i][0]); **<br>**          }   **<br>**          return<br>0;</strong><br>** }     **<br>结果：1 2 3</p>
<p>5     写出下面程序的运行结果<br><strong>#include<iostream></strong><br><strong>using<br>namespace std;</strong><br><strong>class myclass</strong><br><strong>{</strong><br><strong>public:</strong><br>**       myclass(){cout&lt;&lt;”A”;}**<br>**       myclass(char<br>c){cout&lt;&lt;”C”;}**<br>**       ~myclass(){cout&lt;&lt;”B”;}**<br><strong>};</strong><br><strong>int main()</strong><br><strong>{</strong><br>**       myclass my1,my2(‘x’),*p1;**<br>**       p1=new myclass;**<br>**       delete p1;**<br>**       return 0;**<br><strong>}</strong><br>结果:ACABBB</p>
<p>1 从键盘上输入 10 个整数，编写函数，通过函数实现对这 10 个整数进行排序，使小数在前，大数在后。<br>2 Write down the following<br>classes and complete the correspondent functionalities(功能)（写出下列课程并完成相应功能）<br>(1)Please design an <strong>abstract<br>class</strong>（抽象类） named shape, which declared<br>two <strong>pure virtual function</strong> （纯虚函数）GetArea<br>() and GetPerimeter() to return its area(面积) and perimeter(周长).（请设计一个名为形状的抽象类，它声明两个纯虚函数得到区（）和得到周界（），以返回其面积和周界）<br>(2)<strong>Derive</strong> (派生)Circle and Rectangle classes from shape,（从形状推导出圆和矩形类）<br>(3)Assign a Circle or rectangle<br>object（对象）to a shape pointer（指针）, When we send member function GetArea () and GetPerimeter() to<br>the object s of pointer p1 and p2, the output is area and perimeter of Circle<br>and Rectangle objects.（将圆或者矩形对象指派给形状指针，当我们将成员函数 getarea()和 getarate()发送给指针 P1 和 P2 的对象时，输出的是圆和矩形对象的面积和周长）</p>
<h1 id="第二套："><a href="#第二套：" class="headerlink" title="第二套："></a>第二套：</h1><p>1.假定 A 为一个类，则语句 A(A &amp;a);为该类<strong>拷贝构造</strong>**_**<strong><strong>函数的原型说明。 2.在进行函数调用时，将把实参传递给</strong>_形参</strong>____*<em><strong>。 3.在定义该类的   对象         时,系统将自动调用该类的构造函数。 4.已知”char <em>p=”abcdef”; cout&lt;&lt;</em>(p+2);输出为 c</strong>___<strong>。 5.不论派生类以何种方式继承基类，都不能访问和使用基类的 private              成员 6.空字符串的长度是</strong>0___<strong>。 7.面向对象的特征是抽象、封装、继承和多态</strong>__<strong>。 8.派生类构造函数的执行顺序是先执行_基类</strong>___<strong>的构造函数，然后执行成员对象的构造函数，最后执行自身的构造函数。 9.假定一个函数的参数说明为 int x[]，则等价的指针参数说明为_int *x</strong>_<strong>。<br>10.The standard output stream object in c++ is <strong>cout</strong></strong></em>*__********。</p>
<p>1.一个函数为 void f(int,char=’a’)，另一个函数为 void f(int)，则它们_A**_<strong>。<br>A.可以在同一程序中定义，但不可以重载 B.不能在同一程序中定义<br>C.可以在同一程序中定义并可重载        D.以上说法均不正确 2.下面（  D       ）是析构函数的特征。<br>A.析构函数可以有多个                  B.析构函数可以有一个或多个参数<br>C.析构函数的定义只能在类体内          D.一个类中只能定义一个析构函数 3.关于构造函数特点的描述中，错误的是（ D       ）<br>A.构造函数的名字与该类的类名相同      B.一个类中可定义 0 至多个构造函数<br>C.构造函数是一种成员函数              D.定义构造函数必须指出类型//无返回值 4.在 C++语言里，语句以_A_</strong>_字符作为结束符。<br>A ；                                 B 无符号<br>C .                                  D ， 5.对重载函数形参的描述中，错误的是（  A         ）<br>A.参数的个数、类型相同，返回值类型不同 B.参数的个数或类型都不相同<br>C.参数的个数不同                      D.参数的类型不同 6.下面语句彼此等价的是 C。<br>A.!(a&gt;10)||(a&lt;0)   <br>!(a&lt;=10)&amp;&amp;!(a&gt;=0)B.!(a==b)      (a&gt;b)&amp;&amp;(a&lt;b)<br>C.!(a&lt;10)&amp;&amp;!(a&gt;0)  <br>!(a&lt;10)&amp;&amp;(a&gt;0)  <br>D.!(a&gt;b)      a&lt;b 7.定义如下枚举类型:enum Day{Monday,Tuesday,Wednesday,Thursday,Friday=2};则下列语句正确的是 D____*<em>。<br>A.Day day; day=Monday+3       <br>      B.Day day; day=Monday+10<br>C.Day day;day=3;                     D.表达式 Wednesday==Friday 的值时 true 8.下列关于纯虚函数和抽象类的描述中，错误的是（   B      ）<br>A.纯虚函数是一种特殊的虚函数，它没有具体的实现 B.抽象类可以声明对象<br>C.抽象类是指具有纯虚函数的类         <br>D.抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出 9.下列语句错误的是（  B       ）<br>A.char name[5]=”John”;name[2]=’a’;   B.char</em>p=”John”;p[2]=’a’;<br>C.char name[5]=”John”,*p=name;p[2]=’a’;<br>D.char name[5]=”John”,*p=&amp;name[2];*p=’a’; 10.整型变量 i 定义后赋初值的结果是 A。<br>int i=2.8*6<br>A.16                                 B.18<br>C.17                                 D.12</p>
<p>1.单继承情况下,派生类中对基类成员的访问也会出现二义性。 （  对        ）<br>2.There is only one destructor in a class.(一个类中只能有一个析构函数 对)<br>3.The OOP focuses mainly on the step-by-step procedure as  procedure-oriented  programming.。（OOP 主要侧重于作为面向过程的编程的逐步过程   错）<br>4.const 对象只能够访问 const 成员函数，non-const 对象只能够访问 non-const 成员函数。（错） 5.若类 A 是类 B 的友元类，且类 B 是类 C 的友元类，则类 A 也是类 C 的友元类。（  错        ） 6.用 new 运算符动态分配的存储空间若不用 delete 释放， 则程序运行结束后该空间会自动释放。（  错       ）<br>7.cout 是标准输入流对象。       （   错    ）<br>8.C++函数中如果一个参数设定了缺省值时，其右边的参数都要有缺省值。(对           ) 9.类的每一个成员函数的第一个参数都是隐藏的 this 指针。(    对           ) 10.一个类的友元关系可以被继承。                                    (      错    )</p>
<p>1.Please define a class named Student ,which include two<br>properties (name,age) and a const member sno, also having member functions:<br>1)    A constructor with<br>parameters to initialize the data members. (5 points)<br>2)    The copy constrctor.                                               (5<br>points)<br>Please declare a class named CoStudent, which is a kind of<br>student. The class should have a constructor at last, which should be defined<br>properly.                    (5 points)<br>2.1. Please define a class named Square(正方形) ,which include properties length, also define:<br>（1）A constructor that initialize the data members.<br>“      （2）A<br>member function get_area( ) that calculate the area of Square.<br>（3）A member function show_area( ) that output the area of Square.<br>  Write the main function to<br>test your class just defined.</p>
<p>1.下列程序的运行结果是                                              <br>#include<iostream><br>using<br>namespace std;<br>int<br>f(int x=5,int y=10);<br>int<br>main()<br>{<br>int x=6;<br>             cout&lt;&lt;f(x)&lt;&lt;endl;<br>              return 0;<br>}</p>
<p>int<br>f(int m,int n)<br>{<br>return m+n;<br>} 2. 下列程序的运行结果是<br>#include<iostream><br>using<br>namespace std;<br>class<br>base<br>{<br>public:<br>              void who()<br>{<br>cout&lt;&lt;”base class”&lt;&lt;endl;<br>}<br>};</p>
<p>class<br>derivel:public base<br>{<br>public:<br>void who()<br>{<br>cout&lt;&lt;”derivel class”&lt;&lt;endl;<br>}<br>};</p>
<p>class<br>derive2:public base<br>{<br>public:<br>void who()<br>{<br>       cout&lt;&lt;”derive2<br>class”&lt;&lt;endl;<br>}<br>};<br>int<br>main()<br>       {<br>              base obj1,*p;<br>              derivel obj2;<br>              derivel obj3;<br>              p=&obj1;<br>              p-&gt;who();<br>              p=&obj2;<br>              p-&gt;who();<br>              return 0;<br>       }</p>
<p>3.下面程序的运行结果是            <br>       #include<iostream><br>       using namespace std;<br>       void uprch (char <em>s)<br>       {<br>              int i,j;char</em>a;a=s;<br>              for(i=0,j=0;a[i]!=’\0’;i++,j++)<br>              {<br>                     if(a[i]&gt;=’a’&amp;&amp;a[i]&lt;=’z’)<br>                     {<br>                            a[i]=a[i]+’A’-‘a’;}<br>                            s[j]=a[i];<br>                     }    <br>                     s[j]=’\0’;<br>       }<br>       int main()<br>       {<br>              char context[]=”abc34def”;<br>              uprch (context);<br>              cout&lt;&lt; context;<br>              return 0；<br>       }</p>
<ol start="4">
<li>下面程序的运行结果是<br>       #include<iostream><br>       using namespace std;<br>       class A<br>       {<br>       protected:<br>              int n,m;<br>       public:<br>              void set(int a,int b)<br>              {<br>                     m=a;n=b;<br>              }<br>              void show()<br>              {<br>                     cout&lt;&lt;m&lt;&lt;”,”&lt;&lt;n&lt;&lt;endl;<br>              }<br>       };</li>
</ol>
<p>class B:public A<br>       {<br>              int s;<br>       public:<br>              void sets()<br>              {<br>                     s=m*n;<br>              }<br>              void shows()<br>              {<br>                     cout&lt;&lt;s&lt;&lt;endl;<br>              }<br>       };</p>
<p>int main()<br>       {<br>              B b;<br>              b.set(4,5);<br>              b.show();<br>              b.sets();<br>              b.shows();<br>              return 0;<br>       }</p>
<ol start="5">
<li>下面程序的运行结果是</li>
</ol>
<p>#include <iostream ><br>using namespace std;<br>class B1<br>{<br>public:<br>      B1()<br>       {<br>              cout &lt;&lt;<br>“Construct B1”&lt;&lt;endl;<br>       }<br>      ~B1()<br>       {<br>              cout&lt;&lt;<br>“Destruct B1” &lt;&lt; endl;<br>       }<br>};<br>class B2<br>{<br>public:<br>       B2()<br>       {<br>              cout &lt;&lt;<br>“Construct B2” &lt;&lt; endl;<br>       }<br>      ~B2()<br>       {<br>              cout &lt;&lt;<br>“Destruct B2 “ &lt;&lt; endl;<br>       }<br>};<br>class D : public B2, public B1<br>{<br>public:<br>       D() : B2( ), B1( )<br>       {<br>              cout &lt;&lt;<br>“Construct D” &lt;&lt; endl;<br>       }<br>  ~D()<br>       {<br>             cout &lt;&lt; “Destruct D”<br>&lt;&lt;endl;<br>       }<br> private:<br>   B2  b2;<br>   B1  b1;<br>};<br>int main()<br>{<br>      D d;<br>       return 0; <br>}<br>** **<br>** **</p>
<h1 id="第三套："><a href="#第三套：" class="headerlink" title="第三套："></a>第三套：</h1><p>** ** 1.当保护继承时，基类的 public 成员和 protected 成员成为派生类的_protected*<em><strong>__<strong><strong>成员。 2.定义内联函数使用的关键字是 inline。 3.在二叉树中，如果一个节点没有后继节点，那么这种节点称为    叶子            节点。 4.在 C++中，标准输入操作是由标准输入流对象</strong>_<strong>cin</strong>___<strong>完成的。 5.设有语句”char s[]=”china\0nanjin”;int m=strlen(s);”则 m 的值为_5</strong>_</strong>      。 6.在 while 语句中可以使用_</strong>_break</em>*____*<strong>*语句终止循环。 7.假定有如下定义：int *p；，为 p 动态分配内存且为该内存赋值为整数 10 的语句是_int _p=new int(10);**__<strong>。 8.含有纯虚函数的类称为</strong>抽象类</strong>****__**<strong><strong><strong>。 9.假设：int a[12]={1,4,7,10,2,5,8,11,3,6,9,12}，i=9;则 a[a[i]]对应的元素数值是</strong>_8</strong></strong>__<em>*<strong><strong>。 10.使用_const</strong></strong>_<strong><strong>关键字说明的对象称为常对象，在定义常对象时必须进行初始化。<br>下列对结构及其变量定义错误的是(        A    )。<br>A.struct{<br>int num;char ch;}My;<br>B.struct{int<br>num; char ch;};<br>C.struct<br>MyStruct { int num; char ch;};<br>D.struct<br>MyStruct{int num;char ch;}My; 2.下述静态数据成员的特性中，(C          )是错误的。<br>A.说明静态数据成员时前边要加修饰符 static<br>B.静态数据成员要在类体外进行初始化<br>C.静态成员函数可以访问普通成员       <br>D.引用静态数据成员时，要在静态数据成员前加&lt;类名&gt;和作用域运算符 3.关于析构函数的描述，说法正确的是（   D       ）<br>A.析构函数可以有一个或多个参数        B.析构函数的定义只能在类体内<br>C.析构函数可以重载                     D.析构函数不能重载 4.若有整形变量 x=7,y=8,z=3,则表达式 x^y&amp;-z 的结果是（C     ）<br>A.18      B.16       C.15       D.17 5.已知 int m = 10; 正确表示引用的是(D       )<br>A.int<br>&amp;t = 10;                       B.int<br>&amp;t = &m;<br>C.int<br>&t;  t = m;                    D.int &amp;t = m; 6.下列说明中 int _ const ptr;  ptr 应该是（ A       ）。<br>A.指向整形常量的常量指针              B.指向整形变量的常量指针<br>C.指向整形变量的变量指针              D.指向整形常量的变量指针 7.下面程序的输出结果是（  D        ）。<br>#include&lt;stdio.h&gt;<br>int  main()<br>{<br>             int a=-1, b=4, k;<br>             k=(++a&lt;=0)&amp;&amp;(b–&lt;=0);<br>             printf(“%d,%d,%d\n”,k,a,b);<br>              return 0；<br>}<br>A.1,1,2                              B. 0,1,2<br>C.1,0,3                              D.0,0,3<br>8.C++类体系中，不能被派生类继承的有</strong>_D__</strong><br>A.虚函数                              B.赋值操作函数<br>C.静态成员函数                        D.构造函数 9.下列虚基类的声明中，正确的是（ D    ）。<br>A.class<br>virtual B: public A          B.class B:<br>public virtual A<br>C.virtual<br>class B: public A          D.class B:<br>virtual public A<br>10.int <em>p,a[3][10];p=a ; 则下列数组元素 a[i][j]的表示方法中正确的是（  B          ）。<br>A.</em>(*(p+i)+j)                        B.p+10</em>i+j<br>C.<em>(<br>p+i)+j                         <br>D.</em>(p+i*10+j)</p>
<p>1..构造函数是一个没有返回值类型的成员函数。                             （  对    ）<br>2.C++中 cout 和 cin 是单目运算符。                                        （  错    ） 3.局部静态对象和全局静态对象都具有全局寿命。                   （  对    ）<br>4.C++ could set a Base pointer or reference to a Derived object.    （    对   ）（C++可以设置基指针或对派生对象的引用） 5.结构体占用的内存大小是它不同类型的数据内存的总和。     （ 错     ） 6.派生类是从基类派生出来，它不能生成新的派生类。            （ 错     ） 7.函数重载可以实现动态多态，虚函数可以实现静态多态。     （ 错     ） 8.类型向上兼容原则是指派生类指针可以指向基类对象。        （  错    ） 9.构造函数的函数名和类名相同。                                             （ 对     ） 10.构造函数和析构函数都不能重载。                                       （ 错     ）</p>
<ol>
<li><p>please define a class named person ,which include three properties (name,<br> sex,id), also define:<br> （1）A constructor with three parameters.<br> （2）A member function setInfo() that set the information of data<br> member.<br> （3）A member function showInfo() that show the information of data<br> member.<br> 2..<br> Write down the following classes and complete the correspondent functionalities<br> (1)   Please design an abstract class named shape,<br> which declared two pure virtual function GetArea () and GetPerimeter().<br> (2)   Derive Circle and Rectangle classes from<br> shape,,<br> (3)   Assign a Circle or rectangle object to a<br> shape pointer, When we send member function GetArea () and GetPerimeter() to<br> the object s of pointer p1 and p2, the output is area and perimeter of Circle<br> and Rectangle objects.</p>
<p> 1.#include<iostream><br> using namespace std;<br> class B<br> {public:<br>        B( int i) {b=i-10;}<br> virtual void show()       {<br> cout&lt;&lt;”b=”&lt;&lt;b&lt;&lt;endl;}<br> protected:<br>        int b;<br> };<br> class D: public B<br> {public:<br>        D( int i): B(i){<br> d=i+10;}<br>        void<br> show(){cout&lt;&lt;”d=”&lt;&lt;d&lt;&lt;endl;}<br> protected:<br>        int d;<br> };   <br>   void main()<br> {<br>        D d1(100);<br>        B b1(200);<br> d1.show ();<br>        b1.show ();<br>        D *pd=&d1;<br>        pd-&gt;show ();<br>        B *pb=&d1;<br>        pb-&gt;show ();}<br> 2.#include<iostream><br> using namespace std;<br> class B0<br> {   int aa;<br>        int bb;<br> public:<br>        B0(int i,int j){aa=i;<br> bb=j;}<br>        void show()<br>        {cout&lt;&lt;aa&lt;&lt;’<br> ‘&lt;&lt;bb&lt;&lt;’ ‘;}<br> };<br> class B1:public B0<br> {<br>        int cc;<br> public:<br> B1(int i,int j,int k):B0(i,j)<br>        { <br>               cc=k;<br>        };<br>        void disp()<br>        {   show();<br>            cout&lt;&lt;cc &lt;&lt;endl;<br>        }<br> };<br> void main()<br> {<br>        B1 obj(6,7,8);<br>        obj.disp();<br> }<br> 3.#include<iostream><br> using namespace std;<br> class B1<br> {<br> public:<br>        B1()<br> {cout&lt;&lt;”constuctor B1”&lt;&lt;endl;}<br> };<br> class B2:public B1<br> {<br> public:</p>
</li>
</ol>
<p>B2()<br>{cout&lt;&lt;”constuctor B2”&lt;&lt;endl;}<br>~B2()<br>{cout&lt;&lt;”destructor B2”&lt;&lt;endl;}<br>};<br>int main()<br>{  <br>       B2 obj;<br>       return 0;<br>}<br>4.#include “stdio.h”</p>
<p>int main()  <br>{  <br>    int<br>m[][3]={1,4,7,2,5,8,3,6,9}; <br>    int i;  <br>    int (*p)[3];  <br>    p = m;  <br>    for(i = 0;i<br>&lt;3;i++)  <br>    {  <br> printf(“%d”,*p[i]);<br>    }  <br>    return 0; }    <br>结果：             5.下面程序的运行结果<br>#include<iostream><br>using namespace std;<br>class myclass<br>{<br>public:<br>       myclass(){cout&lt;&lt;”A”;}<br>       myclass(char<br>c){cout&lt;&lt;”C”;}<br>       ~myclass(){cout&lt;&lt;”B”;}<br>};<br>int main()<br>{<br>       myclass<br>my1,my2(‘x’),*p1;<br>       p1=new myclass;<br>       delete p1;<br>       return 0;<br>}</p>
<h1 id="第四套："><a href="#第四套：" class="headerlink" title="第四套："></a>第四套：</h1><p>1 在用 class 定义一个类时，数据成员和成员函数的默认访问权限是   private         。<br>2 定义内联函数用关键字    inline          。<br>3 在 while 语句中可以使用    break           语句终止循环。.<br>4 在 C++中，标准输入操作是由标准输入流对象   cin          完成的。<br>5 设有语句”char s[]=”china\0nanjin”;int m=strlen(s);”则 m 的值为<strong>5__</strong>      。<br>6 在函数中调用自己的函数称为   递归             函数。。<br>7 假定有如下定义：int <em>p；，为 p 动态分配内存且为该内存赋值为整数 10 的语句是_int <em>p=new int(10);<strong>_<strong>。<br>8 含有纯虚函数的类称为</strong>抽象类</strong>**</em></em>__**<strong>*<em><strong>。<br>9 假设：int a[12]={1,4,7,10,2,5,8,11,3,6,9,12}，i=9; 试问 a[a[i]]对应的元素数值是    8             。<br>10 在二叉树中，如果一个节点没有后继节点，那么这种节点称为    叶子             节点。<br>1<br>下列说法不正确的是</strong>D</em>*</strong>__<strong>*<em><strong>。<br>A    在 main 函数中包含了 C 程序的入口和出口<br>B     C 语言又被称作为函数的语言<br>C     C 程序的工作过程是编辑、编译、连接、运行<br>D    以上说法均不正确<br>2 已知：int a,<br>&amp;ra=a;关于 ra 的描述中正确的是</strong>C</em>*</strong>__<em><strong><em><strong>。<br>A    ra 是 int 型变量 a 的地址值              B  <br>a 是 int 型变量 ra 的地址值<br>C     ra 是 int 型变量 a 的引用                D   ra 是 int 型变量 a 的指针<br>3 关于析构函数的描述，说法正确的是_</strong>_C</em>*____*<strong><em>。<br>A    析构函数可以有一个或多个参数        B      析构函数的定义只能在类体内<br>C     析构函数名与类名相同                D      析构函数不能重载<br>4 若有语句 int a=5;则执行语句 a+=a</em>=10;后，a 的值为</strong>_B</strong></em>*_*<strong><em><strong>。<br>A    55     <br>       B     100               C        60 <br>                    D        105<br>5 int<br>fun(int,int);不可与下列哪个函数构成重载_</strong>_B</em>*____*<strong><em>。<br>A    int fun(int,int,int);                     B     double fun(int,int);      <br>C     double fun(double,double);             D    double fun(int,double);<br>6 若有说明语句“int a[5],<em>p=a;”,则对数组元素的正确引用是</em></em>_C</strong></strong>_<strong>*<em><strong>。<br>A    a[p]            B      p[a]              C  *(p+2)         D   p+2<br>7 下面程序的输出结果是</strong>D</em>*</strong>__<strong>*<em><strong>。<br>#include&lt;stdio.h&gt;<br>int<br>main()<br>{<br>             int<br>a=-1, b=4, k;<br>             k=(++a&lt;=0)&amp;&amp;(b–&lt;=0);<br>             printf(“%d,%d,%d\n”,k,a,b);<br>              return<br>0;<br>}<br>A    1,1,2      B<br>0,1,2            C     1,0,3             D    0,0,3<br>8 C++类体系中，不能被派生类继承的有</strong>D</em>*</strong>__<strong><strong><strong>。<br>A 虚函数                              B 赋值操作函数<br>C 静态成员函数                        D 构造函数<br>9 下列虚基类的声明中，正确的是</strong>_D</strong></strong>_<strong><strong><strong>。<br>A class virtual B: public A          B class B: public virtual A<br>C virtual class B: public A          D class B: virtual public A<br>10<br>下列说法中错误的是</strong>_C</strong></strong>_******。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
</table>
<p>A   构成数组的所有元素的数据类型必须是相同的<br>B  用指针法引用数组元素允许数组元素的下标越界<br>C  一维数组元素的下标依次是 1、2、3……<br>D  定义数组时的长度可以是整型常量表达式</p>
<p>1 析构函数是一个没有返回值类型的成员函数。                                      （  对       ）<br>2 在 C++语言中，标识符 Max 和 MAX 是不一样的。                              （   对        ）<br>3 switch 语句中必须有 break 语句。                                                          （  错        ）<br>4 设有定义一维数组如下：int<br>a[5],*p=a;则表达式 p=p+1 是合法的。         （   对      ）<br>5 说明函数原型时不需要指明每个参数的类型，只需要说明每个参数的名字。（   错       ）<br>6 派生类是从基类派生出来，它不能生成新的派生类。                            （    错       ）<br>7 函数重载可以实现动态多态，虚函数可以实现静态多态。                    （   错       ）<br>8 类型向上兼容原则是指派生类指针可以指向基类对象。                        （   错       ）<br>9 构造函数的函数名和类名相同。                                                           （    对       ）<br>10 构造函数和析构函数都不能重载。                                                      （  错        ）</p>
<p>1        <br>写出下面程序的运行结果<br>#include<iostream><br>using<br>namespace std;<br>void<br>fun(char p[], int n)<br>{  <br>int i=0, number_count=0;<br>              for(i=0; i&lt;n; i++)<br>                     if(p[i] &gt;= ‘a’ &amp;&amp; p[i] &lt;= ‘z’)<br>                            number_count++;<br>              cout&lt;&lt;number_count&lt;&lt;endl;<br>}</p>
<p>int<br>main()<br>{  <br>int len;</p>
<p>char *s<br>=”ab123cde568” ;<br>              len=strlen(s);<br>              fun(s,len);<br>              return 0;<br>}</p>
<p>结果:</p>
<p>2     写出下面程序的运行结果<br>      #include &lt;stdio.h&gt;<br>void<br>swap(int  a, int       b)<br>{<br>              int<br>c;<br>              c<br>= a;<br>              a<br>= b;<br>              b<br>= c;<br>}</p>
<p>int<br>main()<br>{<br>              int<br>x,y;<br>              x<br>= 1;<br>              y<br>= 2;<br>              swap(x,y);<br>              printf(“x<br>= %d, y = %d\n”,x,y);<br>              return<br>0;<br>}</p>
<p>结果:</p>
<p>3     写出下面程序的运行结果<br>#include<iostream><br>using<br>namespace std;<br>class<br>B1<br>{<br>public:<br>              B1()<br>{<br>cout&lt;&lt;”constuctor B1”&lt;&lt;endl;<br>}<br>};</p>
<p>class<br>B2:public B1<br>{<br>public:<br>B2()<br>{<br>cout&lt;&lt;”constuctor B2”&lt;&lt;endl;<br>}<br>~B2()<br>{<br>cout&lt;&lt;”destructor B2”&lt;&lt;endl;<br>}<br>};<br>int<br>main()<br>{  <br>              B2 obj;<br>              return 0;<br>}<br>       结果:<br>4     写出下面程序的运行结果   <br>#include<br>“stdio.h”  <br>int<br>main()  <br>{</p>
<p>int<br>m[][3]={1,4,7,2,5,8,3,6,9};</p>
<p>int i;</p>
<p>int (*p)[3];</p>
<p>p = m;</p>
<p>for(i = 0; i &lt; 3; i++)</p>
<p>{  <br>                    printf(“%d”,<br>*p[i]);</p>
<p>}</p>
<p>return 0;<br> }    <br>结果：</p>
<p>5     写出下面程序的运行结果<br>#include<iostream><br>using namespace std;<br>class myclass<br>{<br>public:<br>       myclass(){cout&lt;&lt;”A”;}<br>       myclass(char<br>c){cout&lt;&lt;”C”;}<br>       ~myclass(){cout&lt;&lt;”B”;}<br>};<br>int main()<br>{<br>       myclass<br>my1,my2(‘x’),*p1;<br>       p1=new<br>myclass;<br>       delete<br>p1;<br>       return<br>0;<br>}<br>结果:</p>
<p>1 从键盘上输入 10 个整数，编写函数，通过函数实现对这 10 个整数进行排序，使小数在前，大数在后。</p>
<p>2 Write down the following classes and complete the correspondent<br>functionalities<br>(1)Please design an <strong>abstract class</strong>（抽象类） named shape, which declared two <strong>pure virtual function</strong> （纯虚函数）GetArea () and<br>GetPerimeter() to return its area(面积) and perimeter(周长).<br>(2)<strong>Derive</strong> (派生)Circle and Rectangle classes from shape,,<br>(3)Assign a Circle or rectangle object（对象）to a shape pointer（指针）, When we send member function<br>GetArea () and GetPerimeter() to the objects of pointer p1 and p2, the output<br>is area and perimeter of Circle and Rectangle objects.</p>
<h1 id="第五套："><a href="#第五套：" class="headerlink" title="第五套："></a>第五套：</h1><p>1.假定 A 为一个类，则语句 A(A &amp;a);为该类<strong>_拷贝构造函数</strong>____<strong><strong>函数的原型说明。 2.在进行函数调用时，将把实参传递给</strong>_形参</strong>____<strong><strong>。 3.在销毁类的对象时，系统将自动调用类的_</strong>_构造函数**</strong>__<strong>*<em><strong>。 4.已知 char _p=”abcdef”;  cout&lt;&lt;_(p+2);<br>输出为 c**___**。 5.不论派生类以何种方式继承基类，都不能访问和使用基类的   private。 6.空字符串的长度是*0**__**。 7.面向对象的特征是抽象、封装、继承和多态**__**。 8.派生类构造函数的执行顺序是先执行*基类**___**的构造函数，然后执行成员对象的构造函数，最后执行自身的构造函数。 9.假定一个函数的参数说明为 int x[]，则等价的指针参数说明为_int *x**_**。<br>10.The standard output stream object in c++ is **cout******__********。<br>1.     <br>同一作用域中，一个函数为 void f(int,char)，另一个函数为 void f(int)，则它们_C**_**。<br>A. Override（覆盖）        B. Hidden（隐藏）<br>C. Overload （重载）      <br> D. 重复定义错误 2.下面（ D       ）**是**析构函数的特征。<br>A.析构函数可以有多个                  B.析构函数可以有一个或多个参数<br>C.析构函数的定义只能在类体内          D.一个类中只能定义一个析构函数 3.关于构造函数特点的描述中，**错误**的是（  D       ）<br>A.构造函数的名字与该类的类名相同      B.一个类中可定义多个构造函数<br>C.构造函数是一种成员函数              D.定义构造函数必须指出类型 4.在 C++语言里，语句以_C***作为结束符。<br>A  .                                 B 无符号<br>C  ;                                 D ， 5.对重载函数形参的描述中，**错误**的是（  A         ）<br>A.参数的个数、类型相同，返回值类型不同 B.参数的个数或类型都不相同<br>C.参数的个数不同                      D.参数的类型不同 6.下面语句彼此**等价**的是***C**_**。<br>A.!((a&gt;10)||(a&lt;0))    !(a&lt;=10)||!(a&gt;=0)           B.!(a==b)      (a&gt;b)&amp;&amp;(a&lt;b)<br>C. !(a&gt;b)      a&lt;=b               D.!(a&lt;10)&amp;&amp;!(a&gt;20)   !(a&lt;10)&amp;&amp;(a&gt;20) 7.定义如下枚举类型:enum Day{Monday = 0,Tuesday,Wednesday,Thursday,Friday};则下列语句</strong>正确</em>*的是_D</strong>_<strong>。<br>A.Day day; day=Monday-1;     <br>        B.Day day; day=Monday+10;<br>C.Day day; day=3;                     D.表达式 Wednesday==Friday 的值时 true 8.下列关于纯虚函数和抽象类的描述中，</strong>错误<strong>的是（B         ）<br>A.纯虚函数是一种特殊的虚函数，它没有具体的实现<br>B.抽象类可以声明对象<br>C.抽象类是指具有纯虚函数的类         <br>D.抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出 9.下列语句</strong>错误*<em>的是（ B        ）<br>A.char name[5]=”John”;name[2]=’a’;  <br>B.char</em>p=”John”;p[2]=’a’;<br>C.char name[5]=”John”,*p=name; p[2]=’a’;<br>D.char name[5]=”John”,*p=&amp;name[2]; <em>p=’a’; 10. int i=2.8</em>6，则整形变量 i 定义后赋初值的结果是_A____。<br>A.16                                 B.18<br>C.17                        <br>        D.12 1.单继承情况下,派生类中对基类成员的访问也会出现二义性。                   (对          ) 2. There is only one destructor in a class.                                                         (对          )<br>3.The OOP focuses mainly on the step-by-step procedure as  procedure-oriented  programming.。                                                                                               (      错    )<br>4.const 对象只能够访问 const 成员函数，non-const 对象只能够访问 non-const 成员函数。<br>                                                                                                                       (      错    ) 5.若类 A 是类 B 的友元类，且类 B 是类 C 的友元类，则类 A 也是类 C 的友元类。                                                                                                                             (      错    ) 6.用 new 运算符动态分配的存储空间若不用 delete 释放， 则程序运行结束后该空间会自动释放。                                                                                                     (      错    )<br>7.cout 是单目运算符。                                                                                    (      错    )<br>8.C++函数中如果一个参数设定了缺省值时，其右边的参数都要有缺省值。 (    对    ) 9.类的非静态成员函数的第一个参数都是隐藏的 this 指针。                          (      对    ) 10.一个类的友元关系可以被继承。                                                                (      错    )</p>
<table>
<thead>
<tr>
<th>** **</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>Please define a class named Student, which include two<br>properties (<em>name</em>, <em>age</em>) and a <strong>const</strong> member <em>sno</em>, also<br>having member functions:<br>1)    A constructor with<br>parameters to initialize the data members.        (3<br>points)<br>2)    The copy constrctor.                                                                    (3 points)<br>3)    Please declare a class<br>named <strong>CoStudent</strong>, which is** a kind of** student. The class should<br>have a constructor at last, which should be defined properly.                         (4 points)</li>
<li>编写程序，输入两个正整数，输出它们的最大公约数。      (10 分) 1.下列程序的运行结果是                                              <br>#include<iostream><br>using<br>namespace std;<br>int<br>f(int x=5,int y=10);<br>int<br>main()<br>{<br>int x=6;<br>             cout&lt;&lt;f(x)&lt;&lt;endl;<br>              return 0;<br>}</li>
</ol>
<p>int<br>f(int m,int n)<br>{<br>return m+n;<br>}</p>
<ol start="2">
<li>下列程序的运行结果是<br>#include<iostream><br>using<br>namespace std;<br>class CBase<br>{<br>public:<br>              void who()<br>{<br>cout&lt;&lt;”Base class”&lt;&lt;endl;<br>}<br>};</li>
</ol>
<p>classCDerived:<br>public CBase<br>{<br>public:<br>void who()<br>{<br>cout&lt;&lt;”Derived class”&lt;&lt;endl;<br>}<br>};</p>
<p>int<br>main()<br>       {<br>              CBase obj1,*p;<br>              CDerived obj2;</p>
<p>p=&obj1;<br>              p-&gt;who();</p>
<p>p=&obj2;<br>              p-&gt;who();<br>              return 0;<br>       }</p>
<p>3.下面程序的运行结果是            <br>       #include<iostream><br>       using namespace std;<br>       void uprch (char *s)<br>       {<br>              while(*s != 0)<br>              {<br>                     if( *s</p>
<blockquote>
<p>= ‘a’ &amp;&amp; *s &lt;= ‘z’)<br>                     {<br>                            *s<br>= *s + ‘A’ – ‘a’;<br>                     }<br>                     s++;<br>              }<br>       }</p>
</blockquote>
<p>int main()<br>       {<br>              char context[]=”abc34def”;<br>              uprch (context);<br>              cout&lt;&lt; context&lt;&lt;endl;<br>              return 0；<br>       }</p>
<ol start="4">
<li>下面程序的运行结果是<br>       #include<iostream><br>       using namespace std;<br>       class A<br>       {<br>       protected:<br>              int n, m;<br>       public:<br>              void set(int a,int b)<br>              {<br>                     m=a;<br>                     n=b;<br>              }<br>              void show()<br>              {<br>                     cout&lt;&lt;m&lt;&lt;”,”&lt;&lt;n&lt;&lt;endl;<br>              }<br>       };</li>
</ol>
<p>class B:public A<br>       {<br>              int s;<br>       public:<br>              void set()<br>              {<br>                     s=m*n;<br>              }<br>              void show()<br>              {<br>                     cout&lt;&lt;s&lt;&lt;endl;<br>              }<br>       };</p>
<p>int main()<br>       {<br>              B b;<br>              b.A::set(4,5);<br>              b.A::show();<br>              b.set();<br>              b.show();<br>              return 0;<br>       }</p>
<ol start="5">
<li>下面程序的运行结果是<br>#include <iostream ><br>using namespace std;</li>
</ol>
<p>class B1<br>{<br>public:<br>      B1()<br>       {<br>              cout &lt;&lt;<br>“Construct B1”&lt;&lt;endl;<br>       }<br>      ~B1()<br>       {<br>              cout&lt;&lt;<br>“Destruct B1” &lt;&lt; endl;<br>       }<br>};</p>
<p>class B2<br>{<br>public:<br>       B2()<br>       {<br>              cout &lt;&lt;<br>“Construct B2” &lt;&lt; endl;<br>       }<br>      ~B2()<br>       {<br>              cout &lt;&lt;<br>“Destruct B2 “ &lt;&lt; endl;<br>       }<br>};</p>
<p>class D : public B2, public B1<br>{<br>public:<br>       D() : B2( ), B1( )<br>       {<br>              cout &lt;&lt;<br>“Construct D” &lt;&lt; endl;<br>       }<br>  ~D()<br>       {<br>             cout &lt;&lt; “Destruct D”<br>&lt;&lt;endl;<br>       }<br> private:<br>   B1  b1;<br>   B2  b2;<br>};</p>
<p>int main()<br>{<br>      D d;<br>       return 0; <br>}</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Cyberangel</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cyberangel.cn/2020/01/07/C++%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E8%AF%95%E5%8D%B7%EF%BC%885%E5%A5%97%EF%BC%89/">https://cyberangel.cn/2020/01/07/C++期末复习试卷（5套）/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cyberangel.cn" target="_blank">Cyberangel-blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/01/15/C++%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%AF%A6%E8%A7%A3/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++纯虚函数和抽象类详解</div></div></a></div><div class="next-post pull-right"><a href="/2020/01/07/C++%E8%99%9A%E5%87%BD%E6%95%B0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%BB%A5%E5%8F%8A%E6%9E%84%E6%88%90%E5%A4%9A%E6%80%81%E7%9A%84%E6%9D%A1%E4%BB%B6/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++虚函数注意事项以及构成多态的条件</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E5%A5%97%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">第一套：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%A5%97%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">第二套：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E5%A5%97%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">第三套：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E5%A5%97%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">第四套：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E5%A5%97%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">第五套：</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Cyberangel</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">为世界上所有美好而战！！！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://cyberangel.cn/2020/01/07/C++%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E8%AF%95%E5%8D%B7%EF%BC%885%E5%A5%97%EF%BC%89/'
    this.page.identifier = '2020/01/07/C++期末复习试卷（5套）/'
    this.page.title = 'C++期末复习试卷（5套）'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Disqus' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script><script>if (window.DISQUSWIDGETS === undefined) {
  var d = document, s = d.createElement('script');
  s.src = 'https://.disqus.com/count.js';
  s.id = 'dsq-count-scr';
  (d.head || d.body).appendChild(s);
} else {
  DISQUSWIDGETS.getCount({reset: true});
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>