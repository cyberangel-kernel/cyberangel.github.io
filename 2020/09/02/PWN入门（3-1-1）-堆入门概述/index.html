<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>PWN入门（3-1-1）-堆入门概述 | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="参考资料：https:&#x2F;&#x2F;www.anquanke.com&#x2F;post&#x2F;id&#x2F;163971 &gt; https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41988448&#x2F;article&#x2F;details&#x2F;103685794 &gt; https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;484926468136 &gt; https:&#x2F;&#x2F;www.freebuf.com&#x2F;vuls&#x2F;98404.html">
<meta property="og:type" content="article">
<meta property="og:title" content="PWN入门（3-1-1）-堆入门概述">
<meta property="og:url" content="http://example.com/2020/09/02/PWN%E5%85%A5%E9%97%A8%EF%BC%883-1-1%EF%BC%89-%E5%A0%86%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="参考资料：https:&#x2F;&#x2F;www.anquanke.com&#x2F;post&#x2F;id&#x2F;163971 &gt; https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41988448&#x2F;article&#x2F;details&#x2F;103685794 &gt; https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;484926468136 &gt; https:&#x2F;&#x2F;www.freebuf.com&#x2F;vuls&#x2F;98404.html">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-09-02T10:21:24.000Z">
<meta property="article:modified_time" content="2021-07-04T09:57:16.707Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2020/09/02/PWN%E5%85%A5%E9%97%A8%EF%BC%883-1-1%EF%BC%89-%E5%A0%86%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PWN入门（3-1-1）-堆入门概述',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-04 17:57:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">317</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">PWN入门（3-1-1）-堆入门概述</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-09-02T10:21:24.000Z" title="Created 2020-09-02 18:21:24">2020-09-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-07-04T09:57:16.707Z" title="Updated 2021-07-04 17:57:16">2021-07-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="PWN入门（3-1-1）-堆入门概述"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>参考资料：<br><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/163971">https://www.anquanke.com/post/id/163971</a> &gt; <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41988448/article/details/103685794">https://blog.csdn.net/qq_41988448/article/details/103685794</a> &gt; <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/484926468136">https://www.jianshu.com/p/484926468136</a> &gt; <a target="_blank" rel="noopener" href="https://www.freebuf.com/vuls/98404.html">https://www.freebuf.com/vuls/98404.html</a> &gt; <a target="_blank" rel="noopener" href="https://wiki.x10sec.org/pwn/heap/heap_structure/">https://wiki.x10sec.org/pwn/heap/heap_structure/</a></p>
</blockquote>
<h1 id="什么是堆？"><a href="#什么是堆？" class="headerlink" title="什么是堆？"></a>什么是堆？</h1><p>首先先明确一下堆的概念，堆不同于栈，堆是（由操作系统内核或者堆管理器）动态分配的，<strong>只有在程序中需要时才会分配</strong>。在 CTF 的 pwn 程序中，栈是程序加载进内存后就会出现，而堆是由 malloc、alloc、realloc 函数分配内存后才会出现。<br>windows 和 linux 下的堆分配、管理方式都不同，<strong>这里主要讲到的是 CTF 中常出现的 linux 下的堆分配知识</strong><br>先看看堆在虚拟内存中的位置<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599042244857-50522209-16c2-42c6-a125-6e5cd9fa4822.png#align=left&display=inline&height=420&margin=%5Bobject%20Object%5D&name=tJh93VO.png&originHeight=420&originWidth=599&size=19618&status=done&style=none&width=599" alt="tJh93VO.png"><br>堆的生长方向是从低地址向高地址生长的，而栈是从高地址向低地址生长的。<br><strong>实际上堆可以申请到的内存空间比栈要大很多，在 linux 的 4G 的虚拟内存空间里最高可以达到 2.9 G 的空间</strong></p>
<blockquote>
<p><strong>对堆操作的是由堆管理器（ptmalloc2）来实现的，而不是操作系统内核。因为程序每次申请或者释放堆时都需要进行系统调用，系统调用的开销巨大，当频繁进行堆操作时，就会严重影响程序的性能</strong></p>
</blockquote>
<p>下面的分析都是以** glibc 库下的 ptmalloc2** 堆管理器来讲解的。</p>
<h1 id="堆的基本结构"><a href="#堆的基本结构" class="headerlink" title="堆的基本结构"></a>堆的基本结构</h1><blockquote>
<p><strong>pre size（prev size）和 size 头统称为 chunk 头（chunk header）</strong><br>每次 malloc 申请得到的内存指针，其实指向 <code>user data</code> 的起始处。</p>
</blockquote>
<p>堆的大致图解如下：<br>**</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599303198197-3da2e450-f854-42c1-a020-2c887c193800.png#align=left&display=inline&height=319&margin=%5Bobject%20Object%5D&name=RlseGG7.png&originHeight=567&originWidth=666&size=17101&status=done&style=none&width=375" alt="RlseGG7.png"></h2><h2 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h2><p>首先来看一下 malloc_chunk 的结构</p>
<h3 id="malloc-chunk-结构"><a href="#malloc-chunk-结构" class="headerlink" title="malloc_chunk 结构"></a>malloc_chunk 结构</h3><p>每个程序分配的内存（这里指的是 malloc 函数）在内部被一个叫做”<strong>堆块</strong>”的所替代。<strong>一个堆块是由元数据和程序返回的内存组成的（实际上内存是 malloc 的返回值）。</strong>所有的这些堆块都是保存在堆上，这块内存区域在申请新的内存时会不断的扩大。同样，当一定数量的内存释放时，堆可以收缩。在 glibc 源码中定义的堆块如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">  <span class="comment">//一般来说，size_t 在 64 位中是 64 位无符号整数，32 位中是 32 位无符号整数。</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>假设内存中没有堆块释放，新分配的内存区域紧随之前申请的堆块后。因此如果一个程序依次调用 malloc(256),malloc(512),以及 malloc(1024)，内存布局如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Meta-<span class="function">data of chunk created by <span class="title">malloc</span><span class="params">(<span class="number">256</span>)</span></span></span><br><span class="line"><span class="function">The 256 bytes of memory <span class="keyword">return</span> by <span class="built_in">malloc</span></span></span><br><span class="line"><span class="function">-----------------------------------------</span></span><br><span class="line"><span class="function">Meta-data of chunk created by <span class="title">malloc</span><span class="params">(<span class="number">512</span>)</span></span></span><br><span class="line"><span class="function">The 512 bytes of memory <span class="keyword">return</span> by <span class="built_in">malloc</span></span></span><br><span class="line"><span class="function">-----------------------------------------</span></span><br><span class="line"><span class="function">Meta-data of chunk created by <span class="title">malloc</span><span class="params">(<span class="number">1024</span>)</span></span></span><br><span class="line"><span class="function">The 1024 bytes of memory <span class="keyword">return</span> by <span class="built_in">malloc</span></span></span><br><span class="line"><span class="function">-----------------------------------------</span></span><br><span class="line"><span class="function">Meta-data of the top chunk</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#堆的生长方向是从低地址向高地址生长的</span></span><br></pre></td></tr></table></figure>

<p>在堆块之间的”—”是虚拟的边界，实际当中他们是彼此相邻的。你可能会问，为何我要在布局当中包含一个”顶块”元数据（top chunk）。<strong>顶级块表示堆中可利用的内存，而且是唯一的可以大小可以生长的堆块。</strong>当申请新的内存时，顶块分成两个部分：第一个部分变成所申请的堆块，第二个部分变为新的顶块（因此顶块大小可以收缩）。如果顶块不能够满足申请的内存区域大小，程序就会要求操作系统扩大顶块（让堆继续生长）。被释放的 chunk 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, <span class="function"><span class="keyword">if</span> <span class="title">unallocated</span> <span class="params">(P clear)</span>  |</span></span><br><span class="line"><span class="function">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">`head:&#x27; |             Size of chunk, in bytes                     |A|0|P|</span></span><br><span class="line"><span class="function">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">        |             Forward pointer to next chunk in <span class="built_in">list</span>             |</span></span><br><span class="line"><span class="function">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">        |             Back pointer to previous chunk in <span class="built_in">list</span>            |</span></span><br><span class="line"><span class="function">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">        |             Unused <span class="title">space</span> <span class="params">(may be <span class="number">0</span> bytes <span class="keyword">long</span>)</span>                .</span></span><br><span class="line"><span class="function">        .                                                               .</span></span><br><span class="line"><span class="function"> next   .                                                               |</span></span><br><span class="line"><span class="function">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">`foot:&#x27; |             Size of chunk, in bytes                           |</span></span><br><span class="line"><span class="function">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">        |             Size of next chunk, in bytes                |A|0|0|</span></span><br><span class="line"><span class="function">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br></pre></td></tr></table></figure>

<p>一般情况下，**物理相邻的两个空闲 chunk 会被合并为一个 chunk **。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。</p>
<h3 id="1-pre-size-字段"><a href="#1-pre-size-字段" class="headerlink" title="1.pre size 字段"></a>1.pre size 字段</h3><blockquote>
<p>pre size（prev size）全称为 previous size</p>
</blockquote>
<ul>
<li><code>pre_size</code>, 如果该 chunk 的物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）是<strong>空闲</strong>的话，<strong>那该字段记录的是前一个 chunk 的**<strong>大小*</strong>* (包括 chunk 头)<strong>。否则，该字段</strong>可以用来存储物理相邻的前一个 chunk 的**<strong>数据</strong>。这里的前一 chunk 指的是较低地址的 chunk 。</strong>前面一个堆块在使用时并且 pre_size 为储存前面 chunk 的数据时，他的值始终为 0**<blockquote>
<p>堆的生长方向为：低地址向高地址生长。</p>
</blockquote>
</li>
</ul>
<h3 id="2-size-字段"><a href="#2-size-字段" class="headerlink" title="2.size 字段"></a>2.size 字段</h3><p><strong><code>size</code>**</strong> ，*<strong>*这个是用来指示当前堆块的大小的（头部（pre size+size）加上 user data 的大小）</strong>。大小必须是 2 _ SIZE_SZ 的整数倍。如果申请的内存大小不是 2 _ SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。<br><strong>32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8</strong>。 该字段的低三个比特位对 chunk 的大小没有影响，字段的最后<strong>三位</strong>相当于三个 flag ，这三位的作用分别是：<br><code>A（NON_MAIN_ARENA）</code>：为 0 表示该 chunk 属于<strong>主分配区（主线程）</strong>，为 1 表示该 chunk 属于<strong>非主分配区（非主线程）</strong><br><code>M（IS_MAPPED）</code>：表示当前 chunk 是从哪个内存区域获得的虚拟内存。为 1 表示该 chunk 是从<strong>mmap</strong>映射区域分配的，否则是从<strong>heap</strong>区域分配的<br><code>P（PREV_INUSE）</code>：记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599042679373-a4438ff3-2f52-45c7-a36e-f1013367ce0b.png#align=left&display=inline&height=443&margin=%5Bobject%20Object%5D&name=VejSHfX.png&originHeight=443&originWidth=837&size=22272&status=done&style=none&width=837" alt="VejSHfX.png"></p>
<blockquote>
<p>所以前一个堆块的释放与否都和这两个字段（pre_size、size-&gt;prev_inuse）的值有关，这是因为便于内存的释放操作（free）</p>
</blockquote>
<h3 id="3-user-data"><a href="#3-user-data" class="headerlink" title="3.user data"></a>3.user data</h3><p>顾名思义就是用来存放用户数据的。<br>使用 malloc 函数分配到的内存的返回值指针是<strong>指向 user data （用户数据区）</strong>，在后面的例子中也会讲到这个问题。<br><strong>例如在 64 位程序中：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<p>申请到的堆块总大小为 16 + 8 + 8 + 1 = 0x21（byte） 1.第一个 16 字节是<strong>系统最小分配的内存</strong>，也就是说你如果想要申请的内存小于系统最小分配的内存的话，就会按照最小的内存来分配。</p>
<ul>
<li><p>在 64 位系统中这个值是 16 个字节，在 32 位系统中是 8 个字节</p>
</li>
<li><p>例如，如果代码中是 malloc(0) 的话，<strong>堆管理器也会分配最小内存空间给你</strong></p>
<p>2.第二个 8 字节是 pre size 字段的大小（32 位的为 4 字节） 3.第三个 8 字节为 size 字段的大小（32 位的为 4 字节） 4.最后一个 1 字节是 <strong>PREV_INUSE 的值，只有 0 或 1 两个值</strong></p>
<blockquote>
<p><strong>整理一下：堆的基本结构包括 pre_size、size、userdata</strong> &gt; <strong>size 字段包括：</strong>头部（pre size+size）加上 user data 的大小<br><strong>malloc 出最小大小为：系统最小分配内存+pre_size 字段+size 字段+prev_inuse（**<strong>此处存疑*</strong>*）</strong></p>
</blockquote>
</li>
</ul>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><h3 id="使用中（分配后）"><a href="#使用中（分配后）" class="headerlink" title="使用中（分配后）"></a>使用中（分配后）</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599299513017-b38c7227-1492-4407-a21f-05596091a5e9.png#align=left&display=inline&height=257&margin=%5Bobject%20Object%5D&originHeight=257&originWidth=581&size=0&status=done&style=none&width=581"></p>
<h3 id="空闲中（使用后）"><a href="#空闲中（使用后）" class="headerlink" title="空闲中（使用后）"></a>空闲中（使用后）</h3><ol>
<li>空闲中的 chunk 不存在 M 状态，只有 A|P 状态</li>
<li><strong>user data 头部被分配</strong>出两个成员，fd 和 bk<img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599300845878-ff3e7074-0ca2-48d4-a058-e03e8324ffb7.png#align=left&display=inline&height=265&margin=%5Bobject%20Object%5D&originHeight=265&originWidth=585&size=0&status=done&style=none&width=585"></li>
</ol>
<ul>
<li><p><code>fd</code>，<code>bk</code>。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下</p>
<ul>
<li><code>fd</code> 指向前一个（<strong>非物理相邻</strong>）空闲 chunk 的起始地址，32 位占 4 字节，64 位占 8 字节</li>
<li><code>bk</code> 指向后一个（<strong>非物理相邻</strong>）空闲 chunk 的起始地址，32 位占 4 字节，64 位占 8 字节</li>
<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理<blockquote>
<p>注意：事实上，<strong>释放后的 large block</strong>中还存在另外两个成员：fd_nextsize 和 bk_nextsize，上图并未画出，其简介如下：</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>fd_nextsize</code>， <code>bk_nextsize</code>，是只有 chunk <strong>空闲</strong>的时候才使用，不过其用于较大的 chunk（large chunk）。</p>
<ul>
<li><strong>fd_nextsize</strong> 指向前一个与当前 chunk 大小不同的第一个空闲块，<strong>不包含 bin 的头指针</strong>。</li>
<li><strong>bk_nextsize</strong> 指向后一个与当前 chunk 大小不同的第一个空闲块，<strong>不包含 bin 的头指针</strong>。<blockquote>
<p>一般空闲的 large chunk 按照由大到小的顺序排列， 在 fd 的遍历时，可以避免在寻找合适 chunk 时对所有 chunk 进行遍历。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="堆块大小"><a href="#堆块大小" class="headerlink" title="堆块大小"></a>堆块大小</h2><p><strong>32 位操作系统</strong>：</p>
<ol>
<li>用户分配到的最小堆块大小为<code>17B</code>：<strong>prev_size</strong>(4B) + <strong>size</strong>(4B) + <strong>fd</strong>(4B) + <strong>bk</strong>(4B) + <strong>next_chunk-&gt;p(1B)</strong></li>
<li>若用户申请的大小超过最小堆块大小，会与<strong>8B</strong>进行对齐</li>
</ol>
<p><strong>64 位操作系统</strong>：</p>
<ol>
<li>用户分配到的最小堆块大小为<code>33B</code>：<strong>prev_size</strong>(8B) + <strong>size</strong>(8B) + <strong>fd</strong>(8B) + <strong>bk</strong>(8B) + <strong>next_chunk-&gt;p(1B)</strong></li>
<li>若用户申请的大小超过最小堆块大小，会与<strong>16B</strong>进行对齐</li>
</ol>
<h2 id="空间复用"><a href="#空间复用" class="headerlink" title="空间复用"></a>空间复用</h2><p><strong>描述</strong>：<strong>当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 无效</strong>。所以下一个 chunk 的 prev_size 也可以被当前 chunk 使用，这就是 chunk 的空间复用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, <span class="function"><span class="keyword">if</span> <span class="title">unallocated</span> <span class="params">(P clear)</span>  |</span></span><br><span class="line"><span class="function">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">        |             Size of chunk, in bytes                     |A|M|P|</span></span><br><span class="line"><span class="function">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">        |             User data starts here...                          .</span></span><br><span class="line"><span class="function">        .                                                               .</span></span><br><span class="line"><span class="function">        .             <span class="params">(malloc_usable_size() bytes)</span>                      .</span></span><br><span class="line"><span class="function">next    .                                                               |</span></span><br><span class="line"><span class="function">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">        |             <span class="params">(size of chunk, but used <span class="keyword">for</span> application data)</span>    |</span></span><br><span class="line"><span class="function">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">        |             Size of next chunk, in bytes                |A|0|1|</span></span><br><span class="line"><span class="function">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br></pre></td></tr></table></figure>

<h1 id="指针与地址"><a href="#指针与地址" class="headerlink" title="指针与地址"></a>指针与地址</h1><p>指针这一块知识在 c 语言里学的不太好的，可以在学习堆的过程中慢慢巩固一下知识。</p>
<ul>
<li>熟练掌握指针的使用在堆的题目分析中还是很有帮助的。下面简单说一下堆分配中的指针会用到了地方。</li>
</ul>
<p>首先要明确用户在调用 malloc 函数时返回的值为<strong>一个指针，指向分配到堆空间（**<strong>用户数据区*</strong>*）</strong>，这个在最前面的那个图片也已经标出来了。<br>有时候题目是以更复杂的情况，用指针来表示某个数据结构的，例如下面的这个图中的例子：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599096423681-bc5b8b24-b4c0-418b-932e-c10541b79ce2.png#align=left&display=inline&height=349&margin=%5Bobject%20Object%5D&name=lpMMPHl.png&originHeight=702&originWidth=814&size=42068&status=done&style=none&width=405" alt="lpMMPHl.png"><br>first chunk（second chunk）表示第一和第二个结构，<strong>每个结构中都有一个 point_heap 指针来指向存储用户数据的堆块（chunk）。</strong><br><strong>左边的这个本身就是一个堆块，用来存放一些全局信息</strong>。比如 max_size 存储了能够存储的最大结构数量；exist_num 表示已经存储的结构的数量。</p>
<h2 id="IDA-中常见的指针表示形式"><a href="#IDA-中常见的指针表示形式" class="headerlink" title="IDA 中常见的指针表示形式"></a>IDA 中常见的指针表示形式</h2><p>在 IDA 伪代码中的指针形式形如下面的情况：</p>
<blockquote>
<p>*(qword_6020A8 + 8)</p>
</blockquote>
<p><strong>表示取到 qword_6020A8 这个地址加 8 偏移的那个地址存储的值</strong><br>汇编代码等同于：</p>
<blockquote>
<p>.text:0000000000400F85                 mov     rax, cs:qword_6020A8<br>.text:0000000000400F8C                 mov     rax, [rax+8]</p>
</blockquote>
<p>简单转化一下，也就是：<br>*(addr) = [addr]</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>在 pwn 的堆题目中，经常会有像一些”笔记管理系统”之类的题目，例如下面这里例子<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599120933393-a3988554-43c4-4967-b687-1e7fa0d3b994.png#align=left&display=inline&height=233&margin=%5Bobject%20Object%5D&name=9mQhGPF.png&originHeight=233&originWidth=404&size=7583&status=done&style=none&width=404" alt="9mQhGPF.png"><br>代码提供了最基本的增删查改的功能。这个”笔记”的数据结构<strong>通常就是使用链表连接起来的</strong>，记录了当前 note 的大小、属性、内容等等。<br><strong>例如，下面这个例子就是以指针为基础来存储这个 note 结构的</strong>。这里的 i 代表 note 的索引，若这里的 i = 0 时：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599120962277-427b4e66-72af-48e9-8199-3620bc98179e.png#align=left&display=inline&height=50&margin=%5Bobject%20Object%5D&name=n366Lzt.png&originHeight=50&originWidth=411&size=3133&status=done&style=none&width=411" alt="n366Lzt.png"><br>(qword_6020A8 + 16) 就*代表从 qword_6020A8 这个地址出再往后偏移 16 个字节，取到这个地址存储的值，接着把 1 赋值给这个地方（也就是把 1 存入这个地址）<br>同样的 *(qword_6020A8 + 24) 就代表偏移 24 个字节处的值为 len<br>依次类推就可以在不连续的内存空间中，把整个 note 的数据结构存储下来了。</p>
<h1 id="申请堆块的本质"><a href="#申请堆块的本质" class="headerlink" title="申请堆块的本质"></a>申请堆块的本质</h1><blockquote>
<p>堆管理器 ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。</p>
</blockquote>
<p>ptmalloc2 的作用通俗的讲就是<strong>相当于一个”中间商”</strong>，在程序想要申请向系统申请堆空间时，这里的 ptmalloc2 就会申请一块很大的空间，并根据算法从这些内存中把空间真正的分配给程序。<br>简单点说就是下面这个图中的情况：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599121087545-181347d6-feba-4bf9-94e2-bb5b8c6dbeaf.png#align=left&display=inline&height=266&margin=%5Bobject%20Object%5D&name=OHeE6wZ.png&originHeight=266&originWidth=1153&size=17308&status=done&style=none&width=1153" alt="OHeE6wZ.png"><br>这里的举一个最简单的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p;</span><br><span class="line">	p = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 gdb 中进行调试，在 call malloc 处下一个断点，在这里使用 vmmap 命令，查看内存分布。可以看到此时并没有发现堆段<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599121162332-50f043b9-174b-42c5-9a77-98b5292a4780.png#align=left&display=inline&height=464&margin=%5Bobject%20Object%5D&name=AmbgBDz.png&originHeight=464&originWidth=722&size=99737&status=done&style=none&width=722" alt="AmbgBDz.png"><br>单步 n ，vmmap 命令再次查看内存，发现出现了堆段<a target="_blank" rel="noopener" href="https://i.imgur.com/4J2yIhn.png">
</a><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599121189896-ab0f0193-a224-45cf-92e0-fb0b26e5a31d.png#align=left&display=inline&height=358&margin=%5Bobject%20Object%5D&name=4J2yIhn.png&originHeight=358&originWidth=791&size=88517&status=done&style=none&width=791" alt="4J2yIhn.png">但是这里我们明明只是申请了 10 字节的大小，但是为什么这里的为什么给了这么大的堆段呢？<br>0x00602000     ~    0x00623000<br>计算一下，刚好是 132 kB<br>(0x00623000-0x00602000)/1024 = 132 kB<br>一个地址可以容纳 1byte 的内容</p>
<blockquote>
<p><strong>这 132KB 的堆空间叫做 arena，此时因为是主线程分配的，所以这个区域叫做 main arena</strong></p>
</blockquote>
<p>也就是说这 132 KB 是”厂家”（内核）批发给”中间商”（ptmalloc2）的货物，<strong>以便下次程序在向系统申请小内存的时候，直接去”中间商”去取就行了</strong>，他就会在这 132KB 中按照要申请”货物”的多少进行分配下去。若”中间商”缺货了话，ptmalloc2 就继续去找”厂家”（系统内核）去取货</p>
<h2 id="查看已分配的堆内存分布"><a href="#查看已分配的堆内存分布" class="headerlink" title="查看已分配的堆内存分布"></a>查看已分配的堆内存分布</h2><p>在上面我们动态调试的时候已经执行了 malloc 函数，申请到的堆指针是保存在 eax 中的<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599121435584-9b4100f1-c085-4960-89c4-23d11aa92cdc.png#align=left&display=inline&height=499&margin=%5Bobject%20Object%5D&name=YTz6loS.png&originHeight=499&originWidth=822&size=108610&status=done&style=none&width=822" alt="YTz6loS.png"><br>我们这里使用下面这个命令来查看内存堆块情况：</p>
<blockquote>
<p>x/32gx 0x602010-0x10 //32 位的程序使用 x/32xw 比较直观一点</p>
</blockquote>
<p>这里减去 0x10 表示从堆块的头部开始观察（包含 pre size 和 size 字段）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599121498212-84c953ef-34b7-40db-a7c1-2c4b6b1788d3.png#align=left&display=inline&height=499&margin=%5Bobject%20Object%5D&name=YTz6loS.png&originHeight=499&originWidth=822&size=108610&status=done&style=none&width=822" alt="YTz6loS.png"></p>
<h1 id="main-arena-与-top-chunk"><a href="#main-arena-与-top-chunk" class="headerlink" title="main_arena 与 top chunk"></a>main_arena 与 top chunk</h1><h2 id="main-arena"><a href="#main-arena" class="headerlink" title="main_arena"></a>main_arena</h2><p>这个 main_arena 其实就是 ptmalloc2 堆管理器通过与操作系统内核进行交互申请到的，也就是相当于上面所说的”批发”到的一堆货物</p>
<blockquote>
<p>因为是主线程分配的，所以叫做 main arena，通过增加 program break location 的方式来增加 main arena 的大小。</p>
</blockquote>
<p>使用 brk 方式扩展内存的方式这里就不说了，感兴趣可以自己去查一下资料:<br>参考 ctf-wiki：<a target="_blank" rel="noopener" href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_overview-zh/">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_overview-zh/</a><br><strong>在 gdb 调试中，使用”x/32gx &amp;main_arena”，可以看到 main_arena 的内存分配情况。</strong></p>
<h2 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h2><p>顾名思义，是<strong>堆中第一个堆块。相当于一个”带头大哥”，程序以后分配到的内存到要放在他的后面。</strong><br>在系统当前的所有 free chunk(无论那种 bin)，都无法满足用户请求的内存大小的时候，将此 chunk 当做一个应急消防员，分配给用户使用。<br><strong>简单点说，也就是在程序在向堆管理器申请内存时，没有合适的内存空间可以分配给他，此时就会从 top chunk 上”剪切”一部分作为 chunk 分配给他</strong></p>
<h1 id="free-函数和-bins"><a href="#free-函数和-bins" class="headerlink" title="free 函数和 bins"></a>free 函数和 bins</h1><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><h3 id="free-函数"><a href="#free-函数" class="headerlink" title="free 函数"></a>free 函数</h3><p>free 函数的使用是和 bins 的分配息息相关的。用一个简单的例子来理解一下 free 函数的实现原理。<br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> *p;</span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(p,<span class="string">&quot;Hello&quot;</span>,<span class="number">5</span>); <span class="comment">//memcpy=memory copy 内存拷贝函数</span></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序将 “Hello” 字符串复制到申请到的堆内存空间中。</span></span><br></pre></td></tr></table></figure>

<p>编译后用 gdb 调试，在 call memcpy 处下一个断点，单步后将 “Hello” 复制到堆块中<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599122034078-6b2816c6-5cc0-440e-b162-0b63a6df8b4c.png#align=left&display=inline&height=499&margin=%5Bobject%20Object%5D&name=YTz6loS.png&originHeight=499&originWidth=822&size=108610&status=done&style=none&width=822" alt="YTz6loS.png"><br>继续使用 x/32gx 0x602010-0x10 命令查看堆块情况<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599122203779-6b715d75-353e-48c7-9542-c6d756ed5af6.png#align=left&display=inline&height=309&margin=%5Bobject%20Object%5D&name=SkUxKXN.png&originHeight=309&originWidth=704&size=38376&status=done&style=none&width=704" alt="SkUxKXN.png"><br>继续单步 n，执行 free 函数之后，查看堆块情况<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599122244843-86e27494-0d75-427d-a3cc-aaf9782ef8d4.png#align=left&display=inline&height=349&margin=%5Bobject%20Object%5D&name=iifOKJV.png&originHeight=349&originWidth=807&size=53377&status=done&style=none&width=807" alt="iifOKJV.png"><br>这里可以看出原本堆块中存储的内容已经被清空，然后查看一下 main_arena 的值，发现其中 +0x8 的偏移处，存储了指向已经 free 了的指针（指向头部，而不是 user data）</p>
<h3 id="free-总结"><a href="#free-总结" class="headerlink" title="free 总结"></a>free 总结</h3><p>所以调用 free 函数以后程序做了两件事：<br><strong>1.清空此堆块的 user data 2.将此堆块的指针存储到 main_arena 中了（或是 fast bin 中）</strong></p>
<h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><p>bins 这个概念是与<strong>内存回收</strong>相关的，也就是堆管理器会根据用户已经申请到的内存空间大小进行释放，<strong>来决定放入哪类 bins 当作去</strong>。bins 直接翻译过来就是”垃圾桶”的意思，所以在系统在决定使用哪个 bins 时可以看作为”垃圾的分类”。<br><strong>描述</strong>：</p>
<ol>
<li>用户 free 掉的内存并不是都会马上归还给系统，ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的 chunk</li>
<li>当用户进行下一次分配请求时，ptmalloc 会首先试图在空闲的 chunk 中挑选一块给用户，这样就避免了频繁的系统调用，降低了内存分配的开销</li>
<li><strong>ptmalloc 将相似大小的 chunk 用双向链表链接起来，这样的一个链表被称为一个 bin</strong></li>
<li>ptmalloc 一共维护了 128 个 bin，并使用一个数组来存储这些 bin</li>
<li>堆管理器根据特点，将堆分为四种：<strong>fastbin</strong> | <strong>unsortedbin</strong> | <strong>smallbin</strong> | <strong>largebin</strong></li>
<li>数组中<strong>bin 1 为 unsorted bin</strong>；<strong>bin 2 到 63 为 small bin</strong>；<strong>bin 64 到 126 为 large bin</strong></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599301876778-63cc145a-dc32-4ed2-b7c0-0a7bc3e8e068.png#align=left&display=inline&height=291&margin=%5Bobject%20Object%5D&originHeight=373&originWidth=743&size=0&status=done&style=none&width=580"></p>
<h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p>顾名思义，就是为了<strong>快速重新分配回内存而存在的一个结构，</strong> fast bin 是使用到的最多的一类，也是其中结构最为简单的。</p>
<blockquote>
<p>fastbin 所包含 chunk 的大小为 16 Bytes, 24 Bytes, 32 Bytes, … , 80 Bytes。当分配一块较小的内存(mem&lt;=64 Bytes)时，<strong>会首先检查对应大小的 fastbin 中是否包含未被使用的 chunk，如果存在则直接将其从 fastbin 中移除并返回；否则通过其他方式（剪切 top chunk）得到一块符合大小要求的 chunk 并返回。</strong></p>
</blockquote>
<p><strong>描述</strong>：</p>
<ol>
<li>在 32 位操作系统中，当用户释放的堆块大小<strong>小于 64B</strong>时使用 fastbin 进行管理，即 chunk 空间最大为 80 字节</li>
<li>fastbin 只使用了<strong>fd</strong>成员，是个单链表结构</li>
<li>fastbin 不会对<strong>P 位</strong>进行操作，也就是说它不会主动进行合并；只有在某些特定情况下，堆管理器才会对 fastbin 进行合并</li>
<li>fastbinY 为管理 fastbin 的数组，每个成员分别管理不同大小的 fastbin 链表，且均指向了当前链表的尾节点，当尾节点被分配时，通过其 fd 指针指向前一个结点</li>
<li>当用户申请 chunk 大小小于或等于<strong>MAX_FAST_SIZE</strong>时，优先从 fastbins 中查找相应的空闲块，且规则为<strong>LIFO（Last in, first out, 后进先出）</strong></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599302477361-f300cd59-989a-4004-8532-c0fc27492f23.png#align=left&display=inline&height=265&margin=%5Bobject%20Object%5D&originHeight=265&originWidth=587&size=0&status=done&style=none&width=587"><br>引用一张图：</p>
<ul>
<li>这里的横向排列的就是 main_arene（fast bin）的内存地址</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599122660636-572d48c5-7dc2-4487-a9b2-0086213e77c1.png#align=left&display=inline&height=926&margin=%5Bobject%20Object%5D&name=r5Vjflz.png&originHeight=926&originWidth=1494&size=252942&status=done&style=none&width=1494" alt="r5Vjflz.png"><br>假如此时 0x0804a000 处的堆块（实际堆块中的 size 字段要减去 PREV_INUSE 字段值 1）已经被 free 了，那么他就会被存储<strong>在表示 40 bytes 的 fast bin 的内存地址里</strong></p>
<ul>
<li>注意：<strong>这里把指针和地址区别开。地址存储的是指针，64 位的指针占 8 个字节</strong>。</li>
</ul>
<p><strong>假设我们现在还是以 64 位下的 malloc(10) 为例子。</strong><br>根据前面那个 free 函数的例子，查看 main_arena 地址中的指针值我们可以看出来，**+0x8 偏移处才是指向 malloc(10) 的堆块的指针**（因为前面有 pre size 和 size 字段，这个堆块分配后的 user data 实际大小是 16 字节）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/2gx &amp;main_arena                           (16 bytes 的链表头)</span><br><span class="line">0x7ffff7dd3760 &lt;main_arena&gt;:    0x0000000000000000    0x0000000000602000</span><br></pre></td></tr></table></figure>

<p>所以这个 16 字节的堆块的指针会被插入属于他的这个链表队列中，也就是如下的情况。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599123046100-1692cf5c-04a9-4603-a33e-bdea4531e4ff.png#align=left&display=inline&height=570&margin=%5Bobject%20Object%5D&name=yKHQ6fT.png&originHeight=570&originWidth=985&size=20383&status=done&style=none&width=985" alt="yKHQ6fT.png"><br><strong>所以这也就印证了在 main_arena 中分别表示 16 Bytes, 24 Bytes, 32 Bytes, … , 80 Bytes 的内存地址中分别存储着已经 free 的而且满足这个大小的 chunk 的指针。</strong></p>
<h3 id="fast-bin-的特性"><a href="#fast-bin-的特性" class="headerlink" title="fast bin 的特性"></a>fast bin 的特性</h3><p><strong>1.使用单链表来维护释放的堆块</strong><br>也就是和上图一样，从 main_arena 到 free 第一个块的地方是采用单链表形式进行存储的，若还有 free 掉的堆块，则这个堆块的 fk 指针域就会指针前一个堆块。<br>如下图所示，此时就是一个单链表结构<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599123652606-4a1c4d4b-41db-44ed-873b-7ef7476db2ab.png#align=left&display=inline&height=757&margin=%5Bobject%20Object%5D&name=KYQmNPN.png&originHeight=757&originWidth=1002&size=56172&status=done&style=none&width=1002" alt="KYQmNPN.png"><br><strong>2.采用后进先出的方式维护链表（类似于栈的结构）</strong><br>当程序需要重新 malloc 内存并且需要从 fastbin 中挑选堆块时，<strong>会选择后面新加入的堆块拿来先进行内存分配</strong><br>如上图，如果程序重新请求和上面的堆块大小一样时候（malloc），堆管理器就会直接使用 fast bin 里的堆块。<br><strong>这里的话也就是直接使用第二次释放的这个堆块，然后将这个堆块从链表中移除，接着根据堆块的 fk 指针找到这个堆块</strong>，此时 main_arena 就指向了这里。也就是恢复到了上面第一个图中的情况。</p>
<h2 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h2><p>顾名思义，这个是一个 small chunk ，满足的内存空间比 fast bin 大一点。<br>如果程序请求的内存范围不在 fast bin 的范围内，就会考虑 small bin。简单点说就是大于 80 Bytes 小于某一个值时，就会选择他。<br><strong>描述</strong>：</p>
<ol>
<li>在 32 位操作系统中，当用户释放的堆块大小<strong>大于 64B，小于等于 512B</strong>时使用 small bin 进行管理</li>
<li>small bin 为双向循环链表，且使用 <strong>FIFO（First in, first out, 先入先出）</strong> 算法</li>
<li>当满足 small bin 条件的 chunk 被释放后，会优先被放入 unosrted bin，只有在一定情况下，才会被分配到 small bin 中</li>
<li>相邻的 free chunk 将会被合并成一个更大的 free chunk，增加内存利用率</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599302711432-03e90cb4-53d8-4a26-b8be-73412f5732f4.png#align=left&display=inline&height=252&margin=%5Bobject%20Object%5D&originHeight=252&originWidth=583&size=0&status=done&style=none&width=583"></p>
<h2 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h2><blockquote>
<p><strong>描述</strong>：</p>
<ol>
<li>当释放较小或较大的 chunk 的时候，为了增加分配效率，系统会先将最近释放的 chunk 添加到 unsorted bin 中</li>
<li>unsorted bin 为一个双向循环链表，对 chunk 的大小没有限制，即任何大小的 chunk 都可以放入 unsorted bin 链表中</li>
<li>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，堆管理器就会考虑使用 unsorted bin 。它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</li>
</ol>
</blockquote>
<ul>
<li>unsorted bin 与 fast bin 不同，他使用<strong>双向链表</strong>对 chunk 进行连接</li>
<li>unsorted 的字面意思就是”不可回收”的意思，可以看作将不可回收的垃圾（不满足能够进行内存分配的堆块）都放到这个”垃圾桶”中。</li>
</ul>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2020/09/02/PWN%E5%85%A5%E9%97%A8%EF%BC%883-1-1%EF%BC%89-%E5%A0%86%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/">http://example.com/2020/09/02/PWN%E5%85%A5%E9%97%A8%EF%BC%883-1-1%EF%BC%89-%E5%A0%86%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/03/PWN%E5%85%A5%E9%97%A8%EF%BC%883-1-2%EF%BC%89-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A0%86%EF%BC%881%EF%BC%89/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">PWN入门（3-1-2）-深入理解堆（1）</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/02/IDA%20Pro7.0%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">IDA Pro7.0使用技巧总结</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">317</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是堆？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">堆的基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">堆的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-chunk-%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.1.</span> <span class="toc-text">malloc_chunk 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-pre-size-%E5%AD%97%E6%AE%B5"><span class="toc-number">2.2.2.</span> <span class="toc-text">1.pre size 字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-size-%E5%AD%97%E6%AE%B5"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.size 字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-user-data"><span class="toc-number">2.2.4.</span> <span class="toc-text">3.user data</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">2.3.</span> <span class="toc-text">结构图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%AD%EF%BC%88%E5%88%86%E9%85%8D%E5%90%8E%EF%BC%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">使用中（分配后）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E4%B8%AD%EF%BC%88%E4%BD%BF%E7%94%A8%E5%90%8E%EF%BC%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">空闲中（使用后）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%9D%97%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.4.</span> <span class="toc-text">堆块大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E7%94%A8"><span class="toc-number">2.5.</span> <span class="toc-text">空间复用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%9C%B0%E5%9D%80"><span class="toc-number">3.</span> <span class="toc-text">指针与地址</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IDA-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8C%87%E9%92%88%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">IDA 中常见的指针表示形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E5%A0%86%E5%9D%97%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">4.</span> <span class="toc-text">申请堆块的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%B7%B2%E5%88%86%E9%85%8D%E7%9A%84%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="toc-number">4.1.</span> <span class="toc-text">查看已分配的堆内存分布</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#main-arena-%E4%B8%8E-top-chunk"><span class="toc-number">5.</span> <span class="toc-text">main_arena 与 top chunk</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#main-arena"><span class="toc-number">5.1.</span> <span class="toc-text">main_arena</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#top-chunk"><span class="toc-number">5.2.</span> <span class="toc-text">top chunk</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#free-%E5%87%BD%E6%95%B0%E5%92%8C-bins"><span class="toc-number">6.</span> <span class="toc-text">free 函数和 bins</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#free"><span class="toc-number">6.1.</span> <span class="toc-text">free</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#free-%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.1.</span> <span class="toc-text">free 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free-%E6%80%BB%E7%BB%93"><span class="toc-number">6.1.2.</span> <span class="toc-text">free 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bin"><span class="toc-number">6.2.</span> <span class="toc-text">bin</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fast-bin"><span class="toc-number">6.2.1.</span> <span class="toc-text">fast bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fast-bin-%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">6.2.2.</span> <span class="toc-text">fast bin 的特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#small-bin"><span class="toc-number">6.3.</span> <span class="toc-text">small bin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unsorted-bin"><span class="toc-number">6.4.</span> <span class="toc-text">unsorted bin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-1"><span class="toc-number">6.5.</span> <span class="toc-text"></span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/06/10/%E5%88%A9%E7%94%A8mprotect%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E6%AE%B5%E6%9D%83%E9%99%90%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C/" title="利用mprotect修改程序段权限为可执行"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="利用mprotect修改程序段权限为可执行"/></a><div class="content"><a class="title" href="/2021/06/10/%E5%88%A9%E7%94%A8mprotect%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E6%AE%B5%E6%9D%83%E9%99%90%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C/" title="利用mprotect修改程序段权限为可执行">利用mprotect修改程序段权限为可执行</a><time datetime="2021-06-10T07:59:46.000Z" title="Created 2021-06-10 15:59:46">2021-06-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/31/SROP%EF%BC%881%EF%BC%89--%E4%BB%8E%E4%B8%A4%E9%81%93%E9%A2%98%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86SROP%20attack/" title="SROP（1）--从两道题重新认识SROP attack"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SROP（1）--从两道题重新认识SROP attack"/></a><div class="content"><a class="title" href="/2021/05/31/SROP%EF%BC%881%EF%BC%89--%E4%BB%8E%E4%B8%A4%E9%81%93%E9%A2%98%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86SROP%20attack/" title="SROP（1）--从两道题重新认识SROP attack">SROP（1）--从两道题重新认识SROP attack</a><time datetime="2021-05-31T02:14:53.000Z" title="Created 2021-05-31 10:14:53">2021-05-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/18/how2heap(14)-unsortedbin%20attack/" title="how2heap(14)-unsortedbin attack"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="how2heap(14)-unsortedbin attack"/></a><div class="content"><a class="title" href="/2021/05/18/how2heap(14)-unsortedbin%20attack/" title="how2heap(14)-unsortedbin attack">how2heap(14)-unsortedbin attack</a><time datetime="2021-05-18T07:48:53.000Z" title="Created 2021-05-18 15:48:53">2021-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/17/how2heap(13)-tcache_stashing_unlink_attack/" title="how2heap(13)-tcache_stashing_unlink_attack"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="how2heap(13)-tcache_stashing_unlink_attack"/></a><div class="content"><a class="title" href="/2021/05/17/how2heap(13)-tcache_stashing_unlink_attack/" title="how2heap(13)-tcache_stashing_unlink_attack">how2heap(13)-tcache_stashing_unlink_attack</a><time datetime="2021-05-17T02:16:40.000Z" title="Created 2021-05-17 10:16:40">2021-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/14/how2heap(12)-house%20of%20lore/" title="how2heap(12)-house of lore"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="how2heap(12)-house of lore"/></a><div class="content"><a class="title" href="/2021/05/14/how2heap(12)-house%20of%20lore/" title="how2heap(12)-house of lore">how2heap(12)-house of lore</a><time datetime="2021-05-14T08:02:54.000Z" title="Created 2021-05-14 16:02:54">2021-05-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>