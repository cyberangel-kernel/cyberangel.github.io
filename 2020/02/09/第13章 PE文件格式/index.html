<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>第13章 PE文件格式 | Cyberangel-blog</title><meta name="author" content="Cyberangel"><meta name="copyright" content="Cyberangel"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本章将详细讲解 Windows 操作系统的 PE（Portable Executable)文件格式相关知识。学习 PE 文件格式的过程中，也一起整理一下有关进程、内存、DLL 等的内容，它们是 Windows 操作系统最核心的部分。 13.1 介绍PE 文件是 Windows 操作系统下使用的可执行文件格式。它是微软在 UNIX 平台的 COFF（Common Object File Format">
<meta property="og:type" content="article">
<meta property="og:title" content="第13章 PE文件格式">
<meta property="og:url" content="https://cyberangel.cn/2020/02/09/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/index.html">
<meta property="og:site_name" content="Cyberangel-blog">
<meta property="og:description" content="本章将详细讲解 Windows 操作系统的 PE（Portable Executable)文件格式相关知识。学习 PE 文件格式的过程中，也一起整理一下有关进程、内存、DLL 等的内容，它们是 Windows 操作系统最核心的部分。 13.1 介绍PE 文件是 Windows 操作系统下使用的可执行文件格式。它是微软在 UNIX 平台的 COFF（Common Object File Format">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-02-09T02:03:03.000Z">
<meta property="article:modified_time" content="2021-07-04T09:57:23.068Z">
<meta property="article:author" content="Cyberangel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cyberangel.cn/2020/02/09/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第13章 PE文件格式',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-04 17:57:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Cyberangel-blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">317</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Cyberangel-blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第13章 PE文件格式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-02-09T02:03:03.000Z" title="发表于 2020-02-09 10:03:03">2020-02-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-04T09:57:23.068Z" title="更新于 2021-07-04 17:57:23">2021-07-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第13章 PE文件格式"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><span class="disqus-comment-count"><a href="https://cyberangel.cn/2020/02/09/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/#disqus_thread"></a></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本章将详细讲解 Windows 操作系统的 PE（Portable Executable)文件格式相关知识。学习 PE 文件格式的过程中，也一起整理一下有关进程、内存、DLL 等的内容，它们是 Windows 操作系统最核心的部分。</p>
<h1 id="13-1-介绍"><a href="#13-1-介绍" class="headerlink" title="13.1 介绍"></a>13.1 介绍</h1><p>PE 文件是 Windows 操作系统下使用的可执行文件格式。它是微软在 UNIX 平台的 COFF（Common Object File Format,通用对象文件格式）基础上制作而成的。最初（正如 Portable 这个单词所代表的那样）设计用来提高程序在不同操作系统上的移植性，但实际上这种文件格式仅用在 Windows 系列的操作系统下。<br><strong>PE 文件是指 32 位的可执行文件，也称为 PE32。64 位的可执行文件称为 PE+或 PE32+，是 PE（PE32)文件的一种扩展形式（请注意不是 PE64）。</strong></p>
<h1 id="13-2PE-文件格式"><a href="#13-2PE-文件格式" class="headerlink" title="13.2PE 文件格式"></a>13.2PE 文件格式</h1><p>PE 文件种类如表 13-1 所示。<br>表 13-1 PE 文件种类</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>主扩展名</th>
<th>种类</th>
<th>主扩展名</th>
</tr>
</thead>
<tbody><tr>
<td>可执行系列</td>
<td>EXE、SCR</td>
<td>驱动程序系列</td>
<td>SYS、VXD、</td>
</tr>
<tr>
<td>库系列</td>
<td>DLL、OCX、CPL、DRV</td>
<td>对象文件系列</td>
<td>OBJ</td>
</tr>
</tbody></table>
<p><strong>严格地说，OBJ（对象）文件之外的所有文件都是可执行的。</strong>DLL、SYS 文件等虽然不能直接在 Shell（Explorer.exe)中运行，但可以使用其他方法（调试器、服务等）执行。<br>根据——————————————————————————————————————<br><strong>PE 正式规范，编译结果 OBJ 文件也视为 PE 文件。但是 OBJ 文件本身不能以任何形式执行，在代码逆向分析中几乎不需要关注它。</strong></p>
<hr>
<p>下面以记事本（notepad.exe）程序进行简单说明，首先使用 Hex Editor 打开记事本程序。<br>图 13-1 是 notepad.exe 文件的起始部分，也是 PE 文件的头部分（PE header）。notepad.exe 文件运行需要的所有信息就存储在这个 PE 头中。如何加载到内存、从何处开始运行、运行中需要的 DLL 有哪些、需要多大的栈/堆内存等，大量信息以结构体形式存储在 PE 头中。换言之，学习 PE 文件格式就是学习 PE 头中的结构体。<br>提示——————————————————————————————————————<br>书中将以 WindowsXP SP3 的 notepad.exe 为例进行说明，与其他版本 Windows 下的 notepad.exe 文件结构类似，但是地址不同。</p>
<hr>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581214821594-111da9bd-0f09-4229-95b8-4f7a0bca868f.png#align=left&display=inline&height=515&name=QQ%E6%88%AA%E5%9B%BE20200209101832.png&originHeight=795&originWidth=806&size=363414&status=done&style=none&width=522" alt="QQ截图20200209101832.png"><br>图 13-1 notepad.exe 文件</p>
<h2 id="13-2-1-基本结构"><a href="#13-2-1-基本结构" class="headerlink" title="13.2.1 基本结构"></a>13.2.1 基本结构</h2><p>notepad.exe 具有普通 PE 文件的基本结构。图 13-2 描述了 notepad.exe 文件加载到内存时的情形。其中包含了许多内容，下面逐一学习。<br><strong>从 DOS 头（DOS header)到节区头（Section header)是**<strong>PE 头*</strong>*部分</strong>，<strong>其下的节区合称**<strong>PE 体</strong>。</strong>文件中使用偏移（offset），内存中使用 VA（Virtual Address，虚拟地址）来表示位置。文件加载到内存时，情况就会发生变化（节区的大小、位置等）。文件的内容一般可分为代码（.text)、数据（.data）、资源（.rsrc)节，分别保存。**<br>提示—————————————————————————————————————–<br>根据所用的不同开发工具（VB/VC++/Delphi/etc)与编译选项，节区的名称、大小、个数、存储的内容等都是不同的。最重要的是它们按照不同的用途分类保存到不同的节中。</p>
<hr>
<p><strong>各**<strong>节区头*</strong>*定义了各节区在文件或内存中的大小、位置、属性等。</strong><br>PE 头与各节区的尾部存在一个区域，称为<strong>NULL 填充（NULLpadding)<strong>。计算机中，为了提高处理文件、内存、网络包的效率，使用“</strong>最小基本单位</strong>”这一概念，PE 文件中也类似。文件/内存中节区的起始位置应该在各文件/内存最小单位的倍数位置上，空白区域将用 NULL 填充（看图 13-2，可以看到各节区起始地址的截断都遵循一定规则）。<img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581215850519-bd20fe58-6c8c-42f1-8265-27174591bdcd.png#align=left&display=inline&height=666&name=QQ%E6%88%AA%E5%9B%BE20200209103719.png&originHeight=666&originWidth=537&size=246630&status=done&style=none&width=537" alt="QQ截图20200209103719.png"></p>
<h2 id="13-2-2-VA-amp-RVA"><a href="#13-2-2-VA-amp-RVA" class="headerlink" title="13.2.2 VA&amp;RVA"></a>13.2.2 VA&amp;RVA</h2><p>VA 指的是<strong>进程虚拟内存的绝对地址</strong>，RVA（Relative Virtual Address，<strong>相对虚拟地址</strong>）指从某个<strong>基准位置</strong>（ImageBase）开始的<strong>相对地址</strong>。VA 与 RVA 满足下面的换算关系。<br>RVA+ImageBase=VA<br>PE 头内部信息大多以 RVA 形式存在。原因在于，PE 文件（主要是 DLL）加载到进程虚拟内存的特定位置时，该位置可能已经加载了其他 PE 文件（DLL）。此时必须通过<strong>重定位</strong>（Relocation）将其加载到其他空白的位置，若 PE 头信息使用的是 VA，则无法正常访问。因此使用 RVA 来定位信息，即使发生了重定位，只要相对于基准位置的相对地址没有变化，就能正常访问到指定信息，不会出现任何问题。<br>提示—————————————————————————————————————–<br>32 位 WindowsOS 中，<strong>各进程</strong>分配有 4GB 的虚拟内存，因此进程中 VA 值的范围是 00000000~FFFFFFFF。</p>
<hr>
<h1 id="13-3PE-头"><a href="#13-3PE-头" class="headerlink" title="13.3PE 头"></a>13.3PE 头</h1><p><strong>前面提到过：从 DOS 头（DOS header)到节区头（Section header)是**<strong>PE 头*</strong>*部分</strong><br>PE 头由许多<strong>结构体</strong>组成，现在开始逐一学习各结构体。此外还会详细讲解在代码逆向分析中起着重要作用的结构体成员。</p>
<h2 id="13-3-1-DOS-头"><a href="#13-3-1-DOS-头" class="headerlink" title="13.3.1 DOS 头"></a>13.3.1 DOS 头</h2><p>微软创建 PE 文件格式时，人们正广泛使用 DOS 文件，所以微软充分考虑了 PE 文件对 DOS 文件的兼容性。其结果是在**PE 头的最前面添加了一个 IMAGE_DOS_HEADER****结构体*<em>，用来扩展已有的 DOS EXE 头。<br>代码 13-1 IMAGE_DOS_HEADER 结构体<br>typedef struct _IMAGE_DOS_HEADER {<br>+0h WORD e_magic    // Magic DOS signature MZ(4Dh 5Ah)     DOS 签名<br>+2h WORD e_cblp    // Bytes on last page of file<br>+4h WORD e_cp    // Pages in file<br>+6h WORD e_crlc    // Relocations<br>+8h WORD e_cparhdr   // Size of header in paragraphs<br>+0ah WORD e_minalloc   // Minimun extra paragraphs needs<br>+0ch WORD e_maxalloc  // Maximun extra paragraphs needs<br>+0eh WORD e_ss            // intial(relative)SS value        DOS 代码的初始化堆栈 SS<br>+10h WORD e_sp     // intial SP value                       DOS 代码的初始化堆栈指针 SP<br>+12h WORD e_csum     // Checksum<br>+14h WORD e_ip     // intial IP value               DOS 代码的初始化指令入口[指针 IP]<br>+16h WORD e_cs     // intial(relative)CS value         DOS 代码的初始堆栈入口<br>+18h WORD e_lfarlc     // File Address of relocation table<br>+1ah WORD e_ovno         // Overlay number<br>+1ch WORD e_res[4]      // Reserved words<br>+24h WORD e_oemid      // OEM identifier(for e_oeminfo)<br>+26h WORD      e_oeminfo   // OEM information;e_oemid specific<br>+29h WORD e_res2[10]   // Reserved words<br>+3ch DWORD   e_lfanew    <br>} IMAGE_DOS_HEADER，</em>PIMAGE_DOS_HEADER</p>
<p>IMAGEDOS HEADER 结构体的大小为 40 个字节。在该结构体中必须知道 2 个重要成员：e_magic 与 e_lfanew。<br><strong>e_magic</strong>：一个 WORD 类型，值是一个常数 0x4D5A，用文本编辑器查看该值位‘MZ’，可执行文件必须都是’MZ’开头。<br><strong>e_lfanew</strong>：为 32 位可执行文件扩展的域，用来表示 DOS 头之后的 NT 头相对文件起始地址的偏移（换一种说法就是指示 NT 头的偏移，根据不同文件拥有可变值）<br>所有 PE 文件在开始部分（e_magic）都有 DOS 签名（“MZ”）。e_lfanew 值指向 NT 头所在位置（NT 头的名称为 IMAGE_NT_HEADERS，后面将会介绍）。<br>提示——————————————————————————————————————<br>一个名叫 Mark Zbikowski 的开发人员在微软设计了 DOS 可执行文件，MZ 即取自其名字的首字母。<br>出处：<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/MarkZbikowski">http://en.wikipedia.org/wiki/MarkZbikowski</a><br>———————————————————————————————————————–使用 Hex Editor 打开 notepad.exe，查看 IMAGE_DOS_HEADERS 结构体，如图 13-3 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581217198222-31c74ae8-752e-43dc-b3dc-9db3d5481694.png#align=left&display=inline&height=111&name=QQ%E6%88%AA%E5%9B%BE20200209105949.png&originHeight=111&originWidth=760&size=46659&status=done&style=none&width=760" alt="QQ截图20200209105949.png">图 13-3 IMAGE DOS HEADERS<br>根据 PE 规范，文件开始的 2 个字节为 4D5A，e_lfanew 值为 000000E0（不是 E0000000）。<br>提示—————————————————————————————————————— <br>Intel 系列的 CPU 以逆序存储数据，这称为小端序标识法。</p>
<hr>
<p>请尝试修改这些值，保存后运行。可以发现程序无法正常运行（因为根据 PE 规范，它已不再是 PE 文件了）。</p>
<h2 id="13-3-2-DOS-存根"><a href="#13-3-2-DOS-存根" class="headerlink" title="13.3.2 DOS 存根"></a>13.3.2 DOS 存根</h2><p><strong>DOS 存根（stub)<strong>在 DOS 头下方，是个</strong>可选项</strong>，且大小不固定（即使没有 DOS 存根，文件也能正常运行）。DOS 存根由代码与数据混合而成，图 13-4 显示的就是 notepad.exe 的 DOS 存根。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581217430805-346f0858-b14e-4a89-8400-ea8ebfa51966.png#align=left&display=inline&height=198&name=QQ%E6%88%AA%E5%9B%BE20200209110343.png&originHeight=198&originWidth=765&size=133847&status=done&style=none&width=765" alt="QQ截图20200209110343.png"><br>图 13-4 DOS 存根<br>图 13-4 中，文件偏移 40~4D 区域为 16 位的汇编指令。32 位的 WindowsOS 中不会运行该命令（<strong>由于被识别为 PE 文件，所以完全忽视该代码</strong>）。在 DOS 环境中运行 Notepad.exe 文件，或者使用 DOS 调试器（debug.exe)运行它，可使其执行该代码（不认识 PE 文件格式，所以被识别为 DOS EXE 文件）。<br>打开命令行窗口（cmd.exe)，输入如下命令（仅适用于 Windows XP 环境）。<br>debug C:\Windows\notepad.exe<br>在出现的光标位置上输入“u”指令（Unassemble，反汇编指令)，将会出现 16 位的汇编指令，如下所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581217709142-c41e38a4-cdc4-4824-8079-cf55028cfe4f.png#align=left&display=inline&height=338&name=QQ%E6%88%AA%E5%9B%BE20200209110820.png&originHeight=338&originWidth=652&size=10894&status=done&style=none&width=652" alt="QQ截图20200209110820.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581217745488-abeb9234-d810-44ba-b447-32e7bd0b21be.png#align=left&display=inline&height=196&name=QQ%E6%88%AA%E5%9B%BE20200209110856.png&originHeight=196&originWidth=909&size=141059&status=done&style=none&width=909" alt="QQ截图20200209110856.png"><br>代码非常简单，在画面中输出字符串“This program cannot be run in DOS mode”后就退出。<br>换言之，notepad.exe 文件虽然是 32 位的 PE 文件，但是带有 MS-DOS 兼容模式，可以在 DOS 环境中运行，执行 DOS EXE 代码，输出“This program cannot be run in DOS mode”后终止。灵活使用该特性可以在一个可执行文件（EXE）中创建出另一个文件，它在 DOS 与 Windows 中都能运行（在 DOS 环境中运行 16 位 DOS 代码，在 Windows 环境中运行 32 位 Windows 代码）。<br>    如前所述，DOS 存根是可选项，开发工具应该支持它（VB、VC++、Delphi 等默认支持 DOS 存根）。</p>
<h2 id="13-3-3-NT-头"><a href="#13-3-3-NT-头" class="headerlink" title="13.3.3 NT 头"></a>13.3.3 NT 头</h2><p>下面介绍 NT 头 IMAGE_NT_HEADERS。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581217883726-23124ea0-b627-4d8d-babf-30bb13a0cf9f.png#align=left&display=inline&height=135&name=QQ%E6%88%AA%E5%9B%BE20200209111112.png&originHeight=135&originWidth=911&size=116854&status=done&style=none&width=911" alt="QQ截图20200209111112.png"><br>IMAGE_NT_HEADERS<strong>结构体</strong>由 3 个成员组成，第一个成员为<strong>签名</strong>（Signature)<strong>结构体</strong>，其值为 50450000h（“PE”00）。另外两个成员分别为<strong>文件头</strong>（File Header）与<strong>可选头</strong>（Optional Header)<strong>结构体（你没有看错，结构体中嵌套了 3 个结构体）</strong>。使用 Hex Editor 打开 notepad.exe，查看其 IMAGE_NT_HEADERS，如图 13-5 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581218105875-18d72ae0-0971-4f9f-84e5-3c62b4ea4bd8.png#align=left&display=inline&height=321&name=QQ%E6%88%AA%E5%9B%BE20200209111333.png&originHeight=321&originWidth=764&size=136856&status=done&style=none&width=764" alt="QQ截图20200209111333.png"><br>IMAGE_NT_HEADERS 结构体的大小为 F8，相当大。下面分别讲解文件头与可选头结构体。</p>
<h2 id="13-3-4-NT-头：文件头"><a href="#13-3-4-NT-头：文件头" class="headerlink" title="13.3.4 NT 头：文件头"></a>13.3.4 NT 头：文件头</h2><p>文件头是表现文件大致属性的 IMAGE_FILE_HEADER 结构体。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581218214789-74b36604-148a-4a8c-a3bd-4ea3cfc019e2.png#align=left&display=inline&height=220&name=QQ%E6%88%AA%E5%9B%BE20200209111642.png&originHeight=220&originWidth=905&size=179837&status=done&style=none&width=905" alt="QQ截图20200209111642.png"><br>IMAGE_FILE_HEADERS 结构体中有如下 4 种重要成员（若它们设置不正确，将导致文件无法正常运行）。<br><strong>#1.Machine</strong><br>每个 CPU 都拥有唯一的 Machine 码，兼容 32 位 Intelx86 芯片的 Machine 码为 14C。以下是定义在 winnt.h 文件中的 Machine 码。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581218348968-463ff917-f6de-4072-b0d2-da90869e92df.png#align=left&display=inline&height=153&name=QQ%E6%88%AA%E5%9B%BE20200209111818.png&originHeight=153&originWidth=908&size=142487&status=done&style=none&width=908" alt="QQ截图20200209111818.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581218349924-23ec3860-e3c1-42a4-9480-8e16fbaf260b.png#align=left&display=inline&height=302&name=QQ%E6%88%AA%E5%9B%BE20200209111830.png&originHeight=302&originWidth=910&size=225147&status=done&style=none&width=910" alt="QQ截图20200209111830.png"><br><strong>#2.NumberOfSections</strong><br>前面提到过，PE 文件把代码、数据、资源等依据属性分类到各节区中存储。<br>NumberOfSections 用来指出文件中存在的节区数量。该值一定要大于 0，且当定义的节区数量与实际节区不同时，将发生运行错误。<br><strong>#3.SizeOfOptionalHeader</strong><br>IMAGE_NT_HEADER 结构体的最后一个成员为 IMAGE_OPTIONAL_HEADER32<strong>结构体</strong>。SizeOfOptionalHeader 成员用来指出 IMAGE_OPTIONAL_HEADER32 结构体的长度。<strong>IMAGE_OPTIONAL_HEADER32 结构体由 C 语言编写而成，故其大小已经确定。</strong>但是 Windows 的 PE 装载器需要查看 IMAGE_FILE_HEADER 的 SizeOfOptionalHeader 值，从而识别出 IMAGE_OPTIONAL_HEADER32 结构体的大小。<br>（IMAGE_NT_HEADERS:NT 头）-&gt;（IMAGE_FILE_HEADER:NT 头:文件头）-&gt;<strong>SizeOfOptionalHeader</strong>（指出 NT 头:可选头的长度<strong>）</strong><br>**          -&gt;(**IMAGE_OPTIONAL_HEADER32:NT 头：可选头）<br>PE32+格式的文件中使用的是 IMAGE_OPTIONAL_HEADER64 结构体，而不是 IMAGE_OPTIONAL_HEADER32 结构体。2 个结构体的尺寸是不同的，所以需要在 SizeOfOptionalHeader 成员中明确指出结构体的大小。<br>提示—————————————————————————————————————— <br>借助 IMAGE_DOS_HEADER 的 e_lfanew 成（为 32 位可执行文件扩展的域，用来表示 DOS 头之后的 NT 头相对文件起始地址的偏移）与 IMAGE_FILE_HEADER 的 SizeOfOptionalHeader 成员，可以创建出一种脱离常规的 PE 文件（PE Patch)（也有人称之为“麻花”PE 文件）。</p>
<hr>
<p><strong>#4.Characteristics</strong><br>该字段用于标识文件的属性，文件是否是可运行的形态、是否为 DLL 文件等信息，以 bit OR 形式组合起来。<br>以下是定义在 winnt.h 文件中的 Characteristics 值（<strong>请记住 0002h 与 2000h 这两个值</strong>）。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581219303780-e031e305-8559-4a56-8ea3-c4803833a147.png#align=left&display=inline&height=258&name=QQ%E6%88%AA%E5%9B%BE20200209113444.png&originHeight=258&originWidth=899&size=225988&status=done&style=none&width=899" alt="QQ截图20200209113444.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581219305027-b765770f-bff7-4bc3-b102-dfc92897094a.png#align=left&display=inline&height=246&name=QQ%E6%88%AA%E5%9B%BE20200209113452.png&originHeight=246&originWidth=907&size=171433&status=done&style=none&width=907" alt="QQ截图20200209113452.png"><br>另外，PE 文件中 Characteristics 的值有可能不是 0002h 吗（不可执行）?是的，确实存在这种情况。比如类似*.obj 的 object 文件及 resource DLL 文件等。<br>最后讲一下 IMAGE_FILE_HEADER 的<strong>TimeDateStamp</strong>成员。该成员的值不影响文件运行，用来记录编译器创建此文件的时间。但是有些开发工具（VB、VC++）提供了设置该值的工具，而有些开发工具（Delphi)则未提供（且随所用选项的不同而不同）。<br><strong>IMAGE_FILE_HEADER</strong><br>在 Hex Editor 中查看 notepad.exe 的 IMAGE_FILE_HEADER 结构体。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581219554326-f27e1944-f7ce-4a05-a1f5-3c44fb975a30.png#align=left&display=inline&height=42&name=QQ%E6%88%AA%E5%9B%BE20200209113856.png&originHeight=42&originWidth=785&size=19682&status=done&style=none&width=785" alt="QQ截图20200209113856.png"><br>为使大家理解图 13-6，以结构体成员的形式表示如下。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581219603401-1819622e-8955-4b01-96e4-41bbbefa7d61.png#align=left&display=inline&height=339&name=QQ%E6%88%AA%E5%9B%BE20200209113944.png&originHeight=339&originWidth=903&size=234405&status=done&style=none&width=903" alt="QQ截图20200209113944.png"></p>
<h2 id="13-3-5-NT-头：可选头"><a href="#13-3-5-NT-头：可选头" class="headerlink" title="13.3.5 NT 头：可选头"></a>13.3.5 NT 头：可选头</h2><p><strong>IMAGE_OPTIONAL_HEADER32（在前面你见过它）是 PE 头结构体中最大的。</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581219741369-4803c904-e6aa-4fe2-be56-e4ac18a70de4.png#align=left&display=inline&height=199&name=QQ%E6%88%AA%E5%9B%BE20200209114157.png&originHeight=199&originWidth=908&size=137960&status=done&style=none&width=908" alt="QQ截图20200209114157.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581219742257-23d5fd7b-cc0d-468e-bcef-bb0538c65cde.png#align=left&display=inline&height=682&name=QQ%E6%88%AA%E5%9B%BE20200209114209.png&originHeight=682&originWidth=900&size=634305&status=done&style=none&width=900" alt="QQ截图20200209114209.png"><br>在 IMAGE_OPTIONAL_HEADER32 结构体中需要关注下列成员。这些值是文件运行必需的，设置错误将导致文件无法正常运行。<br><strong>#1.Magic</strong><br>为 IMAGE_OPTIONAL_HEADER32 结构体时，Magic 码为 10B；为 IMAGE_OPTIONAL_HEADER64 结构体时，Magic 码为 20B。<br><strong>#2.AddressOfEntryPoint</strong><br>AddressOfEntryPoint 持有 EP 的 RVA（Relative Virtual Address，<strong>相对虚拟地址</strong>）值。该值指出程序最先执行的代码起始地址，相当重要。<br><strong>#3.ImageBase</strong><br>进程虚拟内存的范围是 0-FFFFFFFF（32 位系统）。PE 文件被加载到如此大的内存中时，ImageBase 指出文件的优先装入地址。<br>EXE、DLL 文件被装载到用户内存的 0<del>7FFFFFFF 中，SYS 文件被载入内核内存的 80000000</del>FFFFFFFF 中。一般而言，使用开发工具（VB/VC++/Delphi)创建好 EXE 文件后，其 ImageBase 的值为 00400000，DLL 文件的 ImageBase 值为 10000000（当然也可以指定为其他值）。<br><strong>执行 PE 文件时，PE 装载器先创建进程，再将文件载入内存，然后把 EIP 寄存器的值设置为 ImageBase+AddressOfEntryPoint。</strong><br><strong>#4.SectionAlignment,FileAlignment</strong><br>PE 文件的 Body 部分（<strong>PE 体</strong>）划分为若干节区，这些节存储着不同类别的数据。FileAlignment 指定了<strong>节区在磁盘</strong>文件中的<strong>最小单位</strong>，而 SectionAlignment 则指定了<strong>节区在内存</strong>中的<strong>最小单位</strong>（一个文件中，FileAlignment 与 SectionAlignment 的值可能相同，也可能不同）。磁盘文件或内存的节区大小必定为 FileAlignment 或 SectionAlignment 值的整数倍。<br><strong>#5.SizeOflmage</strong><br>加载 PE 文件到内存时，SizeOflmage 指定了 PEImage 在虚拟内存中所占空间的大小。一般而言，文件的大小与加载到内存中的大小是不同的（节区头中定义了各节装载的位置与占有内存的大小，后面会讲到）。<br><strong>#6.SizeOfHeader</strong><br>SizeOfHeader 用来指出整个 PE 头的大小。该值也必须是 FileAlignment 的整数倍。<strong>第一节区所在位置与 SizeOfHeader 距文件开始偏移的量相同。</strong><br><strong>#7.Subsystem</strong><br>该 Subsystem 值用来区分系统驱动文件（_.sys）与普通的可执行文件（_.exe，*.dll)。Subsystem 成员可拥有的值如表 13-2 所示。<br>表 13-2 Subsystem</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Driver 文件</td>
<td>系统驱动（如：ntfs.sys）</td>
</tr>
<tr>
<td>2</td>
<td>GUI 文件</td>
<td>窗口应用程序（如：notepad.exe）</td>
</tr>
<tr>
<td>3</td>
<td>CUI 文件</td>
<td>控制台应用程序（如：cmd.exe）</td>
</tr>
</tbody></table>
<p><strong>#8.NumberOfRvaAndSizes</strong><br>NumberOfRvaAndSizes 用来指定 DataDirectory（IMAGE_OPTIONAL_HEADER32 结构体的最后一个成员）数组的个数。虽然结构体定义中明确指出了数组个数为 IMAGE_NUMBEROF_DIRECTORY_ENTRIES(16)，但是 PE 装载器通过查看 NumberOfRvaAndSizes 值来识别数组大小，换言之，数组大小也可能不是 16。<br><strong>#9.DataDirectory</strong><br>DataDirectory 是由 IMAGE_DATA_DIRECTORY 结构体（又在 IMAGE_OPTIONAL_HEADER32 嵌套了一个结构体）组成的数组，数组的每项都有被定义的值。代码 13-7 列出了各数组项。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581220939315-f48aab94-3d1f-41ca-b627-9d03fbeab306.png#align=left&display=inline&height=367&name=QQ%E6%88%AA%E5%9B%BE20200209120209.png&originHeight=367&originWidth=905&size=310108&status=done&style=none&width=905" alt="QQ截图20200209120209.png"><br><strong>将此处所说的 Directory 想成某个结构体数组即可。</strong>希望各位重点关注标红的 EXPORT/IMPORT/RESOURCE、TLS Direction。特别需要注意的是 IMPORT 与 EXPORT Directory，它们是 PE 头中非常重要的部分，后面会单独讲解。其余部分不怎么重要，大致了解一下即可。<br><strong>IMAGE OPTIONAL HEADER</strong><br>前面简要介绍了重要成员组。现在查看 notepad.exe 的 IMAGE_OPTIONAL_HEADER 整个结构体。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581223822863-8160b623-93ff-4bba-aeb1-d17ceec80c08.png#align=left&display=inline&height=463&name=QQ%E6%88%AA%E5%9B%BE20200209125013.png&originHeight=795&originWidth=806&size=338663&status=done&style=none&width=469" alt="QQ截图20200209125013.png"><br>图 13-7 notepad.exe 的 IMAGE_OPTIONAL_HEADER<br>图 13-7 中，Hex Editor（HxD)描述的是 notepad.exe 的 IMAGE OPTIONALHEADER 结构体区域。结构体各成员的值及其说明如代码 13-8 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581224243555-d10f9a58-7895-41f4-9a0a-a843f84df0a8.png#align=left&display=inline&height=834&name=QQ%E6%88%AA%E5%9B%BE20200209125639.png&originHeight=834&originWidth=900&size=634534&status=done&style=none&width=900" alt="QQ截图20200209125639.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581224249438-8190aee4-aae3-45b6-8927-27ff3e2fddba.png#align=left&display=inline&height=591&name=QQ%E6%88%AA%E5%9B%BE20200209125709.png&originHeight=591&originWidth=901&size=488643&status=done&style=none&width=901" alt="QQ截图20200209125709.png"></p>
<h2 id="13-3-6-节区头"><a href="#13-3-6-节区头" class="headerlink" title="13.3.6 节区头"></a>13.3.6 节区头</h2><p>节区头中定义了各节区属性。看节区头之前先思考一下：前面提到过，PE 文件中的**code(代码）、data（数据）、resource（资源)**等按照属性分类存储在不同节区，设计 PE 文件格式的工程师们之所以这样做，一定有着某些好处。<br>我认为把 PE 文件创建成多个节区结构的好处是，这样可以保证程序的安全性。若把 code 与 data 放在一个节区中相互纠缠（实际上完全可以这样做）很容易引发安全问题，即使忽略过程的烦琐。<br>假如向字符串 data 写数据时，由于某个原因导致溢出（输入超过缓冲区大小时），那么其下的 code（指令）就会被覆盖，应用程序就会崩溃。因此，PE 文件格式的设计者们决定把具有相似属性的数据统一保存在一个被称为“节区”的地方，然后需要把各节区属性记录在节区头中（节区属性中有文件/内存的起始位置、大小、访问权限等）。<br>换言之，需要为每个 code/data/resource 分别设置不同的特性、访问权限等，如表 13-3 所示。<br>表 13-3 不同内存属性的访问权限</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>访问权限</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>执行，读取权限</td>
</tr>
<tr>
<td>data</td>
<td>非执行，读写权限</td>
</tr>
<tr>
<td>resource</td>
<td>非执行，读取权限</td>
</tr>
</tbody></table>
<p>至此，大家应当对节区头的作用有了大致了解。<br><strong>IMAGE_SECTION_HEADER</strong><br>节区头是由 IMAGE_SECTION_HEADER 结构体组成的数组，每个结构体对应一个节区。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581224679494-1457d1cd-57b1-4f62-bd3f-0ef03d97eeb1.png#align=left&display=inline&height=387&name=QQ%E6%88%AA%E5%9B%BE20200209130412.png&originHeight=387&originWidth=904&size=301491&status=done&style=none&width=904" alt="QQ截图20200209130412.png"><br>表 13-4 中列出了 IMAGE_SECTION_HEADER 结构体中要了解的重要成员（不使用其他成员）。</p>
<p>表 13-4 IMAGE_SECTION_HEADER 结构体的重要成员</p>
<table>
<thead>
<tr>
<th><strong>项目</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>VirtualSize</strong></td>
<td><strong>内存中节区所占的大小</strong></td>
</tr>
<tr>
<td><strong>VirtualAddress</strong></td>
<td><strong>内存中节区起始地址（RVA）</strong></td>
</tr>
<tr>
<td><strong>SizeOfRawData</strong></td>
<td><strong>磁盘文件中节区所占大小</strong></td>
</tr>
<tr>
<td><strong>PointerToRawData</strong></td>
<td><strong>磁盘文件中节区起始位置</strong></td>
</tr>
<tr>
<td><strong>Charateristics</strong></td>
<td><strong>节区属性</strong></td>
</tr>
</tbody></table>
<p>VirtualAddress 与 PointerToRawData 不带有任何值，分别由（定义在 IMAGE_OPTIONAL_HEADER32（NT 头：可选头）中的）SectionAlignment 与 FileAlignment 确定。<br>VirtualSize 与 SizeOfRawData 一般具有不同的值，即磁盘文件中节区的大小与加载到内存中的节区大小是不同的。<br>Characterisitics 由代码 13-10 中显示的值组合（bitOR)而成。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581225218665-5454dcdd-d0de-4c8a-9fac-60a939ad0b65.png#align=left&display=inline&height=315&name=QQ%E6%88%AA%E5%9B%BE20200209131325.png&originHeight=315&originWidth=907&size=247013&status=done&style=none&width=907" alt="QQ截图20200209131325.png"><br>最后谈谈<strong>Name</strong>字段。Name 成员不像 C 语言中的字符串一样以 NULL 结束，并且没有“必须使用 ASCI 值”的限制。PE 规范未明确规定节区的 Name，所以可以向其中放入任何值，甚至可以填充 NULL 值。所以节区的 Name 仅供参考，不能保证其百分之百地被用作某种信息（数据节区的名称也可叫做.code)。<br>下面看一下 notepad.exe 的节区头数组（共有 3 个节区），如图 13-8 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581225389483-1f0ad949-bbef-4532-8816-a5d1647b83a7.png#align=left&display=inline&height=444&name=QQ%E6%88%AA%E5%9B%BE20200209131618.png&originHeight=444&originWidth=806&size=166068&status=done&style=none&width=806" alt="QQ截图20200209131618.png"><br>图 13-8 notepad.exe 的 IMAGE_SECTION_HEADER 结构体数组<br>接着看一下各结构体成员，如代码 13-11 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581225469969-9fe3f45b-194f-4fca-b098-dbdb92929ea6.png#align=left&display=inline&height=784&name=QQ%E6%88%AA%E5%9B%BE20200209131738.png&originHeight=784&originWidth=696&size=510472&status=done&style=none&width=696" alt="QQ截图20200209131738.png"><br>提示——————————————————————————————————————<br><strong>讲解 PE 文件时经常出现“映像”（Image)这一术语，希望各位牢记。PE 文件加载到内存时，文件不会原封不动地加载，而要根据节区头中定义的节区起始地址、节区大小等加载。因此，磁盘文件中的 PE 与内存中的 PE 具有不同形态。**<strong>将装载到内存中的形态称为“映像”以示区别*</strong>*，使用这一术语能够很好地区分二者。</strong></p>
<hr>
<h1 id="13-4-RVA-to-RAW"><a href="#13-4-RVA-to-RAW" class="headerlink" title="13.4 RVA to RAW"></a>13.4 RVA to RAW</h1><p>理解了节区头后，下面继续讲解有关 PE 文件从磁盘到内存映射的内容。<strong>PE 文件加载到内存时，每个节区都要能准确完成内存地址与文件偏移间的映射。这种映射一般称为 RVA to RAW</strong>，方法如下。<br>（1）查找 RVA 所在节区。<br>（2）使用简单的公式计算<strong>文件偏移</strong>。<br>   <strong>根据 IMAGE_SECTION_HEADER（节区头）结构体，换算公式如下：</strong></p>
<blockquote>
<p><strong>RAW-PointerToRawData=RVA-VirtualAddress=Imagebase</strong> &gt; <strong>RAW=RVA-VirtualAddress（是使用 RVA 形式表示的值）+PointerToRawData</strong></p>
</blockquote>
<p><strong>Quiz</strong><br>简单做个测试练习。图 13-9 描绘的是 notepad.exe 的文件与内存间的映射关系。请分别计算各个 RVA（将计算器 calc.exe 切换到 Hex 模式计算会比较方便）。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581226000189-9c32d660-6e3c-4396-901f-c872c0c60641.png#align=left&display=inline&height=425&name=QQ%E6%88%AA%E5%9B%BE20200209132628.png&originHeight=765&originWidth=630&size=376950&status=done&style=none&width=350" alt="QQ截图20200209132628.png"><br>Q1.RVA=5000 时，File Offset（文件偏移）=?<br>A1.首先查找 RVA 值所在节区。<br>   →RVA 5000 位于第一个节区（.text)（假设 ImageBase 为 01000000）。<br>    使用公式换算如下：<br>   →RAW=5000(RVA)-1000(VirtualAddress，也就是 VA)+400(Pointer ToRawData)=4400</p>
<hr>
<p>复习一下，VA 指的是<strong>进程虚拟内存的绝对地址</strong>，RVA（Relative Virtual Address，<strong>相对虚拟地址</strong>）指从某个<strong>基准位置</strong>（ImageBase）开始的<strong>相对地址</strong>。VA 与 RVA 满足下面的换算关系。<br>RVA+ImageBase=VA<br><strong>———————————————————————————————————————-</strong><br><strong>来自 Q&amp;A：</strong><br><strong>Q.对图 13-9 及其下面的 Quiz 不是很理解。如何知道 RVA5000 包含在哪个节区呢？</strong><br><strong>A.图 13-9 是以节区头信息为基础绘制的。图（或节区头信息）中的.text 节区是指 VA01001000<del>01009000 区域，转换为 RVA 形式后对应于 RVA1000-</del>9000 区域（即减去 Imagebase 值的 01000000)。由此可知，RVA5000 包含在.text 节区中。</strong><br><strong>———————————————————————————————————————-</strong><br>Q2.RVA=13314 时，File Offset=?<br>A2.查找 RVA 值所在节区。<br>   →RVA13314 位于第三个节区（.rsrc)。<br>    使用公式换算如下：<br>   →RAW=13314(RVA)-B000(VA)+8400(Pointer ToRawData)=10714<br>Q3.RVA=ABA8 时，File Offset=?<br>A3.查找 RVA 值所在节区。<br>→RVAABA8 位于第二个节区（.data)。<br>使用公式换算如下：<br>→RAW=ABA8(RVA)-9000(VA)+7C00(Pointer ToRawData)=97A8(×)→ 计算结果为 RAW=97A8，但是该偏移在第三个节区（.rsrc)。RVA 在第二个节区，而 RAW 在第三个节区，这显然是错误的。该情况表明“无法定义与 RVA（ABA8）相对应的 RAW 值”。出现以上情况的原因在于，第二个节区的 VirtualSize 值要比 SizeOfRawData 值大。<br>提示——————————————————————————————————————<br>RVA 与 RAW（文件偏移）间的相互变换是 PE 头的最基本的内容，各位一定要熟悉并掌握它们之间的转换关系。</p>
<hr>
<p>像 Q3 一样，PE 文件节区中因 VirtualSize 与 SizeOfRawData 值彼此不同而引起的奇怪、有趣的事还有很多（后面会陆续讲到）。<br>以上就是对 PE 头基本结构体的介绍，接下来将继续学习 PE 头的核心内容—<strong>IAT（ImportAddress Table,导入地址表）与 EAT（Export Address Table,导出地址表）</strong>。</p>
<h1 id="13-5-IAT"><a href="#13-5-IAT" class="headerlink" title="13.5 IAT"></a>13.5 IAT</h1><p>刚开始学习 PE 头时，最难过的一关就是<strong>IAT（Import Address Table，导入地址表）</strong>。IAT 保存的内容与 Windows 操作系统的核心进程、内存、DLL 结构等有关。换句话说，只要理解了 IAT，就掌握了 Windows 操作系统的根基。<strong>简言之，IAT 是一种表格，用来记录程序正在使用哪些库中的哪些函数。</strong></p>
<h2 id="13-5-1-DLL"><a href="#13-5-1-DLL" class="headerlink" title="13.5.1 DLL"></a>13.5.1 DLL</h2><p>讲解 IAT 前先学习一下有关 DLL（Dynamic Linked Library)的知识（知其所以然，才更易理解），它支撑起了整座 WindowsOS 大厦。DLL 翻译成中文为“动态链接库”，为何这样称呼呢?<br>16 位的 DOS 时代不存在 DLL 这一概念，只有“库”（Library）一说。比如在 C 语言中使用 printf()函数时，编译器会先从 C 库中读取相应函数的二进制代码，然后插入（包含到）应用程序。也就是说，可执行文件中包含着 printf()函数的二进制代码。Windows OS 支持多任务，若仍采用这种包含库的方式，会非常没有效率。Windows 操作系统使用了数量庞大的库函数（进程、内存、窗口、消息等）来支持 32 位的 Windows 环境。同时运行多个程序时，若仍像以前一样每个程序运行时都包含相同的库，将造成严重的内存浪费（当然磁盘空间的浪费也不容小觑）。因此，Windows OS 设计者们根据需要引入了 DLL 这一概念，描述如下。</p>
<ul>
<li>不要把库包含到程序中，单独组成 DLL 文件，需要时调用即可。</li>
<li>内存映射技术使加载后的 DLL 代码、资源在多个进程中实现共享。</li>
<li>更新库时只要替换相关 DLL 文件即可，简便易行。</li>
</ul>
<p>加载 DLL 的方式实际有两种：一种是“<strong>显式链接</strong>”（Explicit Linking)，程序使用 DLL 时加载，使用完毕后释放内存；另一种是“<strong>隐式链接</strong>”（Implicit Linking)，程序开始时即一同加载 DLL，程序终止时再释放占用的内存。<strong>IAT 提供的机制即与隐式链接有关。</strong>下面使用 OllyDbg 打开 notepad.exe 来查看 IAT。图 13-10 是调用 CreateFileW()函数的代码，该函数位于 kernel32.dll 中。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581233942230-c33d9a7b-5589-4d53-9f2e-5af67f87f015.png#align=left&display=inline&height=373&name=QQ%E6%88%AA%E5%9B%BE20200209153846.png&originHeight=373&originWidth=708&size=164341&status=done&style=none&width=708" alt="QQ截图20200209153846.png"><br>调用 CreateFileW()函数时<strong>并非直接调用</strong>，而是通过获取 01001104 地址处的值来实现（所有 API 调用均采用这种方式）。<br>地址 01001104 是 notepad.exe 中.text 节区的内存区域（更确切地说是 IAT 内存区域）。01001104 地址的值为 7C8107F0，而 7C8107F0 地址即是加载到 notepad.exe 进程内存中的 CreateFileW()函数（位于 kernel32.dl 库中）的地址。此处产生一个疑问。</p>
<blockquote>
<p>“直接使用 CALL 7C8107F0 指令调用函数不是更好、更方便吗?”</p>
</blockquote>
<p>甚至还会有人问：“编译器直接写 CALL 7C8107F0 不是更准确、更好吗?”这是前面说过的 DOS 时代的方式。<br>事实上，notepad.exe 程序的制作者编译（生成）程序时，并不知道该 notepad.exe 程序要运行在哪种   Windows（9X、2K、XP、Vista、7）、哪种语言（ENG、JPN、KOR 等）、哪种服务包（ServicePack)下。上面列举出的所有环境中，kernel32.dll 的版本各不相同，CreateFileW()函数的位置（地址）也不相同。为了确保在所有环境中都能正常调用 CreateFileW()函数，编译器准备了要保存 CreateFileW()函数实际地址的位置（01001104），并仅记下 CALL DWORD PTR DS：[1004404]形式的指令。执行文件时，PE 装载器将 CreateFileW()函数的地址写到 01001104 位置。<br>编译器不使用 CALL 7C8107F0 语句的另一个原因在于 DLL 重定位。DLL 文件的 ImageBase 值一般为 10000000。比如某个程序使用 a.dll 与 b.dll 时，PE 装载器先把 a.dll 装载到内存的 10000000（ImageBase)处，然后尝试把 b.dl 也装载到该处。但是由于该地址处已经装载了 a.dll，所以 PE 装载器查找其他空白的内存空间（ex:3E000000），然后将 b.dl 装载进去。<br>这就是所谓的 DLL 重定位，它使我们无法对实际地址硬编码。另一个原因在于，PE 头中表示地址时不使用 VA，而是 RVA。<br>提示——————————————————————————————————————<br>实际操作中无法保证 DLL 一定会被加载到 PE 头内指定的 ImageBase 处。但是<strong>EXE 文件（生成进程的主体）却能准确加载到自身的 ImageBase 中，因为它拥有自己的虚拟空间。</strong></p>
<hr>
<p>PE 头的 IAT 是代码逆向分析的核心内容。希望各位好好理解它。相信大家现在已经能够掌握 IAT 的作用了（后面讲解 IAT 结构为什么如此复杂时，希望各位也能很快了解）。</p>
<h2 id="13-5-2-IMAGE-IMPORT-DESCRIPTOR"><a href="#13-5-2-IMAGE-IMPORT-DESCRIPTOR" class="headerlink" title="13.5.2 IMAGE_IMPORT_DESCRIPTOR"></a>13.5.2 IMAGE_IMPORT_DESCRIPTOR</h2><p>IMAGE_IMPORT_DESCRIPTOR 结构体中记录着 PE 文件要导入哪些<strong>库文件</strong>。<br>提示——————————————————————————————————————</p>
<ul>
<li>Import：导入，向库提供服务（函数）。</li>
<li>Export:导出，从库向其他 PE 文件提供服务（函数）。</li>
</ul>
<hr>
<p>IMAGE_IMPORT_DESCRIPTOR 结构体如代码 13-12 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581234628294-a54236b0-05ed-47de-8b21-8c67f8f7d253.png#align=left&display=inline&height=392&name=QQ%E6%88%AA%E5%9B%BE20200209154934.png&originHeight=392&originWidth=977&size=310395&status=done&style=none&width=977" alt="QQ截图20200209154934.png"><br><strong>执行一个普通程序时往往需要导人多个库，导入多少库就存在多少个 IMAGE_IMPORT_DESCRIPTOR 结构体，这些结构体形成了数组，且结构体数组最后以 NULL 结构体结束。</strong><br>IMAGE_IMPORT_DESCRIPTOR 中的重要成员如表 13-5 所示（拥有全部 RVA 值）。<br>表 13-5 IMAGE_IMPORT_DESCRIPTOR 结构体的重要成员</p>
<table>
<thead>
<tr>
<th><strong>项目</strong></th>
<th><strong>含义</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>OriginalFirstThunk</strong></td>
<td><strong>INT 的地址（RVA）</strong></td>
<td></td>
</tr>
<tr>
<td><strong>Name</strong></td>
<td><strong>库名称字符串的地址（RVA）</strong></td>
<td></td>
</tr>
<tr>
<td><strong>FirstThunk</strong></td>
<td><strong>IAT 的地址（RVA）</strong></td>
<td></td>
</tr>
</tbody></table>
<p><strong>提示—————————————————————————————————————–</strong></p>
<ul>
<li><strong>PE 头中提到的“Table”即指数组。</strong></li>
<li><strong>INT 与 IAT 是长整型（4 个字节数据类型）数组，以 NULL 结束（未另外明确指出大小）。</strong></li>
<li><strong>INT 中各元素的值为 IMAGE_IMPORT_BY_NAME 结构体指针（有时 IAT 也拥有相同的值）。</strong></li>
<li><strong>INT 与 IAT 的大小应相同。</strong></li>
</ul>
<p><strong>———————————————————————————————————————-</strong><br>图 13-11 描述了 notepad.exe 之 kernel32.dll 的 IMAGE_IMPORT_DESCRIPTOR 结构。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581235181995-4e73ca1f-ecc9-4552-8100-76a50c04a5a3.png#align=left&display=inline&height=239&name=QQ%E6%88%AA%E5%9B%BE20200209155921.png&originHeight=493&originWidth=784&size=174921&status=done&style=none&width=380" alt="QQ截图20200209155921.png"><br>图 13-11 中，<strong>INT 与 IAT 的各元素同时指向相同地址，但也有很多情况下它们是不一致的</strong>（后面会陆续接触很多变形的 PE 文件，到时再逐一讲解）。<br>下面了解一下 PE 装载器把导入函数输入至 IAT 的顺序。<br><strong>———————————————————————————————————————-</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581235352495-50841ebf-e971-4eef-9973-155c7de5c7d0.png#align=left&display=inline&height=257&name=QQ%E6%88%AA%E5%9B%BE20200209160222.png&originHeight=257&originWidth=974&size=211473&status=done&style=none&width=974" alt="QQ截图20200209160222.png"><br><strong>———————————————————————————————————————-</strong></p>
<h2 id="13-5-3-使用-notepad-exe-练习"><a href="#13-5-3-使用-notepad-exe-练习" class="headerlink" title="13.5.3 使用 notepad.exe 练习"></a>13.5.3 使用 notepad.exe 练习</h2><p>下面以 notepad.exe 为对象逐一查看。先提一个问题：IMAGE_IMPORT_DESCRIPTOR 结构体数组究竟存在于 PE 文件的哪个部分呢?<br><strong>它不在 PE 头而在 PE 体中，但查找其位置的信息在 PE 头中，IMAGE_OPTIONAL_HEADER32.DataDirectory[1].VirtualAddress 的值即是 IMAGE_IMPORT_DESCRIPTOR 结构体数组的起始地址（RVA 值）。IMAGE_IMPORT_DESCRIPTOR 结构体数组也被称为 IMPORT Directory Table(只有了解上述全部称谓，与他人交流时才能没有障碍）。</strong><br>   <strong>IMAGE_OPTIONAL_HEADER32.DataDirectory[1]结构体</strong>的值如图 13-12 所示（第一个 4 字节为<strong>虚拟地址</strong>，第二个 4 字节为<strong>Size 成员</strong>）。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581235721044-7dee5907-cd4f-4a88-a393-473f1b8b8f93.png#align=left&display=inline&height=59&name=QQ%E6%88%AA%E5%9B%BE20200209160826.png&originHeight=59&originWidth=754&size=24106&status=done&style=none&width=754" alt="QQ截图20200209160826.png"><br>图 13-12 notepad.exe 的 IMAGE_OPTIONAL_HEADER32.DataDirectory[1]<br>整理图 13-12 中的 IMAGE_OPTIONAL_HEADER32.DataDirectory 结构体数组的信息以便查看，如表 13-6 所示（加深的部分是与导入相关的信息）。<br><strong>———————————————————————————————————————-</strong><br>表 13-6 notepad.exe 文件的 DataDirectory 数组-lmport<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581235873883-f11a6d30-273e-4b89-b89a-d1cbfc723c7a.png#align=left&display=inline&height=213&name=QQ%E6%88%AA%E5%9B%BE20200209161106.png&originHeight=213&originWidth=1000&size=78827&status=done&style=none&width=1000" alt="QQ截图20200209161106.png"><br><strong>———————————————————————————————————————-</strong><br>像在图 13-12 中看到的一样，因为 RVA 是 7604，故文件偏移为 6A04。在文件中查看 6A04，如图 13-13 所示（请使用“RVA to RAW”转换公式）。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581236049090-69aab323-933f-40ea-bbef-4057d0b61c73.png#align=left&display=inline&height=314&name=QQ%E6%88%AA%E5%9B%BE20200209161356.png&originHeight=546&originWidth=806&size=241002&status=done&style=none&width=463" alt="QQ截图20200209161356.png"><br>图 13-13 notepad.exe 的 IMAGE_IMPORT_DESCRIPTOR 结构体数组<br>图 13-13 中，阴影部分即为全部的 IMAGE_IMPORT_DESCRIPTOR 结构体数组，粗线框内的部分是结构体数组的第一个元素（也可以看到数组的最后是由 NULL 结构体组成的）。下面分别看一下粗线框中 IMAGE_IMPORT_DESCRIPTOR 结构体的各个成员，如表 13-7 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581236275613-c384c281-b8d3-4043-af4b-ee1b7005cf0d.png#align=left&display=inline&height=220&name=QQ%E6%88%AA%E5%9B%BE20200209161713.png&originHeight=220&originWidth=997&size=81165&status=done&style=none&width=997" alt="QQ截图20200209161713.png"><br>由于我们只是为了学习 IAT，所以没有使用专业的 PE Viewer，而是使用 Hex Editor 逐一查看（为方便起见，结构体的值（RVA）已经被转换为文件偏移（RAW）。希望各位亲自转换一下）。下面依序看看吧。<br><strong>1.库名称（Name）</strong><br><strong>Name 是一个字符串指针，它指向导入函数所属的库文件名称。</strong>在图 13-14 的文件偏移 6EAC（RVA：7AAC→RAW:6EAC)处看到字符串 comdlg32.dll 了吧？<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581236459871-5ea08124-9d40-430e-8bfc-d9a378f455cc.png#align=left&display=inline&height=549&name=QQ%E6%88%AA%E5%9B%BE20200209162031.png&originHeight=549&originWidth=806&size=295597&status=done&style=none&width=806" alt="QQ截图20200209162031.png"><br><strong>2.OriginalFirstThunk-INT</strong><br><strong>INT 是一个包含导入函数信息（Ordinal，Name)的结构体指针数组</strong>。只有获得了这些信息，才能在加载到进程内存的库中准确求得相应函数的起始地址（请参考后面 EAT 的讲解）。<br>跟踪 OriginalFirstThunk 成员（RVA：7990→RAW：6D90）。<br>图 13-15 是 INT，由地址数组形式组成（数组尾部以 NULL 结束）。每个地址值分别指向 IMAGE_IMPORT_BY NAME 结构体（参考图 13-11）。跟踪数组的第一个值 7A7A（RVA），进入该地址，可以看到导入的 API 函数的名称字符串。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581237260116-105f2c51-5741-4253-a577-b32c5243009a.png#align=left&display=inline&height=119&name=QQ%E6%88%AA%E5%9B%BE20200209163407.png&originHeight=119&originWidth=774&size=63057&status=done&style=none&width=774" alt="QQ截图20200209163407.png"><br>图 13-15 INT<br><strong>3.IMAGE_IMPORT_BY_NAME</strong><br>RVA：7A7A 即为 RAW：6E7A。<br>文件偏移 6E7A 最初的 2 个字节值（000F）为 Ordinal，是库中函数的固有编号。Ordinal 的后面为函数名称字符串 PageSetupDlgW（同 C 语言一样，字符串末尾以 Terminating NULL[‘\0’]结束）。<br>如图 13-16 所示，INT 是 IMAGE_IMPORT_BY_NAME 结构体指针数组（参考代码 13-12）。数组的第一个元素指向函数的 Ordinal 值 000F，函数的名称为 PageSetupDlgW。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581237454082-cca48fc7-93d6-459e-889b-b339381cc9d6.png#align=left&display=inline&height=65&name=QQ%E6%88%AA%E5%9B%BE20200209163726.png&originHeight=65&originWidth=768&size=40567&status=done&style=none&width=768" alt="QQ截图20200209163726.png"><br>图 13-16 IMAGE IMPORT BY NAME<br><strong>4.FirstThunk-IAT(Import Address Table)</strong><br>IAT 的 RVA:12C4 即为 RAW：6C4。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581237635229-53ea6188-422c-46b0-b55b-3ead63ffbe90.png#align=left&display=inline&height=102&name=QQ%E6%88%AA%E5%9B%BE20200209164015.png&originHeight=102&originWidth=757&size=65288&status=done&style=none&width=757" alt="QQ截图20200209164015.png"><br>图 13-17 FirstThunk-IAT<br>图 13-17 中文件偏移 6C4-6EB 区域即为 IAT 数组区域，对应于 comdlg32.dll 库。它与 INT 类似，由结构体指针数组组成，且以 NULL 结尾。<br>IAT 的第一个元素值被硬编码为 76324906，该值无实际意义，notepad.exe 文件加载到内存时，准确的地址值会取代该值。<br>提示——————————————————————————————————————</p>
<ul>
<li>其实我的系统（Windows XP SP3）中，地址 76324906 即是 comdlg32.dll!PageSetupDlgW 函数的准确地址值。但是该文件在 Windows7 中也能顺利运行。运行 notepad.exe 进程时，PE 装载器会使用相应 API 的起始地址替换该值。</li>
<li>微软在制作服务包过程中重建相关系统文件，此时会硬编入准确地址（普通的 DLL 实际地址不会被硬编码到 IAT 中，通常带有与 INT 相同的值）。</li>
<li>另外，普通 DLL 文件的 ImageBase 为 10000000，所以经常会发生 DLL 重定位。但是 Windows 系统 DLL 文件（kernel32/user32/gdi32 等）拥有自身固有的 ImageBase，不会出现 DLL 重定位。</li>
</ul>
<hr>
<p>下面使用 OllyDbg 查看 notepad.exe 的 IAT，如图 13-18 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581238760308-82a81a6c-734e-41bf-b2b2-93d9d1bde293.png#align=left&display=inline&height=254&name=QQ%E6%88%AA%E5%9B%BE20200209165905.png&originHeight=254&originWidth=499&size=99450&status=done&style=none&width=499" alt="QQ截图20200209165905.png"><br>图 13-18 notepad.exe 的 IAT<br>notepad.exe 的 ImageBase 值为 01000000。所以 comdlg32.dll!PageSetupDlgW 函数的 IAT 地址为 010012C4，其值为 76324906，它是 API 准确的起始地址值。<br>提示——————————————————————————————————————<br>若在其他 OS（2000、Vista 等）或服务包（SP1、SP2）中运行 XP SP3notepad.exe，010012C4 地址中会被设置为其他值（相应 OS 的 comdlg32.dl!PageSetupDlgW 地址）。</p>
<hr>
<p>进入 7632490 地址中，如图 13-19 所示，可以看到该处即为 comdlg32.dll 的 PageSetupDlgW 函数的起始位置。<br>以上是对 IAT 的基本讲解，都是一些初学者不易理解的概念。反复阅读前面的讲解，并且实际进入相应地址查看学习，将非常有助于对概念的掌握。IAT 是 Windows 逆向分析中的重要概念，一定要熟练把握。后面学习带有变形 IAT 的 PE Patch 文件时，会进一步学习 IAT 相关知识。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581238786142-19a26e2a-2fae-4666-a4ec-7137f65263c4.png#align=left&display=inline&height=329&name=QQ%E6%88%AA%E5%9B%BE20200209165934.png&originHeight=329&originWidth=671&size=125968&status=done&style=none&width=671" alt="QQ截图20200209165934.png"></p>
<h1 id="13-6-EAT"><a href="#13-6-EAT" class="headerlink" title="13.6 EAT"></a>13.6 EAT</h1><p>Windows 操作系统中，“库”是为了方便其他程序调用而集中包含相关函数的文件（DLL/SYS)。Win32API 是最具代表性的库，其中的 kernel32.dll 文件被称为最核心的库文件。<br><strong>EAT 是一种核心机制，它使不同的应用程序可以调用库文件中提供的函数。也就是说，只有通过 EAT 才能准确求得从相应库中导出函数的起始地址。</strong>与前面讲解的 IAT 一样，PE 文件内的特定结构体（IMAGE_EXPORT_DIRECTORY)保存着导出信息，且 PE 文件中<strong>仅有一个</strong>用来说明库 EAT 的 IMAGE_EXPORT_DIRECTORY 结构体。<br>提示——————————————————————————————————————<br>用来说明 IAT 的 IMAGE_IMPORT_DESCRIPTOR 结构体以数组形式存在，且拥有多个成员。这样是因为 PE 文件可以同时导入多个库。</p>
<hr>
<p>可以在 PE 文件的 PE 头中查找到 IMAGE_EXPORT_DIRECTORY 结构体的位置。IMAGE_OPTIONAL_HEADER32.DataDirectory[0].VirtualAddress 值即是 IMAGE_EXPORT_DIRECTORY 结构体数组的起始地址（也是 RVA 的值）。<br>图 13-20 显示的是 kernel32.dll 文件的 IMAGE_OPTIONAL_HEADER32.DataDirectory[0](第一个 4 字节为 VirtualAddress，第二个 4 字节为 Size 成员，参考代码 13-6）。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581242288711-a495f219-6977-460b-84c4-26e8d06a6ec2.png#align=left&display=inline&height=106&name=QQ%E6%88%AA%E5%9B%BE20200209175758.png&originHeight=106&originWidth=719&size=50209&status=done&style=none&width=719" alt="QQ截图20200209175758.png"><br>为便于查看，将图 13-20 中的 IMAGE_OPTIONAL_HEADER32.DataDirectory 结构体数组信息整理如下表 13-8（深色部分为“导出”相关信息）。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581242349192-c10f5db4-4055-42cb-bc78-8751ffb31234.png#align=left&display=inline&height=238&name=QQ%E6%88%AA%E5%9B%BE20200209175859.png&originHeight=238&originWidth=684&size=74468&status=done&style=none&width=684" alt="QQ截图20200209175859.png"><br>由于 RVA 值为 262C，所以文件偏移为 1A2C（希望各位多练习 RVA 与文件偏移间的转换过程）</p>
<h2 id="13-6-1-IMAGE-EXPORT-DIRECTORY"><a href="#13-6-1-IMAGE-EXPORT-DIRECTORY" class="headerlink" title="13.6.1 IMAGE_EXPORT_DIRECTORY"></a>13.6.1 IMAGE_EXPORT_DIRECTORY</h2><p>IMAGE_EXPORT_DIRECTORY 结构体如代码 13-14 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581242457570-c56b457f-9567-4b4b-9de6-2faa31c7d9ff.png#align=left&display=inline&height=342&name=QQ%E6%88%AA%E5%9B%BE20200209180047.png&originHeight=342&originWidth=976&size=264845&status=done&style=none&width=976" alt="QQ截图20200209180047.png"><br>下面讲解其中的重要成员（<strong>全部地址均为 RVA</strong>），如表 13-9 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581242522255-e23fb370-b9cc-427e-ad71-3c171795af19.png#align=left&display=inline&height=227&name=QQ%E6%88%AA%E5%9B%BE20200209180147.png&originHeight=227&originWidth=986&size=95994&status=done&style=none&width=986" alt="QQ截图20200209180147.png"><br>图 13-21 描述的是 kernel32.dll 文件的 IMAGE_EXPORT_DIRECTORY 结构体与整个 EAT 结构。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581242600900-12ced865-b258-4bed-8a92-de505093e06a.png#align=left&display=inline&height=311&name=QQ%E6%88%AA%E5%9B%BE20200209180300.png&originHeight=582&originWidth=541&size=200582&status=done&style=none&width=289" alt="QQ截图20200209180300.png"><br><strong>从库中获得函数地址的 API 为 GetProcAddress()函数。该 API 用 EAT 来获取指定 API 的地址。</strong>GetProcAddress()API 拥有函数名称，下面讲解它如何获取函数地址。理解了这一过程，就等于征服了 EAT。<br><strong>GetProcAddress()操作原理—————————————————————————————–</strong><br><strong>（1）利用 AddressOfNames 成员转到“函数名称数组”。</strong><br><strong>（2）“函数名称数组”中存储着字符串地址。通过比较（strcmp)字符串，查找指定的函数名称（此时数组的索引称为 name_index）。</strong><br><strong>（3）利用 AddressOfNameOrdinals 成员，转到 orinal 数组。</strong><br><strong>（4）在 ordinal 数组中通过 name_index 查找相应 ordinal 值。</strong><br><strong>（5）利用 AddressOffunctions 成员转到“函数地址数组”（EAT）。</strong><br><strong>（6）在“函数地址数组”中将刚刚求得的 ordinal 用作数组索引，获得指定函数的起始地址。</strong><br><strong>———————————————————————————————————————-</strong><br>图 13-21 描述的是 kernel32.dll 文件的情形。<strong>kernel32.dll 中所有导出函数均有相应名称，AddressOfNameOrdinals 数组的值以 index=ordinal 的形式存在。但并不是所有的 DLL 文件都如此。</strong><br><strong>导出函数中也有一些函数没有名称（仅通过 ordinal 导出），AddressOfNameOrdinals 数组的值为 index!=ordinal。所以只有按照上面的顺序才能获得准确的函数地址。</strong><br>提示——————————————————————————————————————<br>对于没有函数名称的导出函数，可以通过 Ordinal 查找到它们的地址。从 Ordinal 值中减去 IMAGE EXPORT DIRECTORY.Base 成员后得到一个值，使用该值作为“函数地址数组”的索引，即可查找到相应函数的地址。</p>
<hr>
<h2 id="13-6-2-使用-kernel32-dll-练习"><a href="#13-6-2-使用-kernel32-dll-练习" class="headerlink" title="13.6.2 使用 kernel32.dll 练习"></a>13.6.2 使用 kernel32.dll 练习</h2><p>下面看看如何实际从 kernel32.dll 文件的 EAT 中查找 AddAtomW 函数（参考图 13-21）。由表 13-8 可知，<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581242349192-c10f5db4-4055-42cb-bc78-8751ffb31234.png#align=left&display=inline&height=238&name=QQ%E6%88%AA%E5%9B%BE20200209175859.png&originHeight=238&originWidth=684&size=74468&status=done&style=none&width=684" alt="QQ截图20200209175859.png"><br>kernel32.dll 的 IMAGE_EXPORT_DIRECTORY 结构体 RAW 为 1A2C。使用 Hex Editor 进入 1A2C 偏移处，如图 13-22 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581246328622-4bc8a2b0-4999-4e2c-85d6-55054f1bf84b.png#align=left&display=inline&height=124&name=QQ%E6%88%AA%E5%9B%BE20200209190518.png&originHeight=124&originWidth=756&size=66327&status=done&style=none&width=756" alt="QQ截图20200209190518.png"><br>图 13-22 kernel32.dll 的 IMAGE_EXPORT_DIRECTORY 结构体<br>图 13-22 深色部分就是 IMAGE_EXPORT_DIRECTORY 结构体区域。该 IMAGE_EXPORT_DIRECTORY 结构体的各个成员如表 13-10 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581246471415-947b546f-ac6b-44b9-a103-0045b12bacc9.png#align=left&display=inline&height=199&name=QQ%E6%88%AA%E5%9B%BE20200209190718.png&originHeight=199&originWidth=990&size=62948&status=done&style=none&width=990" alt="QQ截图20200209190718.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581246472257-b12329af-afb8-42fd-ac07-6583359ff7d7.png#align=left&display=inline&height=204&name=QQ%E6%88%AA%E5%9B%BE20200209190733.png&originHeight=204&originWidth=990&size=63013&status=done&style=none&width=990" alt="QQ截图20200209190733.png"><br>依照前面介绍的代码 13-15 的顺序查看。<br><strong>1.函数名称数组</strong><br>AddressOfNames 成员的值为 RVA=353C，即 RAW=293C。使用 Hex Editor 查看该地址，如图 13-23 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581246598810-87ffb22a-1d68-4e88-a31b-18dd0506626b.png#align=left&display=inline&height=254&name=QQ%E6%88%AA%E5%9B%BE20200209190947.png&originHeight=254&originWidth=726&size=166119&status=done&style=none&width=726" alt="QQ截图20200209190947.png"><br>（方框中）此处为 4 字节 RVA 组成的数组。数组元素个数为 NumberOfNames（3BA）。逐一跟随所有 RVA 值即可发现“函数名称字符串”。<br><strong>2.查找指定函数名称</strong><br>要查找的函数名称字符串为“AddAtomW”，只要在图 13-23 中找到 RVA 数组第三个元素的值（RVA：4BBD→RAW:3FBD)即可。<br>进入相应地址就会看到“AddAtomW”字符串，如图 13-24 所示。此时“AddAtomW”函数名即是图 13-23 数组的第三个元素，数组索引为 2。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581246851058-7201ea69-7bac-46e0-9e6a-a30f33a47822.png#align=left&display=inline&height=87&name=QQ%E6%88%AA%E5%9B%BE20200209191326.png&originHeight=87&originWidth=703&size=40371&status=done&style=none&width=703" alt="QQ截图20200209191326.png"><br><strong>3.Ordinal 数组</strong><br>下面查找“AddAtomW”函数的 Ordinal 值。AddressOfNameOrdinals 成员的值为 RVA：4424→RVA：3824。<br>    在图 13-25 中可以看到，深色部分是由多个 2 字节的 ordinal 组成的数组（ordinal 数组中的各元素大小为 2 个字节）。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581247055746-b22f294b-3d91-48af-a8b7-536dd4cde1b4.png#align=left&display=inline&height=134&name=QQ%E6%88%AA%E5%9B%BE20200209191726.png&originHeight=134&originWidth=712&size=75678&status=done&style=none&width=712" alt="QQ截图20200209191726.png"><br><strong>4.ordinal</strong><br>将 2 中求得的 index 值（2）应用到 3 中的 Ordinal 数组即可求得 Ordinal(2)。<br>AddressOfNameOrdinals[index]=ordinal(index=2,ordinal=2)<br><strong>5.函数地址数组-EAT</strong><br>最后查找 AddAtomW 的实际函数地址。AddressOffunctions 成员的值为 RVA：2654→RVA:1A54。<br>图 13-26 深色部分即为 4 字节函数地址 RVA 数组，它就是 Export 函数的地址。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581247645843-4b43bdfa-47b2-454c-ad20-6c9cb9e318d1.png#align=left&display=inline&height=139&name=QQ%E6%88%AA%E5%9B%BE20200209192714.png&originHeight=139&originWidth=713&size=82567&status=done&style=none&width=713" alt="QQ截图20200209192714.png"><br><strong>6.AddAtomW 函数地址</strong><br>图 13-26 中，为了获取“AddAtomW”函数的地址，将图 13-25 中求得的 Ordinal 用作图 13-26 数组的索引，得到 RVA=00326F1。<br>AddressOfFunctions[ordinal]=RVA(ordinal-2,RVA=326F1)<br>kernel32.dll 的 ImageBase=7C7D0000。因此 AddAtomW 函数的实际地址（VA）为 7C8026F1 （7C7D0000+326F1=7C8026F1）。可以使用 OllyDbg 验证，如图 13-27 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581248027654-0951be33-68b3-4d35-ab73-60f1b18f6bd6.png#align=left&display=inline&height=163&name=QQ%E6%88%AA%E5%9B%BE20200209193337.png&originHeight=163&originWidth=705&size=61338&status=done&style=none&width=705" alt="QQ截图20200209193337.png"><br>如图 13-27 所示，7C8026F1 地址（VA）处出现的就是要查找的 AddAtomW 函数。以上过程是在 DLL 文件中查找 Export 函数地址的方法，与使用 GetProcAddressOAPI 获取指定函数地址的方法最基本、最重要的部分到此就全部讲完了。<strong>要理解这些内容并不容易，若有不理解的暂且保留，通过实际操作慢慢理解。</strong></p>
<h1 id="13-7-高级-PE"><a href="#13-7-高级-PE" class="headerlink" title="13.7 高级 PE"></a>13.7 高级 PE</h1><p>前面我们花了相当长时间来学习 PE 文件格式相关知识。虽然可以根据 PE 规范逐一学习各结构体成员，但前面的学习中仅抽取与代码逆向分析息息相关的成员进行了说明。其中<strong>IAT/EAT 相关内容是运行时压缩器（Run-time Packer)、反调试、DLL 注入、API 钩取等多种中高级逆向主题的基础知识。</strong>希望各位多训练使用 Hex Editor、铅笔、纸张逐一计算 IAT/EAT 的地址，再找到文件/内存中的实际地址。虽然要掌握这些内容并不容易，但是由于其在代码逆向分析中占有重要地位，所以只有掌握它们，才能学到高级逆向技术。</p>
<h2 id="13-7-1-PEView-exe"><a href="#13-7-1-PEView-exe" class="headerlink" title="13.7.1 PEView.exe"></a>13.7.1 PEView.exe</h2><p>下面向各位介绍一个简单易用的 PE Viewer 应用程序（PEView.exe)（个人编写的免费公开 SW）。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581248457776-b99a17c7-bed1-472e-9878-5e84f89ea083.png#align=left&display=inline&height=506&name=QQ%E6%88%AA%E5%9B%BE20200209194046.png&originHeight=506&originWidth=993&size=31983&status=done&style=none&width=993" alt="QQ截图20200209194046.png"><br>图 13-28PEView<br>PEView 中，PE 头按不同结构体分类组织起来，非常方便查看，也能非常容易地在 RVA 与文件偏移间转换（与前面讲解的内容与术语略微不同。若二者都能熟练掌握，与他人沟通时会更加顺畅）。<br>强烈建议各位自己制作一个 PE Viewer。我刚开始学习 PE 头时（为了验证)就制作了一款基于控制台的 PE Viewer，使用至今。亲手制作 PE Viewer 可以学到更多知识，纠正理解上的错误，更有利于进步。</p>
<h2 id="13-7-2-Patched-PE"><a href="#13-7-2-Patched-PE" class="headerlink" title="13.7.2 Patched PE"></a>13.7.2 Patched PE</h2><p>顾名思义，PE 规范只是一个建议性质的书面标准，查看各结构体内部会发现，其实有许多成员并未被使用。事实上，只要文件符合 PE 规范就是 PE 文件，利用这一点可以制作出一些脱离常识的 PE 文件。<br>Patched PE 指的就是这样的 PE 文件，这些 PE 文件仍然符合 PE 规范，但附带的 PE 头非常具有创意（准确地说，PE 头纠缠放置到各处）。代码逆向分析中，Patched PE 涉及的内容宽泛而有深度，详细讲解须另立主题。<br>这里只介绍一点，但是足以颠覆前面对 PE 头的常规理解（但仍未违反 PE 规范）。<br>在下列网站制作一个名为“tiny pe”的最小 PE 文件。</p>
<blockquote>
<p>http:/blogs.securiteam.com/index.php/archives/675</p>
</blockquote>
<p>它是正常的 PE 文件，大小只有 411 个字节。其 IMAGE_NT_HEADERS 结构体大小只有 248 个字节，从这一点来看，的确非常小。其他人也不断加入挑战，现在已经出现了 304 个字节的 PE 文件。有人访问上面网站后受到了刺激，制作了一个非常极端、非常荒唐的 PE 文件，在下列网址中可以看到。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://www.phreedom.org/solar/code/tinype/">http://www.phreedom.org/solar/code/tinype/</a></p>
</blockquote>
<p>进入网站后可以下载一个 97 字节的 PE 文件，它可以在 WindowsXP 中正常运行。并且网站记录了 PE 头与 tiny pe 的制作过程，认真阅读这些内容会有很大帮助（需要具备一点汇编语言的知识）。希望各位全部下载并逐一分析，技术水平必有显著提高。</p>
<h1 id="13-8-小结"><a href="#13-8-小结" class="headerlink" title="13.8 小结"></a>13.8 小结</h1><p>这些 PatchedPE 文件能够帮助打破对 PE 文件的固有概念，对我、对普通的逆向分析人员都一样。正因如此，逆向分析技术学起来才更有意思。关于 PE 头需要再次强调的内容整理如下。</p>
<ul>
<li>PE 规范只是一种标准规范而已（有许多内容未使用）。</li>
<li>现在已知关于 PE 头的认识中有些是错误的（除 tiny pe 外，会出现更多操作 PE 头的创意技巧）。</li>
<li>经常检验掌握的知识，发现不懂的马上补充学习。</li>
</ul>
<p>后面还会有机会详细分析、学习 Patched PE 文件有关知识，到时再向各位一一介绍有关操作 PE 头更多有趣而奇特的技巧。</p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><p>Q.前面的讲解中提到，执行文件加载到内存时会根据 Imagebase 确定地址，那么 2 个 notepad 程序同时运行时 Imagebase 都是 10000000，它们会侵占彼此的空间区域，不是这样吗?<br>A.<strong>生成进程（加载到内存）时，OS 会单独为它分配 4GB 大小的虚拟内存。虚拟内存与实际物理内存是不同的。同时运行 2 个 notepad 时，各进程分别在自身独有的虚拟内存空间中，所以它们彼此不会重叠。这是由 OS 来保障的。因此，即使它们的 Imagebase 一样也完全没问题。</strong></p>
<p>Q.不怎么理解“填充”（padding)这一概念。<br>A.相信会有很多人想了解 PE 文件的“填充”这一概念，就当它是为了对齐“基本单位”而添加的“饶头”。“基本单位”这个概念在计算机和日常生活中都常见。<br>比如，保管大量的橘子时并不是单个保管，而是先把它们分别放入一个个箱子中，然后再放入仓库。这些箱子就是“基本单位”。并且，说橘子数量时也很少说几个橘子，而说几箱橘子，这样称呼会更方便。橘子箱数增加很多时，就要增加保管仓库的数量。此时不会再说几箱橘子，而是说“几仓库的橘子”。事实上，这样保管橘子便于检索，查找时只要说出“几号仓库的几号箱子的第几个橘子”即可。也就是说，保存大量数据时成“捆”<br>保管，整理与检索都会变得更容易。这种“基本单位”的概念也被融入计算机设计，还被应用到内存、硬盘等。各位一定听说过硬盘是用“扇区”这个单位划分的吧?<br>同样，“基本单位（大小）”的概念也应用到了 PE 文件格式的节区。即使编写的代码（编译为机器语言）大小仅有 100d 字节，若节区的基本单位为 1000d（400h)字节，那么代码节区最小也应该为 1000d。其中 100 个字节区域为代码，其余 900 个字节区域填充着 NULL(0)，后者称为 NULL 填充区域。内存中也使用“基本单位”的概念（其单位的大小比普通文件要略大一些）。那么 PE 文件中的填充是谁创建的呢?在开发工具（VC++/VB 等）中生成 PE 文件时由指定的编译选项确定。</p>
<p>Q.经常在数字旁边见到字母“h”，它是什么单位?<br>A.数字旁边的字母“h”是 Hex 的首字母，表示前面的数字为十六进制数。另外，十进制数用 d（Decimal）、八进制数用 o（Octal）、二进制数用 b（Binary）标识。</p>
<p>Q.如何只用 Hex Editor 识别出 DOS 存根、IMAGE_FILE_HEADER 等部分呢？<br>A.根据 PE 规范，IMAGEDOS_HEADER 的大小为 40 个字节，DOS 存根区域为 40~PE 签名区域。紧接在 PE 签名后的是 IMAGE_FILE_HEADER，且该结构体的大小是已知的，所以也可以在 Hex Editor 中表示出来。也就是说，解析 PE 规范中定义的结构体及其成员的含义，即可区分出各组成部分（多看几次就熟悉了）。</p>
<p>Q.IMAGE_FILE_HEADER 的 TimeDateStamp 值为 0x47918EA2，在 PEView 中显示为 2008/01/19,05:46：10UTC，如何才能这样解析出来呢？<br>A.使用 C 语言标准库中提供的 ctime()函数，即可把 4 个字节的数字转换为实际的日期字符串。</p>
<p>Q.PE 映像是什么？<br>A.PE 映像这一术语是微软创建 PE 结构时开始使用的。一般是指 PE 文件运行时加载到内存中的形态。PE 头信息中有一个 SizeOflmage 项，该项指出了 PE 映像所占内存的大小。当然，这个大小与文件的大小不一样。PE 文件格式妙处之一就在于，其文件形态与内存形态是不同的。</p>
<p>Q.不太明白 EP 这一概念。<br>A.<strong>EP 地址是程序中最早被执行的代码地址。CPU 会最先到 EP 地址处，并从该处开始依次执行指令。</strong></p>
<p>Q.用 PEView 打开记事本程序（notepad.exe)后，发现各节区的起始地址、大小等与示例中的不同，为什么会这样呢?<br>A.notepad.exe 文件随 OS 版本的不同而不同（其他所有系统文件也如此）。换言之，不同版本的 OS 下，系统文件的版本也是不同的。微软可能修改了代码、更改了编译选项，重新编译后再发布。</p>
<p>Q.对图 13-9 及其下面的 Quiz 不是很理解。如何知道 RVA5000 包含在哪个节区呢？<br>A.图 13-9 是以节区头信息为基础绘制的。图（或节区头信息）中的.text 节区是指 VA01001000<del>01009000 区域，转换为 RVA 形式后对应于 RVA1000-</del>9000 区域（即减去 Imagebase 值的 01000000)。由此可知，RVA5000 包含在.text 节区中。</p>
<p><strong>Q.讲解节区头成员 VirtualAddress 时提到，它是内存中节区头的起始地址（RVA），VirtualAddress 不就是 VA 吗?为什么要叫 RVA 呢?</strong><br><strong>A.“使用 RVA 值来表示节区头的成员 VirtualAddress”，这样理解就可以了。节区头结构体（IMAGE SECTION_HEADER)的 VirtualAddress 成员与虚拟内存地址（VA，VirtualAddress)用的术语相同才引起这一混乱。此处“VirtualAddress 成员指的是虚拟内存中相应节区的起始地址，它以 RVA 的形式保存”，如此理解即可。</strong><br>**Q.查看某个文件时，发现其 IMAGE_IMPORT_DESCRIPTOR 结构体的 OriginalFirstThunk 成员为 NULL，跟踪 FirstFThunk 成员，看到一个实际使用的 APl 的名称字符串数组（INT）。跟踪 FirstThunk 应该看到的是 IAT 而不是 INT，这是怎么回事呢？<br>A.PE 装载器无法根据 OriginalFirstThunk 查找到 API 名称字符串数组（INT）时，就会尝试用 FirstThunk 查找。本来 FirstThunk 含义为 IAT，但在实际内存中被实际的 API 函数地址覆盖掉了（此时 INT 与 IAT 虽然是相同区域，但仍然能够正常工作）。</p>
<p><strong>Q.使用 Windows7 的 notepad.exe 测试，用 PEView 打开后，IAT 起始地址为 01001000，而用 OllyDbg 查看时 IAT 出现在 00831000 地址处。请问这是怎么回事呢？</strong><br><strong>A.这是由 Windows Vista、7 中使用的 ASLR 技术造成的。请参考第 41 章。</strong></p>
<p>Q.EAT 讲解中提到的 Ordinal 究竟是什么？不太理解。<br>A.<strong>把 Ordinal 想成导出函数的固有编号就可以了。</strong>有时候某些函数对外不会公开函数名，仅公开函数的固有编号（Ordinal）。导入并使用这类函数时，要先用 Ordinal 查找到相应函数的地址后再调用。比如下面示例（1）通过函数名称来获取函数地址，示例（2）则使用函数的 Ordinal 来取得函数地址。<br>示例（1)pFunc=GetProcAddress(“TestFunc”)；<br>示例(2)pFunc=GetProcAddress(5)；</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Cyberangel</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cyberangel.cn/2020/02/09/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/">https://cyberangel.cn/2020/02/09/第13章 PE文件格式/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cyberangel.cn" target="_blank">Cyberangel-blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/02/10/%E7%AC%AC14%E7%AB%A0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第14章运行时压缩</div></div></a></div><div class="next-post pull-right"><a href="/2020/02/08/%E7%AC%AC12%E7%AB%A0%20%E7%A9%B6%E7%AB%9F%E5%BA%94%E5%BD%93%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第12章 究竟应当如何学习代码逆向分析（重要）</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#13-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">13.1 介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-2PE-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">13.2PE 文件格式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-1-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">13.2.1 基本结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-2-VA-amp-RVA"><span class="toc-number">2.2.</span> <span class="toc-text">13.2.2 VA&amp;RVA</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-3PE-%E5%A4%B4"><span class="toc-number">3.</span> <span class="toc-text">13.3PE 头</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-1-DOS-%E5%A4%B4"><span class="toc-number">3.1.</span> <span class="toc-text">13.3.1 DOS 头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-2-DOS-%E5%AD%98%E6%A0%B9"><span class="toc-number">3.2.</span> <span class="toc-text">13.3.2 DOS 存根</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-3-NT-%E5%A4%B4"><span class="toc-number">3.3.</span> <span class="toc-text">13.3.3 NT 头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-4-NT-%E5%A4%B4%EF%BC%9A%E6%96%87%E4%BB%B6%E5%A4%B4"><span class="toc-number">3.4.</span> <span class="toc-text">13.3.4 NT 头：文件头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-5-NT-%E5%A4%B4%EF%BC%9A%E5%8F%AF%E9%80%89%E5%A4%B4"><span class="toc-number">3.5.</span> <span class="toc-text">13.3.5 NT 头：可选头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-6-%E8%8A%82%E5%8C%BA%E5%A4%B4"><span class="toc-number">3.6.</span> <span class="toc-text">13.3.6 节区头</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-4-RVA-to-RAW"><span class="toc-number">4.</span> <span class="toc-text">13.4 RVA to RAW</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-5-IAT"><span class="toc-number">5.</span> <span class="toc-text">13.5 IAT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-5-1-DLL"><span class="toc-number">5.1.</span> <span class="toc-text">13.5.1 DLL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-5-2-IMAGE-IMPORT-DESCRIPTOR"><span class="toc-number">5.2.</span> <span class="toc-text">13.5.2 IMAGE_IMPORT_DESCRIPTOR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-5-3-%E4%BD%BF%E7%94%A8-notepad-exe-%E7%BB%83%E4%B9%A0"><span class="toc-number">5.3.</span> <span class="toc-text">13.5.3 使用 notepad.exe 练习</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-6-EAT"><span class="toc-number">6.</span> <span class="toc-text">13.6 EAT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-6-1-IMAGE-EXPORT-DIRECTORY"><span class="toc-number">6.1.</span> <span class="toc-text">13.6.1 IMAGE_EXPORT_DIRECTORY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-6-2-%E4%BD%BF%E7%94%A8-kernel32-dll-%E7%BB%83%E4%B9%A0"><span class="toc-number">6.2.</span> <span class="toc-text">13.6.2 使用 kernel32.dll 练习</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-7-%E9%AB%98%E7%BA%A7-PE"><span class="toc-number">7.</span> <span class="toc-text">13.7 高级 PE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-7-1-PEView-exe"><span class="toc-number">7.1.</span> <span class="toc-text">13.7.1 PEView.exe</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-7-2-Patched-PE"><span class="toc-number">7.2.</span> <span class="toc-text">13.7.2 Patched PE</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-8-%E5%B0%8F%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text">13.8 小结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Q-amp-A"><span class="toc-number">9.</span> <span class="toc-text">Q&amp;A</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Cyberangel</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">为世界上所有美好而战！！！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://cyberangel.cn/2020/02/09/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/'
    this.page.identifier = '2020/02/09/第13章 PE文件格式/'
    this.page.title = '第13章 PE文件格式'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Disqus' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script><script>if (window.DISQUSWIDGETS === undefined) {
  var d = document, s = d.createElement('script');
  s.src = 'https://.disqus.com/count.js';
  s.id = 'dsq-count-scr';
  (d.head || d.body).appendChild(s);
} else {
  DISQUSWIDGETS.getCount({reset: true});
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>