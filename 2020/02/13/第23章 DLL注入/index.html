<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>第23章 DLL注入 | Cyberangel-blog</title><meta name="author" content="Cyberangel"><meta name="copyright" content="Cyberangel"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="DLL 注入（DLL Injection)是渗透其他进程的最简单有效的方法，本章将详细讲解 DLL 注入的有关内容。借助 DLL 注入技术，可以钩取 API、改进程序、修复 Bug 等。 23.1 DLL 注入DLL 注入指的是向运行中的其他进程强制插入特定的 DLL 文件。从技术细节来说，DLL 注入命令其他进程自行调用 LoadLibrary）API，加载（Loading)用户指定的 DLL">
<meta property="og:type" content="article">
<meta property="og:title" content="第23章 DLL注入">
<meta property="og:url" content="https://cyberangel.cn/2020/02/13/%E7%AC%AC23%E7%AB%A0%20DLL%E6%B3%A8%E5%85%A5/index.html">
<meta property="og:site_name" content="Cyberangel-blog">
<meta property="og:description" content="DLL 注入（DLL Injection)是渗透其他进程的最简单有效的方法，本章将详细讲解 DLL 注入的有关内容。借助 DLL 注入技术，可以钩取 API、改进程序、修复 Bug 等。 23.1 DLL 注入DLL 注入指的是向运行中的其他进程强制插入特定的 DLL 文件。从技术细节来说，DLL 注入命令其他进程自行调用 LoadLibrary）API，加载（Loading)用户指定的 DLL">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-02-13T07:32:43.000Z">
<meta property="article:modified_time" content="2021-07-04T09:57:21.897Z">
<meta property="article:author" content="Cyberangel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cyberangel.cn/2020/02/13/%E7%AC%AC23%E7%AB%A0%20DLL%E6%B3%A8%E5%85%A5/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第23章 DLL注入',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-04 17:57:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Cyberangel-blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">317</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Cyberangel-blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第23章 DLL注入</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-02-13T07:32:43.000Z" title="发表于 2020-02-13 15:32:43">2020-02-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-04T09:57:21.897Z" title="更新于 2021-07-04 17:57:21">2021-07-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第23章 DLL注入"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><span class="disqus-comment-count"><a href="https://cyberangel.cn/2020/02/13/%E7%AC%AC23%E7%AB%A0%20DLL%E6%B3%A8%E5%85%A5/#disqus_thread"></a></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>DLL 注入（DLL Injection)是渗透其他进程的最简单有效的方法，本章将详细讲解 DLL 注入的有关内容。借助 DLL 注入技术，可以钩取 API、改进程序、修复 Bug 等。</p>
<h1 id="23-1-DLL-注入"><a href="#23-1-DLL-注入" class="headerlink" title="23.1 DLL 注入"></a>23.1 DLL 注入</h1><p><strong>DLL 注入指的是向运行中的其他进程强制插入特定的 DLL 文件。</strong>从技术细节来说，DLL 注入命令其他进程自行调用 LoadLibrary）API，加载（Loading)用户指定的 DLL 文件。<strong>DLL 注入与一般 DLL 加载的区别在于，加载的目标进程是其自身或其他进程。</strong>图 23-1 描述了 DLL 注入的概念。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581579324684-59444e9f-3d6b-4c7c-bd62-256dc01e891c.png#align=left&display=inline&height=534&name=QQ%E6%88%AA%E5%9B%BE20200213153517.png&originHeight=534&originWidth=519&size=110383&status=done&style=none&width=519" alt="QQ截图20200213153517.png"><br>从图 23-1 中可以看到，myhack.dll 已被强制插入 notepad 进程（本来 notepad 并不会加载 myhack.dll）。加载到 notepad.exe 进程中的 myhack.dll 与已经加载到 notepad.exe 进程中的 DLL（kernel32.dll、user32.dll)一样，拥有访问 notepad.exe 进程内存的（正当的）权限，这样用户就可以做任何想做的事了（比如：向 notepad 添加通信功能以实现 Messenger、文本网络浏览器等）。<br>DLL（Dynamic Linked Library,动态链接库）————————————————————————-<br><strong>DLL 被加载到进程后会自动运行 DlIMain()函数，用户可以把想执行的代码放到 DllMain()函数，每当加载 DLL 时，添加的代码就会自然而然得到执行。利用该特性可修复程序 Bug，或向程序添加新功能。</strong></p>
<hr>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582077500929-cbf70b5e-d6c7-4393-9324-0371f96eab8e.png#align=left&display=inline&height=524&name=QQ%E6%88%AA%E5%9B%BE20200219095812.png&originHeight=524&originWidth=1044&size=398864&status=done&style=none&width=1044" alt="QQ截图20200219095812.png"></p>
<h1 id="23-2-DLL-注入示例"><a href="#23-2-DLL-注入示例" class="headerlink" title="23.2 DLL 注入示例"></a>23.2 DLL 注入示例</h1><p>使用 LoadLibrary()API 加载某个 DLL 时，该 DLL 中的 DlIMain()函数就会被调用执行。DLL 注入的工作原理就是从外部促使目标进程调用 LoadLibrary()API（与一般 DLL 加载相同），所以会强制调用执行 DLL 的 DllMain()函数。并且，被注入的 DLL 拥有目标进程内存的访问权限，用户可以随意操作（修复 Bug、添加功能等）。下面看一些使用 DLL 注入技术的示例。</p>
<h2 id="23-2-1-改善功能与修复-Bug"><a href="#23-2-1-改善功能与修复-Bug" class="headerlink" title="23.2.1 改善功能与修复 Bug"></a>23.2.1 改善功能与修复 Bug</h2><p>DLL 注入技术可用于改善功能与修复 Bug。没有程序对应的源码，或直接修改程序比较困难时，就可以使用 DLL 注入技术为程序添加新功能（类似于插件），或者修改有问题的代码、数据。</p>
<h2 id="23-2-2-消息钩取"><a href="#23-2-2-消息钩取" class="headerlink" title="23.2.2 消息钩取"></a>23.2.2 消息钩取</h2><p><strong>Windows OS 默认提供的消息钩取功能应用的就是一种 DLL 注入技术。与常规的 DLL 注入唯一的区别是，OS 会直接将已注册的钩取 DLL 注入目标进程。</strong><br>提示——————————————————————————————————————<br>我曾经从网上下载过一个 HexEditor，它不支持鼠标滚轮滑动，所以我用消息钩取技术为其添加了鼠标滚轮支持。虽然可以下载更多、更好用的 Hex Editor，但是利用学到的技术改善、扩展程序功能是一种非常妙的体验。这样不仅能解决问题，还锻炼了我们灵活应用技术的能力（此后我就开始对使用逆向技术改善已有程序的功能产生了浓厚兴趣）。</p>
<hr>
<h2 id="23-2-3API-钩取"><a href="#23-2-3API-钩取" class="headerlink" title="23.2.3API 钩取"></a>23.2.3API 钩取</h2><p>API 钩取广泛应用于实际的项目开发，而进行 API 钩取时经常使用 DLL 注入技术。先创建好 DLL 形态的钩取函数，再将其轻松注入要钩取的目标进程，这样就完成了 API 钩取。这灵活运用了“<strong>被注入的 DLL 拥有目标进程内存访问权限</strong>”这一特性。</p>
<h2 id="23-2-4-其他应用程序"><a href="#23-2-4-其他应用程序" class="headerlink" title="23.2.4 其他应用程序"></a>23.2.4 其他应用程序</h2><p>DLL 注入技术也应用于监视、管理 PC 用户的应用程序。比如，用来阻止特定程序（像游戏、股票交易等）运行、禁止访问有害网站，以及监视 PC 的使用等。管理员（或者父母）主要安装这类拦截/阻断应用程序来管理/监视。受管理/监视的一方当然千方百计地想关闭这些监视程序，但由于这些监视程序采用 DLL 注入技术，它们可以隐藏在正常进程中运行，所以管理员一般不用担心被发现或被终止（若用户强制终止 Windows 系统进程，也会一并关闭系统，最后也算达成了拦截/阻断这一目标）。</p>
<h2 id="23-2-5-恶意代码"><a href="#23-2-5-恶意代码" class="headerlink" title="23.2.5 恶意代码"></a>23.2.5 恶意代码</h2><p>恶意代码制作者们是不会置这么好的技术于不顾的，他们积极地把 DLL 注入技术运用到自己制作的恶意代码中。这些人把自己编写的恶意代码隐藏到正常进程（winlogon.exe、services.exe、svchost.exe、explorer.exe 等），打开后门端口（Backdoor port)，尝试从外部连接，或通过键盘偷录（Keylogging)功能将用户的个人信息盗走。只有了解恶意代码制作者们使用的手法，才能拿出相应的对策。<br>23.3DLL 注入的实现方法<br>向某个进程注入 DLL 时主要使用以下三种方法：<br>   DLL 注入方法</p>
<ul>
<li>创建远程线程（CreateRemote Thread()API)</li>
<li>使用注册表（AppInit_DLLs 值）</li>
<li>消息钩取（SetWindowsHookEx()API）</li>
</ul>
<h1 id="23-4-CreateRemote-Thread"><a href="#23-4-CreateRemote-Thread" class="headerlink" title="23.4 CreateRemote Thread()"></a>23.4 CreateRemote Thread()</h1><p>本方法是《Windows 核心编程》一书（素有“Windows 编程圣经”之称）中介绍过的。本节通过一个简单的示例来演示如何通过创建远程线程完成 DLL 注入。</p>
<h2 id="23-4-1-练习示例-myhack-dll"><a href="#23-4-1-练习示例-myhack-dll" class="headerlink" title="23.4.1 练习示例 myhack.dll"></a>23.4.1 练习示例 myhack.dll</h2><p>本示例将把 myhack.dll 注入 notepad.exe 进程，被注入的 myhack.dll 是用来联网并下载<a target="_blank" rel="noopener" href="http://www.naver.com/index.html%E6%96%87%E4%BB%B6%E7%9A%84%E3%80%82">http://www.naver.com/index.html文件的。</a><br>    复制练习文件首先将练习文件（InjectDll.exe、myhack.dll)分别复制到工作文件夹（C:\Work)，如图 23-2 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582078213598-db70a134-b738-4897-8e89-29da135a99ac.png#align=left&display=inline&height=816&name=QQ%E6%88%AA%E5%9B%BE20200219101000.png&originHeight=816&originWidth=1106&size=57523&status=done&style=none&width=1106" alt="QQ截图20200219101000.png"><br>图 23-2 复制练习文件<br><strong>运行 notepad.exe 程序</strong><br>先运行 notepad.exe（日记本）程序，再运行 Process Explorer（或者 Windows 任务管理器）获取 notepad.exe 进程的 PID。<br>可以看到图 23-3 中 notepad.exe 进程的 PID 值为 9080。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582078365695-8150adaa-46c0-4c93-9ff0-e7a7d6697d68.png#align=left&display=inline&height=79&name=QQ%E6%88%AA%E5%9B%BE20200219101235.png&originHeight=79&originWidth=917&size=7477&status=done&style=none&width=917" alt="QQ截图20200219101235.png"><br>图 23-3 Process Explorer<br><strong>运行 DebugView</strong><br>DebugView 是一个非常有用的实用程序，它可以用来捕获并显示系统中运行的进程<strong>输出的所有调试字符串</strong>，由大名鼎鼎的 Process Explorer 制作人 Mark Russinovich 开发而成。请访问下面 URL 下载。<br><a target="_blank" rel="noopener" href="http://technet.microsoft.com/en-us/sysinternals/bb896647">http://technet.microsoft.com/en-us/sysinternals/bb896647</a><br>示例中的 DLL 文件被成功注入 notepad.exe 进程时，就会输出调试字符串，此时使用 DebugView 即可查看，如图 23-4 所示。<br>提示——————————————————————————————————————<br>应当养成在应用程序开发中灵活使用 DebugView 查看调试日志的好习惯。</p>
<hr>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582078669190-fa9ddb67-5bf9-49ef-8d3f-1763afcf40f2.png#align=left&display=inline&height=366&name=QQ%E6%88%AA%E5%9B%BE20200219101726.png&originHeight=366&originWidth=607&size=21523&status=done&style=none&width=607" alt="QQ截图20200219101726.png"><br>图 23-4 DebugView<br><strong>myhack.dll 注入</strong><br>InjectDll.exe 是用来向目标进程注入 DLL 文件的实用小程序（后面会详细讲解工作原理及源代码）。如图 23-5 所示，打开命令窗口并输入相应参数即可运行 InjectDll.exe。<br><strong>（要以管理员权限运行）</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582079264504-15f5e81b-eb0f-4e97-a514-a2d2f3b362d0.png#align=left&display=inline&height=220&name=QQ%E6%88%AA%E5%9B%BE20200219102237.png&originHeight=220&originWidth=816&size=25941&status=done&style=none&width=816" alt="QQ截图20200219102237.png"><br>图 23-5 运行 InjectDll.exe<br><strong>确认 DLL 注入成功</strong><br>下面要检查 myhack.dll 文件是否成功注入 notepad.exe 进程。首先查看 DebugView 日志，如图 23-6 所示。<br>（此处我的 DebugView 没有日志，注入失败…）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582079520932-436f0ae4-027b-4d50-86af-1fed7c43e63d.png#align=left&display=inline&height=341&name=QQ%E6%88%AA%E5%9B%BE20200219103153.png&originHeight=341&originWidth=502&size=70681&status=done&style=none&width=502" alt="QQ截图20200219103153.png"><br>DebugView 中显示出调试字符串，该字符串是由 PID：1016 进程输出的。PID：1016 进程就是注入 myhack.dll 的 notepad.exe 进程。成功注入 myhack.dll 时，就会调用执行 DllMain()函数的 OutputDebugString()API。<br>在 Process Explorer 中也可以看到 myhack.dll 已经成功注入 notepad.exe 进程。在 Process Explorer 的 View 菜单中，选择 Show Lower Pane 与 Lower Pane Views-DLLs 项，然后选择 notepad.exe 进程，就会列出所有加载到 notepad.exe 进程中的 dll，如图 23-7 所示。在图中可以看到已经成功注入 notepad.exe 的 myhack.dll 文件。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582079757105-3823d23a-800b-495f-a33f-a0447bb3cb19.png#align=left&display=inline&height=665&name=QQ%E6%88%AA%E5%9B%BE20200219103550.png&originHeight=665&originWidth=567&size=325176&status=done&style=none&width=567" alt="QQ截图20200219103550.png"><br><strong>结果确认</strong><br>下面确认一下指定网站的 index.html 文件下载是否正常。<br>双击图 23-8 中的 Index.html 文件，在 IE 浏览器中查看页面。<br>图 23-9 看上去虽然与实际网站的主页面有些不同，但可以肯定它就是该网站的 index.html 文件。<img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582079886831-6950e91e-3300-4784-8a1e-6b61fa644e09.png#align=left&display=inline&height=516&name=QQ%E6%88%AA%E5%9B%BE20200219103742.png&originHeight=516&originWidth=570&size=154259&status=done&style=none&width=570" alt="QQ截图20200219103742.png"><br>图 23-9 看上去虽然与实际网站的主页面有些不同，但可以肯定它就是该网站的 index.html 文件。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582079968309-9357dc5b-3aed-4eae-b83e-cdbc8ff2fe0d.png#align=left&display=inline&height=486&name=QQ%E6%88%AA%E5%9B%BE20200219103921.png&originHeight=486&originWidth=776&size=189752&status=done&style=none&width=776" alt="QQ截图20200219103921.png"><br>提示——————————————————————————————————————<br>有时会因系统用户权限、安全设置等导致无法下载 index.html 文件</p>
<hr>
<p>就像在上述示例中看到的一样，借助创建远程线程的方法可以成功“渗透”指定进程，进而可以随意操作。下面继续分析示例源代码，进一步学习使用 CreateRemote Thread()API 实施 DLL 注入的原理与实现方法。</p>
<h2 id="23-4-2-分析示例源代码"><a href="#23-4-2-分析示例源代码" class="headerlink" title="23.4.2 分析示例源代码"></a>23.4.2 分析示例源代码</h2><p>提示——————————————————————————————————————<br>以下介绍的源代码是用 Micosoft Visual C++Express2010 编写的，在 Windows XP/7 32 位操作系统中通过测试。</p>
<hr>
<p><strong>Myhack.cpp</strong><br>先分析一下 myhack.dl 源代码（myhack.cpp)。<br><strong>#include “windows.h”</strong><br><strong>#include “tchar.h”</strong></p>
<p><strong>#pragma comment(lib, “urlmon.lib”)</strong></p>
<p><strong>#define DEF_URL         (L”<a target="_blank" rel="noopener" href="http://www.naver.com/index.html&quot;">http://www.naver.com/index.html&quot;</a>)</strong><br><strong>#define DEF_FILE_NAME   (L”index.html”)</strong></p>
<p><strong>HMODULE g_hMod = NULL;</strong></p>
<p><strong>DWORD WINAPI ThreadProc(LPVOID lParam)</strong><br><strong>{</strong><br>**    TCHAR szPath[_MAX_PATH] = {0,};**</p>
<p>**    if( !GetModuleFileName( g_hMod, szPath, MAX_PATH ) )**<br>**        return FALSE;** **    **<br>**    TCHAR <em>p = _tcsrchr( szPath, ‘\‘ );**<br>**    if( !p )</em>*<br>**        return FALSE;**</p>
<p>**    _tcscpy_s(p+1, _MAX_PATH, DEF_FILE_NAME);**</p>
<p>**    URLDownloadToFile(NULL, DEF_URL, szPath, 0, NULL);**</p>
<p>**    return 0;**<br><strong>}</strong></p>
<p><strong>BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</strong><br><strong>{</strong><br>**    HANDLE hThread = NULL;**</p>
<p>**    g_hMod = (HMODULE)hinstDLL;**</p>
<p>**    switch( fdwReason )**<br>**    {**<br>**    case DLL_PROCESS_ATTACH : **<br>**        OutputDebugString(L”&lt;myhack.dll&gt; Injection!!!”);**<br>**        hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);**<br>**        CloseHandle(hThread);**<br>**        break;**<br>**    }**</p>
<p>**    return TRUE;**<br><strong>}<br>**    在 DllMain()函数中可以看到，该 DLL 被加载（DLL_PROCESS_ATTACH)时，先输出一个调试字符串（“myhack.dll Injection!!！”），然后创建线程调用函数（ThreadProc）。在 ThreadProc()函数中通过调用 urlmon!URLDownloadToFile()API 来下载指定网站的 index.html 文件。</strong>前面提到过，向进程注入 DLL 后就会调用执行该 DLL 的 DlIMain()函数。所以当 myhack.dll 注入 notepad.exe 进程后，最终会调用执行 URLDownloadToFile()API。**<br><strong>InjectDll.cpp</strong><br>InjectDll.exe 程序用来将 myhack.dll 注入 notepad.exe 进程，下面看一下其源代码。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582080496224-758f4e0a-4852-4d6e-821c-42c1b2f76e2a.png#align=left&display=inline&height=380&name=QQ%E6%88%AA%E5%9B%BE20200219104703.png&originHeight=380&originWidth=1046&size=279737&status=done&style=none&width=1046" alt="QQ截图20200219104703.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582080498682-25012421-6609-4c10-8f87-bedf912296d4.png#align=left&display=inline&height=762&name=QQ%E6%88%AA%E5%9B%BE20200219104722.png&originHeight=762&originWidth=1041&size=578410&status=done&style=none&width=1041" alt="QQ截图20200219104722.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582080501013-4e8b7ec4-919a-43e1-bc46-745e11d39b7d.png#align=left&display=inline&height=492&name=QQ%E6%88%AA%E5%9B%BE20200219104754.png&originHeight=492&originWidth=1048&size=338237&status=done&style=none&width=1048" alt="QQ截图20200219104754.png"><br>main()函数的主要功能是检查输入程序的参数，然后调用 InjectDll()函数。InjectDll()函数是用来实施 DLL 注入的核心函数，其功能是命令目标进程（notepad.exe）自行调用 LoadLibrary（“myhack.dll”)API。下面逐行详细查看 InjectDll()函数。<br><strong>获取目标进程句柄</strong><br>hProcess=OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwPID))<br>调用 OpenProcess()API，借助程序运行时以参数形式传递过来的 dwPID 值，获取 notepad.exe 进程的句柄（PROCESS_ALL_ACCESS 权限）。得到 PROCESS_ALL_ACCESS 权限后，就可以使用获取的句柄（hProcess)控制对应进程（notepad.exe）。<br><strong>将要注入的 DLL 路径写入目标进程内存   **     <br>pRemoteBuf=VirtualAllocEx(hProcess,NULL,dwBufSize,MEM_COMMIT,PAGE_READWRITE);<br>需要把即将加载的 DLL 文件的路径（字符串）告知目标进程（notepad.exe)。</strong>因为任何内存空间都无法进行写入操作，故先使用 VirtualAllocEx()API 在目标进程（notepad.exe)的内存空间中分配一块缓冲区，且指定该缓冲区的大小为 DLL 文件路径字符串的长度（含 Terminating NULL）即可。**<br><strong>提示—————————————————————————————————————–</strong><br><strong>VirtualAllocEx()函数的返回值（pRemoteBuf）为分配所得缓冲区的地址。该地址并不是程序（Inject.exe）自身进程的内存地址，而是 hProcess 句柄所指目标进程（notepad.exe)的内存地址，请务必牢记这一点。</strong><br><strong>———————————————————————————————————————-</strong><br>WriteProcessMemory(hProcess,pRemoteBuf,(LPVOID)szDlLName,dwBufSize,NULL);<br>使用 WriteProcessMemory()API 将 DLL 路径字符串（“C：\work\myhack.dll”）写入分配所得缓冲区（pRemoteBuf)地址。WriteProcessMemory()API 所写的内存空间也是 hProcess 句柄所指的目标进程（notepad.exe）的内存空间。这样，要注入的 DLL 文件的路径就被写入目标进程（notepad.exe）的内存空间。<br>调试 API—————————————————————————————————————<br><strong>Windows 操作系统提供了调试 API，借助它们可以访问其他进程的内存空间。</strong>其中具有代表性的有 VirtualAllocEx()、VirtualFreeEx()、WriteProcessMemory()、ReadProcessMemory()等。</p>
<hr>
<p>获取 LoadLibraryW()API 地址<br>hMod=GetModuleHandle(“kernel32.dll”);<br>pThreadProc=(LPTHREAD_START_ROUTINE)GetProcAddress(hMod,”LoadLibraryw”);<br>调用 LoadLibrary()API 前先要获取其地址<strong>（LoadLibraryW()是 LoadLibrary()的 Unicode 字符串版本）。</strong><br>最重要的是理解好以上代码的含义。我们的目标明明是获取加载到 notepad.exe 进程的 kernel32.dll 的 LoadLibraryW()API 的起始地址，但上面的代码却用来获取加载到 InjectDll.exe 进程的 kernel32.dll 的 LoadLibraryW()API 的起始地址。如果加载到 notepad.exe 进程中的 kernel32.dll 的地址与加载到 InjectDll.exe 进程中的 kernel32.dll 的地址相同，那么上面的代码就不会有什么问题。但是如果 kernel32.dll 在每个进程中加载的地址都不同，那么上面的代码就错了，执行时会发生内存引用错误。</p>
<blockquote>
<p><strong>其实在 Windows 系统中，kernel32.dll 在每个进程中的加载地址都是相同的。</strong></p>
</blockquote>
<p>《Windows 核心编程》一书中对此进行了介绍，此后这一特性被广泛应用于 DLL 注入技术。<br>提示——————————————————————————————————————<br><strong>根据 OS 类型、语言、版本不同，kernel32.dll 加载的地址也不同。并且 Vista/7 中应用了新的 ASLR 功能，每次启动时，系统 DLL 加载的地址都会改变。但是在系统运行期间它都会被映射（Mapping）到每个进程的相同地址。Windows 操作系统中，DLL 首次进入内存称为“加载”（Loading），以后其他进程需要使用相同 DLL 时不必再次加载，只要将加载过的 DLL 代码与资源映射一下即可，这种映射技术有利于提高内存的使用效率。</strong></p>
<hr>
<p>像上面这样，OS 核心 DLL 会被加载到自身固有的地址，DLL 注入利用的就是 Windows OS 的这一特性（该特性也可能会被恶意使用，成为 Windows 安全漏洞）。所以，导入 InjectDll.exe 进程中的 LoadLibraryW()地址与导入 notepad.exe 进程中的 LoadLibraryW()地址是相同的。<br>提示——————————————————————————————————————<br>一般而言，DLL 文件的 ImageBase 默认为 0x10000000，依次加载 a.dll 与 b.dll 时，先加载的 a.dll 被正常加载到 0x10000000 地址处，后加载的 b.dll 无法再被加载到此，而是加载到其他空白地址空间，也就是说，该过程中发生了 DLL 重定位（因为 a.dll 已经先被加载到它默认的地址处）。<br>    若 kernel32.dll 加载到各个进程时地址各不相同，那么上述代码肯定是错误的。但实际在 Windows 操作系统中，<strong>kernel32.dll 不管在哪个进程都会被加载至相同地址。</strong>为什么会这样呢?我借助 PEView 软件查看了 Windows 操作系统的核心 DLL 文件的 ImageBase 值，罗列如下表（WindowsXPSP3 版本，根据 Windows 更新不同，各值会有变化）。</p>
<hr>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582081490989-e267ae31-169d-497e-9361-13ce84f558e8.png#align=left&display=inline&height=301&name=QQ%E6%88%AA%E5%9B%BE20200219110439.png&originHeight=301&originWidth=866&size=87831&status=done&style=none&width=866" alt="QQ截图20200219110439.png"><br>微软整理了一份 OS 核心 DLL 文件的 ImageBase 值，防止各 DLL 文件加载时出现区域重合，这样加载 DLL 就不会发生 DLL 重定位了。</p>
<hr>
<p>**在目标进程中运行远程线程（Remote Thread）  **<br>hThread=CreateRemoteThread(hProcess,NULL,0,pThreadProc,pRemoteBuf,0,NULL);<br>pThreadProc=notepad.exe 进程内存中的 LoadLibraryw()地址<br>pRemoteBuf=notepad.exe 进程内存中的“c:\work\myhack.dll”字符串地址<br>一切准备就绪后，最后向 notepad.exe 发送一个命令，让其调用 LoadLibraryW()API 函数加载指定的 DLL 文件即可，遗憾的是 Windows 并未直接提供执行这一命令的 API。但是我们可以另辟蹊径，使用 CreateRemote Thread()这个 API（在 DLL 注入时几乎总会用到）。CreateRemote Thread()API 用来在目标进程中执行其创建出的线程，其函数原型如下：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582081691137-e9594e98-3934-4ac6-9c5d-b74b9fa60b25.png#align=left&display=inline&height=249&name=QQ%E6%88%AA%E5%9B%BE20200219110802.png&originHeight=249&originWidth=1055&size=162181&status=done&style=none&width=1055" alt="QQ截图20200219110802.png"><br>除第一个参数 hProcess 外，其他参数与 CreateThread()函数完全一样。hProcess 参数是要执行线程的目标进程（或称“远程进程”、“宿主进程”）的句柄。lpStartAddress 与 IpParameter 参数分别给出线程函数地址与线程参数地址。需要注意的是，这 2 个地址都应该在目标进程虚拟内存空间中（这样目标进程才能认识它们）。<br>初次接触 DLL 注入技术的读者朋友可能会头昏脑涨、不知所云。本来想向其他进程注入 DLL 文件，这里为何突然出现线程运行函数呢？仔细观察线程函数 ThreadProc()与 LoadLibrary()API，可以从中得到一些启示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582081866890-bb0bd772-ac40-4ec4-99db-e3245933b114.png#align=left&display=inline&height=228&name=QQ%E6%88%AA%E5%9B%BE20200219111016.png&originHeight=228&originWidth=1057&size=123271&status=done&style=none&width=1057" alt="QQ截图20200219111016.png"><br>两函数都有一个 4 字节的参数，并返回一个 4 字节的值。也就是说，二者形态结构完全一样，灵感即源于此。调用 CreateRemoteThread()时，只要将 LoadLibrary()函数的地址传递给第四个参数 lpStartAddress,把要注入的 DLL 的路径字符串地址传递给第五个参数 lpParameter 即可（必须是目标进程的虚拟内存空间中的地址）。由于前面已经做好了一切准备，现在调用该函数使目标进程加载指定的 DLL 文件就行了。<br>其实，CreateRemote Thread()函数最主要的功能就是驱使目标进程调用 LoadLibrary()函数，进而加载指定的 DLL 文件。</p>
<h2 id="23-4-3-调试方法"><a href="#23-4-3-调试方法" class="headerlink" title="23.4.3 调试方法"></a>23.4.3 调试方法</h2><p>本节将介绍如何从 DLL 文件注入目标进程就开始调试。首先重新运行 notepad.exe，然后使用 OllyDbg2 的 Attach（文件-&gt;附加）命令附加新生成的 notepad.exe 进程（我的没有！！！）（使用最新版本的 OllyDbg2 进行 DLL 注入调试更方便）。<br>如图 23-10 所示，使用调试器中的 Attach 命令附加运行中的进程后，进程就会暂停运行。按 F9 让 notepad.exe 运行起来。然后如图 23-11 所示，在 Option 对话框的 Events 中复选“Pause on newmodule(DLL)”一项。这样一来，每当有新的 DLL 被加载到 notepad.exe 进程，都会在该 DLL 的 EP 处暂停。同样，进行 DLL 注入时也会在该 DLL 的 EP 处暂停。使用 InjectDll.exe 将 myhack.dll 文件注入 notepad.exe 进程，此时调试器将暂停，如图 23-12 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582082366499-b52f80f9-728f-499c-9640-b1cc2b8d47fe.png#align=left&display=inline&height=391&name=QQ%E6%88%AA%E5%9B%BE20200219111851.png&originHeight=391&originWidth=749&size=235227&status=done&style=none&width=749" alt="QQ截图20200219111851.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582082367991-a1943ea7-3ef5-4d7c-a329-07031e3a0d3f.png#align=left&display=inline&height=528&name=QQ%E6%88%AA%E5%9B%BE20200219111903.png&originHeight=528&originWidth=599&size=201701&status=done&style=none&width=599" alt="QQ截图20200219111903.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582082369325-3c5fccac-1327-4df0-ba1e-291bb0d97351.png#align=left&display=inline&height=498&name=QQ%E6%88%AA%E5%9B%BE20200219111913.png&originHeight=498&originWidth=746&size=240730&status=done&style=none&width=746" alt="QQ截图20200219111913.png"></p>
<p>调试器暂停的地方并不是 myhack.dll 的 EP，而是一个名为 MSASN1.dll 模块的 EP。加载 myhack.dll 前，需要先加载它导入的所有 DLL 文件，MSASN1.dl 文件即在该过程中被加载。OllyDbg2 的 Pause on new module(DLL)被选中时，每当加载新的 dll 文件，都暂停在相应 DLL 文件的 EP 处。不断按（F9）运行键，直到在 myhack.dll 的 EP 处暂停。<br>图 23-13 显示的即是 myhack.dll 模块的 EP 入口处，接下来从该入口处调试就可以了（调试前，请先取消对 Pause on new module(DLL)项的复选，恢复之前“未选中”状态）。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582082478289-d0e8853a-c325-45d3-9ba4-e6eba623114a.png#align=left&display=inline&height=450&name=QQ%E6%88%AA%E5%9B%BE20200219112109.png&originHeight=450&originWidth=672&size=221739&status=done&style=none&width=672" alt="QQ截图20200219112109.png"><br>提示——————————————————————————————————————        根据用户的系统环境，加载的 DLL 类型与个数可能有所不同。</p>
<hr>
<p>至此，对于使用 CreateRemoteThread()函数进行 DLL 注入技术的讲解就完成了。初学时可能不怎么理解，反复认真阅读前面的讲解，实际动手操作，就较容易掌握。<br>提示—————————————————————————————————————— <br>使用 CreateRemoteThread(）函数注入相应 DLL 后，如何再次卸载注入的 DLL，这部分内容请参考第 24 章。</p>
<hr>
<h1 id="23-5AppInit-DLLs"><a href="#23-5AppInit-DLLs" class="headerlink" title="23.5AppInit_DLLs"></a>23.5AppInit_DLLs</h1><p>进行 DLL 注入的第二种方法是使用注册表。Windows 操作系统的注册表中默认提供了 AppInt_DLLs 与 LoadAppInit_DLLs 两个注册表项，如图 23-14 所示。<br>在注册表编辑器中，将要注入的 DLL 的路径字符串写入 AppInit DLLs 项目，然后把 LoadApplait_DLLs 的项目值设置为 1。重启后，指定 DLL 会注入所有运行进程。该方法操作非常简单，但功能相当强大。<br>提示—————————————————————————————————————— <br>上述方法的工作原理是，User32.dll 被加载到进程时，会读取 AppInit_DLLs 注册表项，若有值，则调用 LoadLibrary()API 加载用户 DLL。所以，严格地说，相应 DLL 并不会被加载到所有进程，而只是加载至加载 user32.dll 的进程。请注意，Windows XP 会忽略 LoadAppInit_DLLs 注册表项。</p>
<hr>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582082813081-003bfffa-daa0-4097-9c16-2645ccf35b51.png#align=left&display=inline&height=446&name=QQ%E6%88%AA%E5%9B%BE20200219112639.png&originHeight=446&originWidth=855&size=200483&status=done&style=none&width=855" alt="QQ截图20200219112639.png">图 23-14 注册表编辑器（regedit.exe)</p>
<h2 id="23-5-1-分析示例源码-myhack2-cpp"><a href="#23-5-1-分析示例源码-myhack2-cpp" class="headerlink" title="23.5.1 分析示例源码 myhack2.cpp"></a>23.5.1 分析示例源码 myhack2.cpp</h2><p>下面分析一下 myhack2.dll 的源代码（myhack2.cpp)，如代码 25-3 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582082931743-8889dd7c-1b08-4969-b2bd-234b728c5e86.png#align=left&display=inline&height=816&name=QQ%E6%88%AA%E5%9B%BE20200219112820.png&originHeight=816&originWidth=1041&size=633225&status=done&style=none&width=1041" alt="QQ截图20200219112820.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582082932970-ba609b81-8ce4-4a52-9d9c-c7192ea7910e.png#align=left&display=inline&height=440&name=QQ%E6%88%AA%E5%9B%BE20200219112841.png&originHeight=440&originWidth=1026&size=249681&status=done&style=none&width=1026" alt="QQ截图20200219112841.png"><br>myhack2.dl 的源代码非常简单，若当前加载自己的进程为“notepad.exe”，则以隐藏模式运行 IE，连接指定网站。这样就可以根据不同目的执行多种任务了。</p>
<h2 id="23-5-2-练习示例-myhack2-dll"><a href="#23-5-2-练习示例-myhack2-dll" class="headerlink" title="23.5.2 练习示例 myhack2.dll"></a>23.5.2 练习示例 myhack2.dll</h2><p>下面使用修改注册表项的方法做个 DLL 注入练习，注意操作顺序。<br>复制文件首先将要注入的 DLL 文件（myhack2.dll）复制到合适位置（在我电脑中的位置为 C:\work\myhack2.dll)，如图 23-15 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582083005406-4e64a290-8341-4822-bf61-0faeebc91c1a.png#align=left&display=inline&height=508&name=QQ%E6%88%AA%E5%9B%BE20200219112957.png&originHeight=508&originWidth=563&size=140717&status=done&style=none&width=563" alt="QQ截图20200219112957.png"><br>修改注册表项 运行注册表编辑器 regedit.exe，进入如下路径。<br>HKEY_LOCAL MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows<br>编辑修改 AppInit_DLLs 表项的值，如图 23-16 所示（请输入 myhack2.dll 的完整路径）。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582083087624-65fda240-642d-4b3f-ba4e-f8ecb91d215b.png#align=left&display=inline&height=243&name=QQ%E6%88%AA%E5%9B%BE20200219113102.png&originHeight=243&originWidth=498&size=80191&status=done&style=none&width=498" alt="QQ截图20200219113102.png"><br>然后修改 LoadAppInit_DLLs 注册表项的值为 1，如图 23-17 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582083088305-2963d3ea-b592-4620-9604-f66484281370.png#align=left&display=inline&height=319&name=QQ%E6%88%AA%E5%9B%BE20200219113115.png&originHeight=319&originWidth=498&size=105844&status=done&style=none&width=498" alt="QQ截图20200219113115.png"><br><strong>重启系统</strong><br>注册表项修改完毕后，重启系统，使修改生效。系统重启完成后，使用 Process Explorer 查看 myhack2.dll 是否被注入所有（加载 user32.dll 的）进程。<br>从图 23-18 可以看到，myhack2.dll 成功注入所有加载 user32.dll 的进程。但由于它的目标进程仅是 notepad.exe 进程，所以在其他进程中不会执行任何动作。运行 notepad.exe，可以看到 IE 被（以隐藏模式）执行，如图 23-19 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582083241030-30e053b7-e8a5-4884-b825-eca17bf50a0a.png#align=left&display=inline&height=554&name=QQ%E6%88%AA%E5%9B%BE20200219113336.png&originHeight=554&originWidth=731&size=286747&status=done&style=none&width=731" alt="QQ截图20200219113336.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1582083242587-c77fe45b-d5fd-4e2b-a708-66f2b3aeb594.png#align=left&display=inline&height=587&name=QQ%E6%88%AA%E5%9B%BE20200219113349.png&originHeight=587&originWidth=540&size=254502&status=done&style=none&width=540" alt="QQ截图20200219113349.png"><br>提示—————————————————————————————————————–<br><strong>Applnit_DLLs 注册表键非常强大，通过它几乎可以向所有进程注入 DLL 文件。若波注入的 DLL 出现问题（Bug)，则有可能导致 Windows 无法正常启动，所以修改该 AppInit_DLLs 前务必彻查。</strong></p>
<hr>
<h1 id="23-6-SetWindowsHookEx"><a href="#23-6-SetWindowsHookEx" class="headerlink" title="23.6 SetWindowsHookEx()"></a>23.6 SetWindowsHookEx()</h1><p>注入 DLL 的第三个方法就是消息钩取，即用 SetWindowsHookEx()API 安装好消息“钩子”，然后由 OS 将指定 DLL（含有“钩子”过程）强制注入相应（带窗口的）进程。其工作原理与使用方法在第 21 章中已有详细讲解，请参考。</p>
<h1 id="23-7-小结"><a href="#23-7-小结" class="headerlink" title="23.7 小结"></a>23.7 小结</h1><p>本章我们学习了有关 DLL 注人的概念及具体的实现方法。这些内容在代码逆向分析中占据着很大比重，学习时要重点理解 DLL 注入技术的内部工作原理。此外，进程钩取与“打补丁”中也广泛应用 DLL 注入技术。</p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><p>Q.开始学习代码逆向分析前，是不是得先学汇编语言、C 语言、Win32APl?<br>A.我开始学习代码逆向分析技术时，完全不懂汇编语言（可能大部分代码逆向分析人员都如此）。入门阶段重要的不是汇编知识，而是调试器的使用方法、Windows 内部结构等内容。C 语言与 Win32API 是一定要学好的，如果事先已经学过，那当然好；没学过也不要担心，遇到就随时查看并学习相关资料。初学时多碰壁反而是好事。</p>
<p>Q.我编写了一个 DLL 文件，想注入 Explorer.exe 进程，但杀毒软件总是报告病毒。<br>A.向系统进程注入 DLL 时，大部分杀毒软件会根据行为算法将其标识为病毒并查杀。</p>
<p>Q.前面的讲解中提到“CreateRemote Thread（）实际调用的是 LoadLibrary(）”，实际生成的不是线程吗？<br>A.是的，会在目标进程中创建线程。与普通意义上的创建线程相比，调用 LoadLibrary()占据了很大比重，所以才这样说的（这可能给大家造成了混乱）。</p>
<p>Q.进程 A 不具有串口通信功能，我想使用 DLL 注入技术为进程添加该功能，这可以实现吗？<br>A.从技术角度来说，问题不大。只要把串口通信功能放入要注入的 DLL 即可。但如需与原程序联动，设计时必须进行更准确的分析，找到合适的方案（我认为这个问题其实就是灵活运用代码逆向分析技术的一个示例，即通过代码逆向分析技术，向程序中添加新功能或修改不足之处）。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Cyberangel</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cyberangel.cn/2020/02/13/%E7%AC%AC23%E7%AB%A0%20DLL%E6%B3%A8%E5%85%A5/">https://cyberangel.cn/2020/02/13/第23章 DLL注入/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cyberangel.cn" target="_blank">Cyberangel-blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/02/19/%E7%AC%AC24%E7%AB%A0%20DLL%E5%8D%B8%E8%BD%BD/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第24章 DLL卸载</div></div></a></div><div class="next-post pull-right"><a href="/2020/02/13/%E7%AC%AC22%E7%AB%A0%E6%81%B6%E6%84%8F%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95%E5%99%A8/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第22章恶意键盘记录器</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#23-1-DLL-%E6%B3%A8%E5%85%A5"><span class="toc-number">1.</span> <span class="toc-text">23.1 DLL 注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-2-DLL-%E6%B3%A8%E5%85%A5%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.</span> <span class="toc-text">23.2 DLL 注入示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#23-2-1-%E6%94%B9%E5%96%84%E5%8A%9F%E8%83%BD%E4%B8%8E%E4%BF%AE%E5%A4%8D-Bug"><span class="toc-number">2.1.</span> <span class="toc-text">23.2.1 改善功能与修复 Bug</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-2-2-%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96"><span class="toc-number">2.2.</span> <span class="toc-text">23.2.2 消息钩取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-2-3API-%E9%92%A9%E5%8F%96"><span class="toc-number">2.3.</span> <span class="toc-text">23.2.3API 钩取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-2-4-%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.4.</span> <span class="toc-text">23.2.4 其他应用程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-2-5-%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81"><span class="toc-number">2.5.</span> <span class="toc-text">23.2.5 恶意代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-4-CreateRemote-Thread"><span class="toc-number">3.</span> <span class="toc-text">23.4 CreateRemote Thread()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#23-4-1-%E7%BB%83%E4%B9%A0%E7%A4%BA%E4%BE%8B-myhack-dll"><span class="toc-number">3.1.</span> <span class="toc-text">23.4.1 练习示例 myhack.dll</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-4-2-%E5%88%86%E6%9E%90%E7%A4%BA%E4%BE%8B%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">3.2.</span> <span class="toc-text">23.4.2 分析示例源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-4-3-%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">23.4.3 调试方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-5AppInit-DLLs"><span class="toc-number">4.</span> <span class="toc-text">23.5AppInit_DLLs</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#23-5-1-%E5%88%86%E6%9E%90%E7%A4%BA%E4%BE%8B%E6%BA%90%E7%A0%81-myhack2-cpp"><span class="toc-number">4.1.</span> <span class="toc-text">23.5.1 分析示例源码 myhack2.cpp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-5-2-%E7%BB%83%E4%B9%A0%E7%A4%BA%E4%BE%8B-myhack2-dll"><span class="toc-number">4.2.</span> <span class="toc-text">23.5.2 练习示例 myhack2.dll</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-6-SetWindowsHookEx"><span class="toc-number">5.</span> <span class="toc-text">23.6 SetWindowsHookEx()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-7-%E5%B0%8F%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">23.7 小结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Q-amp-A"><span class="toc-number">7.</span> <span class="toc-text">Q&amp;A</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Cyberangel</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">为世界上所有美好而战！！！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://cyberangel.cn/2020/02/13/%E7%AC%AC23%E7%AB%A0%20DLL%E6%B3%A8%E5%85%A5/'
    this.page.identifier = '2020/02/13/第23章 DLL注入/'
    this.page.title = '第23章 DLL注入'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Disqus' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script><script>if (window.DISQUSWIDGETS === undefined) {
  var d = document, s = d.createElement('script');
  s.src = 'https://.disqus.com/count.js';
  s.id = 'dsq-count-scr';
  (d.head || d.body).appendChild(s);
} else {
  DISQUSWIDGETS.getCount({reset: true});
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>