<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>第8章 abex'crackme#2 | Cyberangel-blog</title><meta name="author" content="Cyberangel"><meta name="copyright" content="Cyberangel"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本章分析一个非常简单的 crackme 文件，帮助大家继续熟悉调试器与反汇编代码。先简单介绍Visual Basic的文件结构及分析方法。本章分析第二个 crackme 文件 abex’crackme#2，它使用 Visual Basic 语言编写，你会感受到与使用 Visual C++或 Assembly 编写的文件相比具有不同的形态。提示————————————————————————————">
<meta property="og:type" content="article">
<meta property="og:title" content="第8章 abex&#39;crackme#2">
<meta property="og:url" content="https://cyberangel.cn/2020/02/07/%E7%AC%AC8%E7%AB%A0%20abex'crackme#2/index.html">
<meta property="og:site_name" content="Cyberangel-blog">
<meta property="og:description" content="本章分析一个非常简单的 crackme 文件，帮助大家继续熟悉调试器与反汇编代码。先简单介绍Visual Basic的文件结构及分析方法。本章分析第二个 crackme 文件 abex’crackme#2，它使用 Visual Basic 语言编写，你会感受到与使用 Visual C++或 Assembly 编写的文件相比具有不同的形态。提示————————————————————————————">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-02-07T11:28:53.000Z">
<meta property="article:modified_time" content="2021-07-04T09:57:23.410Z">
<meta property="article:author" content="Cyberangel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cyberangel.cn/2020/02/07/%E7%AC%AC8%E7%AB%A0%20abex'crackme#2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第8章 abex\'crackme#2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-04 17:57:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Cyberangel-blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">317</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Cyberangel-blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第8章 abex'crackme#2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-02-07T11:28:53.000Z" title="发表于 2020-02-07 19:28:53">2020-02-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-04T09:57:23.410Z" title="更新于 2021-07-04 17:57:23">2021-07-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第8章 abex'crackme#2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><span class="disqus-comment-count"><a href="https://cyberangel.cn/2020/02/07/%E7%AC%AC8%E7%AB%A0%20abex'crackme#2/#disqus_thread"></a></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本章分析一个非常简单的 crackme 文件，帮助大家继续熟悉调试器与反汇编代码。先简单介绍<strong>Visual Basic</strong>的文件结构及分析方法。<br>本章分析第二个 crackme 文件 abex’crackme#2，它使用 Visual Basic 语言编写，你会感受到与使用 Visual C++或 Assembly 编写的文件相比具有不同的形态。<br>提示——————————————————————————————————————<br>讲解中出现的内存（栈）地址随用户 PC 环境的不同而变化。希望各位调试时注意这一点。你现在感到调试很难是正常的，投入大量时间和精力后，就会逐渐熟悉起来。</p>
<hr>
<h1 id="8-1-运行-abex’crackme-2"><a href="#8-1-运行-abex’crackme-2" class="headerlink" title="8.1 运行 abex’crackme#2"></a>8.1 运行 abex’crackme#2</h1><p>运行之后才能了解它是什么样的程序，如图 8-1 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581075284696-54e35838-b217-4be0-b267-28571dee1a8c.png#align=left&display=inline&height=191&name=QQ%E6%88%AA%E5%9B%BE20200207193435.png&originHeight=191&originWidth=345&size=9450&status=done&style=none&width=345" alt="QQ截图20200207193435.png"><br>图 8-1 运行画面<br>这个程序具有典型的 crackme 形态，要求我们找出程序的序列号。从单独输入 Name 来看，生成 Serial 时才会用到 Name 字符串（依据经验推测）。输入合适的 Name 与 Serial，按 Check 按钮，如图 8-2 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581075384237-10728d07-667e-43c5-8d31-943751dcb325.png#align=left&display=inline&height=191&name=QQ%E6%88%AA%E5%9B%BE20200207193606.png&originHeight=191&originWidth=345&size=14905&status=done&style=none&width=345" alt="QQ截图20200207193606.png"><br>图 8-2“Wrong serial!”消息框<br>弹出“Wrong serial!”消息框，即使多次尝试其他值也依然是这个结果。下面通过调试仔细分析其代码。<br>提示——————————————————————————————————————<br>若上述示例文件（abexcm2-voiees.exex）无法运行，请先把附带的 MSVBVM60.dll 文件复制到示例文件相同路径下再操作。</p>
<hr>
<h1 id="8-2Visual-Basic-文件的特征"><a href="#8-2Visual-Basic-文件的特征" class="headerlink" title="8.2Visual Basic 文件的特征"></a>8.2Visual Basic 文件的特征</h1><p>要调试的 abex’s crackme#2 文件由 Visual Basic 编写而成。调试前最好先了解 Visual Basic 文件的特征。</p>
<h2 id="8-2-1VB-专用引擎"><a href="#8-2-1VB-专用引擎" class="headerlink" title="8.2.1VB 专用引擎"></a>8.2.1VB 专用引擎</h2><p><strong>VB 文件使用名为 MSVBVM60.dll</strong>（Microsoft Visual Basic Virtual Machine6.0)<strong>的 VB 专用引擎</strong>（也称为 The Thunder Runtime Engine)。<br><strong>举个使用 VB 引擎的例子，显示消息框时，VB 代码中要调用 MsgBox()函数。其实，VB 编辑器真正调用的是 MSVBVM60.d11 里的 rtcMsgBox）函数，在该函数内部通过调用 user32.dll 里的 MessageBoxW()函数（Win32API)来工作（也可以在 VB 代码中直接调用 user32.dll 里的 MessageBoxW())。</strong></p>
<h2 id="8-2-2-本地代码和伪代码"><a href="#8-2-2-本地代码和伪代码" class="headerlink" title="8.2.2 本地代码和伪代码"></a>8.2.2 本地代码和伪代码</h2><p>根据使用的编译选项的不同，VB 文件可以编译为<strong>本地代码（Ncode）</strong>与<strong>伪代码（Pcode）</strong>。<strong>本地代码一般使用易于调试器解析的 IA-32 指令；而伪代码是一种解释器（Interpreter)语言，它使用由 VB 引擎实现虚拟机并可自解析的指令（字节码）。</strong>因此，若想准确解析 VB 的伪代码，就需要分析 VB 引擎并实现模拟器。<br>提示—————————————————————————————————————— <br>伪代码具有与 Java（Java 虚拟机）、Python（Python 专用引擎）类似的形态结构。<strong>使用伪代码的好处是非常方便代码移植</strong>（编写/发布针对特定平台的引擎，用户代码借助它几乎可以不加任何修改地在指定平台上运行）。</p>
<hr>
<h2 id="8-2-3-事件处理程序"><a href="#8-2-3-事件处理程序" class="headerlink" title="8.2.3 事件处理程序"></a>8.2.3 事件处理程序</h2><p>VB 主要用来编写 GUI 程序，IDE 用户界面本身也最适合于 GUI 编程。<strong>由于 VB 程序采用 Windows 操作系统的事件驱动方式工作，所以在 main()或 WinMain()中并不存在用户代码（希望调试的代码），用户代码存在于各个事件处理程序（event handler)之中。</strong><br>    就上述 abex’crackme#2 而言，<strong>用户代码在点击 Check 按钮时触发的事件处理程序内</strong>。</p>
<h2 id="8-2-4-未文档化的结构体"><a href="#8-2-4-未文档化的结构体" class="headerlink" title="8.2.4 未文档化的结构体"></a>8.2.4 未文档化的结构体</h2><p>VB 中使用的各种信息（Dialog、Control、Form、Module、Function 等）以结构体形式保存在文件内部。由于微软未正式公开这种结构体信息，所以调试 VB 文件会难一些。</p>
<h1 id="8-3-开始调试"><a href="#8-3-开始调试" class="headerlink" title="8.3 开始调试"></a>8.3 开始调试</h1><p>运行 OllyDbg，查看 abex’crackme#2 文件的反汇编代码，如图 8-3 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581129227224-6ff698e6-78d2-4a47-a70d-a9b2bd8f72b7.png#align=left&display=inline&height=528&name=QQ%E6%88%AA%E5%9B%BE20200208103340.png&originHeight=528&originWidth=1278&size=101533&status=done&style=none&width=1278" alt="QQ截图20200208103340.png"><br>图 8-3EP<br>执行程序后，在 EP 代码中首先要做的是调用 VB 引擎的主函数（ThunRTMain()）。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581129411274-a651ffbc-5e7a-438c-91c1-6694d0f4d503.png#align=left&display=inline&height=61&name=QQ%E6%88%AA%E5%9B%BE20200208103644.png&originHeight=61&originWidth=1279&size=13921&status=done&style=none&width=1279" alt="QQ截图20200208103644.png"><br>EP 的地址为 401238。401238 地址处的 PUSH 401E14 命令用来把 RT MainStruct 结构体的地址（401E14)压入栈。然后 40123D 地址处的 CALL 00401232 命令调用 401232 地址处的 JMP DWORD PTR DS:[4010A0]指令。该 JMP 指令会跳转至 VB 引擎的主函数 ThunRTMain()（前面压入栈的 401E14 的值作为 ThunRTMain()的参数）。<br>以上 3 行代码是 VB 文件的全部启动代码。虽然非常简单，但有 3 个方面需要各位留意。</p>
<h2 id="8-3-1-间接调用"><a href="#8-3-1-间接调用" class="headerlink" title="8.3.1 间接调用"></a>8.3.1 间接调用</h2><p>40123D 地址处的 CALL 401232 命令用于调用 ThunRTMain()函数，这里使用了较为特别的技法。不是直接转到 MSVBVM60.dll 里的 ThunRTMain()函数，而是通过中间 401232 地址处的 JMP 命令跳转。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581129664318-6afa6b89-512b-429a-8ac5-90d5b70a5695.png#align=left&display=inline&height=22&name=QQ%E6%88%AA%E5%9B%BE20200208104053.png&originHeight=22&originWidth=1275&size=5638&status=done&style=none&width=1275" alt="QQ截图20200208104053.png"><br>这就是 VC++、VB 编译器中常用的<strong>间接调用法</strong>（Indirect Call）。<br>提示——————————————————————————————————————<br>4010A0 地址是 IAT（Import Address Table，导入地址表）区域，包含着 MSVBVM60，ThunRTMain()函数的实际地址。第 13 章将详细讲解 IAT。</p>
<hr>
<h2 id="8-3-2RT-MainStruct-结构体"><a href="#8-3-2RT-MainStruct-结构体" class="headerlink" title="8.3.2RT_MainStruct 结构体"></a>8.3.2RT_MainStruct 结构体</h2><p>要注意的是 ThunRTMain()函数的参数 RT_MainStruct 结构体。这里，RT_MainStruct 结构体存在于 401E14 地址处，如图 8-4 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581130026428-6f76c4e4-d464-42a9-b26e-08d298503f8e.png#align=left&display=inline&height=301&name=QQ%E6%88%AA%E5%9B%BE20200208104657.png&originHeight=301&originWidth=763&size=36598&status=done&style=none&width=763" alt="QQ截图20200208104657.png"><br>图 8-4 RT_MainStruct<br>微软未公开 RT_MainStruct，但是有国外的逆向分析高手已经完成了对 RT_MainStruct 结构体的分析，并公布在网络上。<br>RT_MainStruct 结构体的成员是其他结构体的地址。也就是说，VB 引擎通过参数传递过来的 RT_MainStruct 结构体获取程序运行需要的所有信息。<br>此处省略对 RT_MainStruct 结构体的详细说明。<br>8.3.3 ThunRTMain()函数<br>前面提到了 ThunRTMain()函数，下面了解一下。<br>图 8-5 显示了 ThunRTMain()代码的开始部分，可以看到内存地址完全不同了。这是 MSVBVM60.dll 模块的地址区域。换言之，我们分析的不是程序代码，而是 VB 引擎代码（现在还不需要分析如此庞大的代码）。对 VB 文件的讲解到此为止，继续回到 abex’crackme#2。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581130239181-34a89c59-0059-4d4a-ba24-da6610ddb0ab.png#align=left&display=inline&height=527&name=QQ%E6%88%AA%E5%9B%BE20200208105031.png&originHeight=527&originWidth=1278&size=94164&status=done&style=none&width=1278" alt="QQ截图20200208105031.png"><br>图 8-5 ThunRTMain()代码开始<br>总结一下：<br>EP 代码（地址：401238）（PUSH 401E14）-&gt;把 RT MainStruct 结构体的地址（401E14)压入栈-&gt;CALL 00401232（地址：40123D）-&gt;JMP DWORD PTR DS:[4010A0]-&gt;跳转至 VB 引擎的主函数 ThunRTMain()（为 MSVBVM60.dll 模块的地址区域）（4010A0 地址是 IAT（Import Address Table，导入地址表）区域，包含着 MSVBVM60，ThunRTMain()函数的实际地址。）-&gt;（以上代码称之为 VB 文件的启动代码）-&gt;ThunRTMain()函数的参数 RT_MainStruct 结构体（地址：401E14）（RT_MainStruct 结构体的成员是其他结构体的地址。也就是说，VB 引擎通过参数传递过来的 RT_MainStruct 结构体获取程序运行需要的所有信息）<br>注：前面压入栈的 401E14 的值作为 ThunRTMain()的参数</p>
<h1 id="8-4-分析-crackme"><a href="#8-4-分析-crackme" class="headerlink" title="8.4 分析 crackme"></a>8.4 分析 crackme</h1><p>要“打补丁”的代码到底在哪呢?应该先找到解决问题的线索。以各位现在的水平，分析 RT_MainStruct 结构体不是件容易的事，要想一个更简单的方法才行。这种思路就是利用图 8-2 中的错误消息框与字符串。</p>
<h2 id="8-4-1-检索字符串"><a href="#8-4-1-检索字符串" class="headerlink" title="8.4.1 检索字符串"></a>8.4.1 检索字符串</h2><p>使用 OllyDbg 中的字符串检索功能（选择 All referenced text strings)（右键-&gt;查找-&gt;所有参考文本字符串），显示出图 8-6 所示的窗口。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581131329151-75aebd56-3c7d-4190-a825-687017e66461.png#align=left&display=inline&height=455&name=QQ%E6%88%AA%E5%9B%BE20200208110840.png&originHeight=455&originWidth=1284&size=86369&status=done&style=none&width=1284" alt="QQ截图20200208110840.png"><br>图 8-6 All referenced text strings<br>可以在上面窗口中看到消息框显示的字符串。双击相应字符串（“Wrong serial”），转到其地址处，如图 8-7 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581131501303-2ce7b1a1-c144-4236-b5e5-7fb9885a98b4.png#align=left&display=inline&height=527&name=QQ%E6%88%AA%E5%9B%BE20200208111134.png&originHeight=527&originWidth=1278&size=102143&status=done&style=none&width=1278" alt="QQ截图20200208111134.png"><br>图 8-7 403458 地址<br>消息框的标题（“Wrong serial！”）、内容（“Nope，this serial is wrong!”)，还有实际调用消息框函数的代码（4034A6）都显示出来了。<br>从编程的观点来看，使用某种算法生成序列号，通过比较用户输入的序列号与字符串，代码分为 TRUE（序列号相同）与 FALSE（序列号不同）两大部分。换言之，上述代码的前后存在字符串比较代码，且序列号正确时程序代码会调用消息框输出成功消息（序列号正确时调用消息框，这一点可由图 8-6 中的字符串类比推测出来）。<br>在图 8-7 中略微向上拖动滚动条，果然（如前预测）看到了包含条件转移语句的代码（参考图 8-8）。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581131710734-a18cae6b-246b-4c92-a8ca-c65040041c3c.png#align=left&display=inline&height=524&name=QQ%E6%88%AA%E5%9B%BE20200208111503.png&originHeight=524&originWidth=1279&size=106616&status=done&style=none&width=1279" alt="QQ截图20200208111503.png"><br>图 8-8 条件转移指令<br>调用 403329 地址的__vbaVarTstEq()函数，比较（TEST 命令）返回值（AX)后，由 403332 地址的条件转移指令（正指令）决定执行“真”代码还是“假”代码。<br>上述代码使用的汇编指令说明—————————————————————————————–<br>TEST：逻辑比较（Logical Compare)<br>与 bit-wise logical（按位运算）‘AND’一样（仅改变 EFLAGS 寄存器而不改变操作数的值）若 2 个操作数中一个为 0，则 AND 运算结果被置为 0→ZF=1。<br>JE：条件转移指令（Jump if equal)<br>若 ZF=1，则跳转。</p>
<hr>
<h2 id="8-4-2-查找字符串地址"><a href="#8-4-2-查找字符串地址" class="headerlink" title="8.4.2 查找字符串地址"></a>8.4.2 查找字符串地址</h2><p>图 8-8 中 403329 地址处的__vbaVarTstEq()函数为字符串比较函数，其上方的 2 个 PUSH 指令为比较函数的参数，即比较的字符串（联想到 C 语言的 strcmp()函数而推测出的）。<br>调试至 403329 地址处。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581132078271-22f3ee5c-1e26-4e1c-8497-873e8f601e1d.png#align=left&display=inline&height=142&name=QQ%E6%88%AA%E5%9B%BE20200208112109.png&originHeight=142&originWidth=1280&size=26472&status=done&style=none&width=1280" alt="QQ截图20200208112109.png"><br>00403321 地址处的 SS；[EBP-44]表达的是什么呢?“IA-32 基本说明”与“栈帧”中讲过，SS 是栈段，EBP 是基址指针寄存器。换言之，SS:[EBP-44]指的是栈内地址，它恰好又是函数中声明的局部对象的地址（局部对象存储在栈区）。在此状态下查看栈（这时你需要在程序框中输入：ReverseCore，abcd1234 并且按下程序中的 check 按钮），如图 8-9 所示（栈地址会随调试环境的不同而改变）。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581132677324-0bbb9221-1e5b-4c8e-9f79-97ebabef55cb.png#align=left&display=inline&height=40&name=QQ%E6%88%AA%E5%9B%BE20200208113107.png&originHeight=40&originWidth=1113&size=4705&status=done&style=none&width=1113" alt="QQ截图20200208113107.png"><br>图 8-9 栈<br>查看存储在栈中的内存地址（19F1BC、19F1AC），如图 8-10 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581133001741-aca3de24-a50d-4004-b248-d497932b34bc.png#align=left&display=inline&height=298&name=QQ%E6%88%AA%E5%9B%BE20200208113634.png&originHeight=298&originWidth=761&size=45882&status=done&style=none&width=761" alt="QQ截图20200208113634.png"><br>图 8-10 栈内存<br>提示——————————————————————————————————————<br>OllyDbg 中有一个更方便的查找命令，使用时不需要输入地址。在代码窗口或栈窗口中使用鼠标选中指定地址，使用右键菜单中的 Follow in dump 或 Follow in dump→Memory address 命令即可。</p>
<hr>
<p>与 C++的 string 类一样，VB 字符串使用可变长度的字符串类型。所以就像在图 8-10 看到的一样，直接显示的不是字符串，而是 16 字节大小的数据（这就是 VB 中使用的字符串对象）。<br>不同的值被这样统一起来，仅方框显示的值是不同的，看上去就像内存地址一样（可变长度字符串类型内部持有实际动态分配的字符串缓存地址）。<br><strong>在 OllyDbg 的 Dump 窗口中选择右键菜单 Long-Address with ASCII dump（长型-&gt;ASCII 数据地址）命令。该命令可以把 Dump 窗口的查看形式变得与栈窗口一样，特别是针对字符串地址时可以将相应字符串显示出来（若想返回原视图，使用鼠标右键菜单的 Hex-Hex/ASCII（16 个字节）命令即可）</strong>。<br>如图 8-11 所示，EDX（0019F1A8）最终是实际的 serial 值，EAX（0019F1B8）是用户输入的 serial 值（请注意 VB 使用 Unicode 字符串）。进入字符串所在地址可以看到实际的字符串。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581133598907-d978aabc-1f11-4d31-841f-ef477a53ffdf.png#align=left&display=inline&height=301&name=QQ%E6%88%AA%E5%9B%BE20200208114556.png&originHeight=301&originWidth=761&size=30755&status=done&style=none&width=761" alt="QQ截图20200208114556.png"><br>图 8-11 Long-Address with ASCII dump<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581134248286-be86d5e1-7d87-44e0-888a-c123360ef4e4.png#align=left&display=inline&height=137&name=QQ%E6%88%AA%E5%9B%BE20200208115721.png&originHeight=137&originWidth=628&size=54561&status=done&style=none&width=628" alt="QQ截图20200208115721.png"><br>（注：读者的 ASCII 窗口为乱码，应该是中文环境导致（猜的））<br>提示——————————————————————————————————————<br>图 8-10~图 8-12 中的 Unicode 字符串地址是不一样的（读者是一次性调试的，因此地址是相同的）。原因在于它们不是在同一调试过程中截图的，而是经过多次调试重启截取的，所以字符串的地址发生了变化。<strong>VB 默认使用基于 Unicode 的可变长度字符串对象。可变长度字符串对象会根据需要在内部随时动态分配/释放内存。因此，每次运行时字符串的地址会有所不同。此外，调试时无法一眼看全实际字符串，这也是调试的困难之一。</strong></p>
<hr>
<p>运行 Crackme 程序，输入 Name=“ReverseCore”、Serial=“B6C9DAC9”，会弹出成功的消息框，如图 8-13 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581134363978-73a188be-beef-4854-9fe4-46984882bd3c.png#align=left&display=inline&height=191&name=QQ%E6%88%AA%E5%9B%BE20200208115910.png&originHeight=191&originWidth=345&size=14148&status=done&style=none&width=345" alt="QQ截图20200208115910.png"><br>图 8-13“Congratulations!”消息框<br>消息框表明找到了正确的 Serial 并破解成功。但 Name 与 Serial 之间是什么关系呢?为了测试，向 Name 中输入另一个值，Serial 保持不变，程序显示错误信息。这证明了最初的推测，即程序采用了“以 Name 字符串为基础随时生成 Serial”的算法。</p>
<h2 id="8-4-3-生成-Serial-的算法"><a href="#8-4-3-生成-Serial-的算法" class="headerlink" title="8.4.3 生成 Serial 的算法"></a>8.4.3 生成 Serial 的算法</h2><p>本节讲述生成 Serial 字符串的算法。<br><strong>查找函数开始部分</strong><br>很显然，图 8-8 中的条件转移代码属于某个函数。该函数可能就是 Check 按钮的事件处理程序。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581131710734-a18cae6b-246b-4c92-a8ca-c65040041c3c.png#align=left&display=inline&height=524&name=QQ%E6%88%AA%E5%9B%BE20200208111503.png&originHeight=524&originWidth=1279&size=106616&status=done&style=none&width=1279" alt="QQ截图20200208111503.png"><br>图 8-8 条件转移指令<br>原因在于选择 Check 按钮后，该函数会被调用执行，且含有用户代码来弹出成功/失败消息框。<br>最好倒着向上一点点地查找函数开始部分。向上拖动滚动条即可见到图 8-14 所示的代码。仔细看一下 00402ED0 地址处的命令。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581134622419-1b435435-8f4e-4970-bb58-5fd720e14e76.png#align=left&display=inline&height=44&name=QQ%E6%88%AA%E5%9B%BE20200208120333.png&originHeight=44&originWidth=1278&size=4919&status=done&style=none&width=1278" alt="QQ截图20200208120333.png"><br>上述代码是典型的栈帧代码，开始执行函数就会形成<strong>栈帧</strong>。由此得知该位置就是函数开始部分，<strong>即 Check 按钮的事件处理程序。</strong><br>汇编指令————————————————————————————————————–<br>VB 文件的函数之间存在着 NOP 指令（图 8-14 的 402ECC~402ECF 地址区）。<br>NOP:No Operation，不执行任何动作的指令（只消耗 CPU 时钟）。</p>
<hr>
<p>为了准确分析代码，在 402ED0 处设置断点（F2）后开始调试。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581134838431-c53801ce-06b3-4c81-83dd-2ddfccbfc6b0.png#align=left&display=inline&height=524&name=QQ%E6%88%AA%E5%9B%BE20200208120657.png&originHeight=524&originWidth=1279&size=90509&status=done&style=none&width=1279" alt="QQ截图20200208120657.png"><br>图 8-14 按钮的事件处理程序</p>
<h2 id="8-4-4-预测代码"><a href="#8-4-4-预测代码" class="headerlink" title="8.4.4 预测代码"></a>8.4.4 预测代码</h2><p>如果你有编程或逆向分析经验，就可以预测出生成序列号的方法。若是 Win32API 程序，则有如下特点。</p>
<ul>
<li>读取 Name 字符串（使用 GetWindowText、GetDlgltemText 等 API）。</li>
<li>启动循环，对字符加密（XOR、ADD、SUB 等）。</li>
</ul>
<p>上述文件使用 VB 引擎函数编写而成，也有类似的原理。若预测正确，从图 8-14 的事件处理程序起始代码开始调试，查找到读取 Name 字符串的部分后，紧接着就会出现加密循环。<br>提示—————————————————————————————————————–<br>调试前先预测代码的实现，这是个好习惯。若预测有误也没关系，从头开始调试即可。但若是有幸预测正确，则可以节省大量调试时间。</p>
<hr>
<h2 id="8-4-5-读取-Name-字符串的代码"><a href="#8-4-5-读取-Name-字符串的代码" class="headerlink" title="8.4.5 读取 Name 字符串的代码"></a>8.4.5 读取 Name 字符串的代码</h2><p>记住：我们已经在 402ED0 处设置了断点<br>在 402F98 处设置断点，按下 F9 开始执行程序<br>在程序框中输入：“ReverseCore”和“abcd1234”如下图：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581147440557-fdc95141-9d57-4cd0-91cb-a8919d679044.png#align=left&display=inline&height=191&name=QQ%E6%88%AA%E5%9B%BE20200208153713.png&originHeight=191&originWidth=345&size=12690&status=done&style=none&width=345" alt="QQ截图20200208153713.png"><br>点击“check”按钮，程序来到：402ED0 地址处，按下 F9 继续执行：程序来到：402F98 地址处。<br><strong>注意—————————————————————————————————————–</strong><br><strong>若当 OD 中显示如下图时，在 Dump 窗口中按下 Ctrl+G 转到此时的 ESP 所指向的地址。（千万别再 404000 处瞎找，读者就是卡在这里非常长时间）</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581147809223-d730f155-0579-43c0-bd6e-8640c2789f17.png#align=left&display=inline&height=298&name=QQ%E6%88%AA%E5%9B%BE20200208154321.png&originHeight=298&originWidth=762&size=35367&status=done&style=none&width=762" alt="QQ截图20200208154321.png"></strong><br><strong>———————————————————————————————————————-</strong><br>我此时的 ESP 指向：0019F084，来到如图 8-15：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581147855011-c9471bd4-c97c-41ec-bb06-f8c906e6d379.png#align=left&display=inline&height=302&name=QQ%E6%88%AA%E5%9B%BE20200208154408.png&originHeight=302&originWidth=762&size=41288&status=done&style=none&width=762" alt="QQ截图20200208154408.png"><br>图 8-15<br>继续调试：单步步过 402F98。<br><strong>要查找的是 Name 字符串，在 VB 中，字符串使用字符串对象（这与 C 语言使用 char 数组不同），如图 8-15 查看内存，很难认出实际的字符串。因此把 OlyDbg 的 Dump 窗口更改为 Long-Addresswith ASCII dump 视图模式。</strong><br>更改视图方式后，就可以直接看到 VB 字符串对象存储实际字符串的缓存地址了。在该状态下运行到 402F98 地址处的 CALL 命令，值存储到字符串对象，如图 8-17 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581148043230-8c3937e5-4bc2-47f0-b002-7bc11c2b6c72.png#align=left&display=inline&height=299&name=QQ%E6%88%AA%E5%9B%BE20200208154711.png&originHeight=299&originWidth=762&size=27564&status=done&style=none&width=762" alt="QQ截图20200208154711.png"><br>图 8-17 Name 字符串<br>Name 字符串（以字符串对象形式）存储到 19F078 地址。</p>
<h2 id="8-4-6-加密循环"><a href="#8-4-6-加密循环" class="headerlink" title="8.4.6 加密循环"></a>8.4.6 加密循环</h2><p>继续调试，遇到如下循环，即一系列循环语句。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581148623853-053e6eef-14d5-48b3-be97-d508cec81a23.png#align=left&display=inline&height=215&name=QQ%E6%88%AA%E5%9B%BE20200208155655.png&originHeight=215&originWidth=904&size=196634&status=done&style=none&width=904" alt="QQ截图20200208155655.png"><br>简单讲解上述循环的动作原理，就像在链表中使用 next 指针引用下一个元素一样，_vbaVarForlnit()、__vbaVarForNext()可以使逆向分析人员在字符串对象中逐个引用字符。并且设置 loop count（EBX）使其按指定次数运转循环。<br>提示——————————————————————————————————————<br>实测仅使用接收的 Name 字符串中的前 4 个字符。在代码内检查字符串的长度，若少于 4 个字符，就会弹出错误消息框。</p>
<hr>
<p>至此我们已经查找到了所有希望查看的部分，接下来了解一下加密方法。</p>
<h2 id="8-4-7-加密方法"><a href="#8-4-7-加密方法" class="headerlink" title="8.4.7 加密方法"></a>8.4.7 加密方法</h2><p>PS:输入的 Name 字符串为“ReverseCore”。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581148870151-de1f2004-cffc-457e-831a-a234215340f2.png#align=left&display=inline&height=190&name=QQ%E6%88%AA%E5%9B%BE20200208160046.png&originHeight=190&originWidth=906&size=179389&status=done&style=none&width=906" alt="QQ截图20200208160046.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581148871016-4333c4e7-8ab5-4838-95cc-4636c112a589.png#align=left&display=inline&height=80&name=QQ%E6%88%AA%E5%9B%BE20200208160058.png&originHeight=80&originWidth=908&size=66880&status=done&style=none&width=908" alt="QQ截图20200208160058.png"><br>在 40323D 中下断点，按 F9 调试至此，看一下栈：（中文为乱码，因此借用一下书上的）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581149832899-de5b62a1-39c5-47ee-ab2f-c86447d6a91e.png#align=left&display=inline&height=373&name=QQ%E6%88%AA%E5%9B%BE20200208161705.png&originHeight=373&originWidth=904&size=271014&status=done&style=none&width=904" alt="QQ截图20200208161705.png"><br>运行如下函数，将加密后的值存储到 ECX 寄存器所指的缓冲区。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581149968947-d2d0dd17-17b3-464d-92b2-6db9e9f09025.png#align=left&display=inline&height=22&name=QQ%E6%88%AA%E5%9B%BE20200208161921.png&originHeight=22&originWidth=1157&size=5116&status=done&style=none&width=1157" alt="QQ截图20200208161921.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581150087625-49db9696-3ef8-41af-b7f3-d7ffe6624899.png#align=left&display=inline&height=734&name=QQ%E6%88%AA%E5%9B%BE20200208162119.png&originHeight=734&originWidth=911&size=506085&status=done&style=none&width=911" alt="QQ截图20200208162119.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581150156378-a5a97283-68b7-480e-a65a-5bc3d1f5e014.png#align=left&display=inline&height=114&name=QQ%E6%88%AA%E5%9B%BE20200208162220.png&originHeight=114&originWidth=906&size=74015&status=done&style=none&width=906" alt="QQ截图20200208162220.png"><br>加密方法整理如下。<br>（1)从给定的 Name 字符串前端逐一读取字符（共 4 次）。<br>（2）将字符转换为数字（ASCII 代码）<br>（3）向变换后的数字加 64。<br>（4）再次将数字转换为字符。<br>（5）连接变换后的字符。</p>
<h1 id="8-5-小结"><a href="#8-5-小结" class="headerlink" title="8.5 小结"></a>8.5 小结</h1><p>从破解层面看，示例是个很容易说明的文件。但对于代码逆向分析初学者而言，其中包含了大量内容（VB 文件、字符串加密），若要一一学习，分量就显得非常多。<br>若跟随调试时进展不顺，请不要轻易放弃。看着上面的说明，各位可能会觉得我调试得过于简单了（特别是讲解有关事件处理程序代码的部分），但是我为了编写该章节已经重启了 10 多次。<br>错过要查找的代码时就要重启调试，需要不断重启以跟踪 VB 字符串对象内部的字符串缓冲区。各位也要经历这样一个过程才能提高调试水平。因此，现在暂时跳过还不懂的部分，达到一定水平后再挑战。</p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><p>Q.除了前面介绍的方法，还有别的方法吗?<br>A.当然，还有很多呢。破解方法不是一成不变的。即便是同一个文件，也可以尝试使用不同方法，不断尝试才能提高水平。</p>
<p>Q.破解很多 crackme 文件能够帮助提高逆向分析水平吗?<br>A.的确对提高逆向分析水平有一定帮助，但我建议初学者分析 crackme 是想让他们感受代码逆向分析的乐趣。代码逆向分析领域中要学习的内容非常多，若感受不到其中的乐趣很容易半途而废。所以，<strong>如果通过分析 crackme 文件感受到了逆向分析的乐趣，学习起来就不会觉得太难。但也不要过分沉溺于 crackme 程序的分析，只要能从中感受到乐趣足矣。</strong></p>
<p>Q.“调试到 403329”的含义是“在 403329 地址处设置断点，然后运行 Run（F9）命令”吗?<br>A.使用断点可快速到达指定位置。也可使用 StepInto（F7)/StepOver(F8)命令调试到相应地址处。</p>
<p><strong>Q.如图 8-10 所示，若想查看栈内存，该怎么办呢？?</strong><br><strong>A.在 OllyDbg 的 Dump 窗中使用移动命令（Ctrl+G)即可。或者在图 8-9 的栈窗口中选择 12FAB8，再选择鼠标右键菜单中的 Follow in dump 项。抑或在图 8-8 中选择 403321 地址后，使用鼠标右键莱单中的 Follow in dump-Memory Address 命令。</strong></p>
<p>Q.为何要在“TEST AX，AX”指令中比较 2 个一样的项？<br>A.为了检测 AX 是否为 0。只要把它想成汇编语法的特征即可。比如图 8-8 的 40332F 地址处有如下指令：<br>TEST AX,AX<br>JE403408<br>将上述汇编代码转换为 C 语言语句，如下所示：<br>if(AX==0)<br>goto 403408<br>“原来汇编语法是这样子啊”，这样想就好。<br>Q.您如何在图 8-14 的代码中查找到了 Check 按钮的事件处理程序?<br>A.参考图 8-6 ～图 8-8 的代码，把“Wrong serial”字符串定为目标，然后查找引用该字符串的代码（因为代码所属区域即是按钮的事件处理程序）。从查找到的代码开始，向上拖动滑动条，找到生成栈帧（函数开始）的部分。</p>
<p>Q.加密字符串的代码复杂难懂，看也看不明白，您是怎么知道的呢?<br>A.我找出“ReverseCore”字符串的地址后，在查找访问该字符串的代码过程中发现了加密代码。而且，仔细逐行调试也能发现。对于初学者而言，这些不是一下子就能理解的内容。<strong>不断努力、反复调试</strong>，就会慢慢明白。</p>
<p>Q.读取 Name 的位置是 StackFrame 形成后第四个 call 语句，您是如何知道的?<br>A.先找到处理程序再反复调试该代码。在此过程中边注意观察寄存器、栈边调试代码，就会看到如下指令。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1581150619172-b49f46df-3f9f-4d52-91e2-4906882499d3.png#align=left&display=inline&height=105&name=QQ%E6%88%AA%E5%9B%BE20200208163008.png&originHeight=105&originWidth=810&size=71064&status=done&style=none&width=810" alt="QQ截图20200208163008.png"><br>上面 00402FB6 地址处的命令把字符串的地址设置到 EAX 寄存器。由此可以推出[EBP-88]变量即是字符串对象，且值是由 00402F98 地址处的 CALL 指令设置的。只要反复调试就会知道这一点，各位不断挑战后也终将了解。</p>
<p>Q.其他部分都明白，但加密部分太难了。除了不断调试外，还有别的方法吗？<br>A.有些读者初次接触这些汇编代码形式的加密代码，感到很难是十分正常的，我也一样。但可以明确告诉大家，即便一再抱怨，只要不断看代码，一个月、两个月…一年后就会觉得简单一些了。坚持就是胜利。</p>
<p>Q.为什么 402ED0 地址处没有 Check 按钮的注释?<br>A.这个注释是我为便于讲解手动添加的。由于没有特别说明，可能让大家误以为它是 OllyDbg 默认提供的注释。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Cyberangel</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cyberangel.cn/2020/02/07/%E7%AC%AC8%E7%AB%A0%20abex'crackme#2/">https://cyberangel.cn/2020/02/07/第8章 abex'crackme#2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cyberangel.cn" target="_blank">Cyberangel-blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/02/08/%E7%AC%AC9%E7%AB%A0%20Process%20Explorer%E2%80%94%E2%80%94%E6%9C%80%E4%BC%98%E7%A7%80%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第9章 Process Explorer——最优秀的进程管理工具</div></div></a></div><div class="next-post pull-right"><a href="/2020/02/07/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第7章 栈帧</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#8-1-%E8%BF%90%E8%A1%8C-abex%E2%80%99crackme-2"><span class="toc-number">1.</span> <span class="toc-text">8.1 运行 abex’crackme#2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-2Visual-Basic-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">2.</span> <span class="toc-text">8.2Visual Basic 文件的特征</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-1VB-%E4%B8%93%E7%94%A8%E5%BC%95%E6%93%8E"><span class="toc-number">2.1.</span> <span class="toc-text">8.2.1VB 专用引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-2-%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E5%92%8C%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.</span> <span class="toc-text">8.2.2 本地代码和伪代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-3-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.3.</span> <span class="toc-text">8.2.3 事件处理程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-4-%E6%9C%AA%E6%96%87%E6%A1%A3%E5%8C%96%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.4.</span> <span class="toc-text">8.2.4 未文档化的结构体</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-3-%E5%BC%80%E5%A7%8B%E8%B0%83%E8%AF%95"><span class="toc-number">3.</span> <span class="toc-text">8.3 开始调试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-1-%E9%97%B4%E6%8E%A5%E8%B0%83%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">8.3.1 间接调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-2RT-MainStruct-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">3.2.</span> <span class="toc-text">8.3.2RT_MainStruct 结构体</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-4-%E5%88%86%E6%9E%90-crackme"><span class="toc-number">4.</span> <span class="toc-text">8.4 分析 crackme</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-1-%E6%A3%80%E7%B4%A2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.1.</span> <span class="toc-text">8.4.1 检索字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-2-%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%B0%E5%9D%80"><span class="toc-number">4.2.</span> <span class="toc-text">8.4.2 查找字符串地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-3-%E7%94%9F%E6%88%90-Serial-%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">8.4.3 生成 Serial 的算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-4-%E9%A2%84%E6%B5%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">4.4.</span> <span class="toc-text">8.4.4 预测代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-5-%E8%AF%BB%E5%8F%96-Name-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">4.5.</span> <span class="toc-text">8.4.5 读取 Name 字符串的代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-6-%E5%8A%A0%E5%AF%86%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.6.</span> <span class="toc-text">8.4.6 加密循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-7-%E5%8A%A0%E5%AF%86%E6%96%B9%E6%B3%95"><span class="toc-number">4.7.</span> <span class="toc-text">8.4.7 加密方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-5-%E5%B0%8F%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">8.5 小结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Q-amp-A"><span class="toc-number">6.</span> <span class="toc-text">Q&amp;A</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Cyberangel</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">为世界上所有美好而战！！！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://cyberangel.cn/2020/02/07/%E7%AC%AC8%E7%AB%A0%20abex'crackme#2/'
    this.page.identifier = '2020/02/07/第8章 abex'crackme#2/'
    this.page.title = '第8章 abex\'crackme#2'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Disqus' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script><script>if (window.DISQUSWIDGETS === undefined) {
  var d = document, s = d.createElement('script');
  s.src = 'https://.disqus.com/count.js';
  s.id = 'dsq-count-scr';
  (d.head || d.body).appendChild(s);
} else {
  DISQUSWIDGETS.getCount({reset: true});
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>