<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>第2章 逆向分析Hello World!程序 | Cyberangel-blog</title><meta name="author" content="Cyberangel"><meta name="copyright" content="Cyberangel"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="“Hello World!”程序大概是世界上最有名的程序了，下面调试“Hello World!”程序来开始学习逆向分析技术的旅程，希望大家能从中切身体验到逆向分析的乐趣。 2.1 Hello World!程序学过编程的人编写的第一个程序大概都是“Hello World!”，如图 2-1 所示。这个程序非常简洁，每当看到“Hello World!”的源码，都会让人回想起初次学习编程语言的情景，以及当">
<meta property="og:type" content="article">
<meta property="og:title" content="第2章 逆向分析Hello World!程序">
<meta property="og:url" content="https://cyberangel.cn/2020/02/06/%E7%AC%AC2%E7%AB%A0%20%E9%80%86%E5%90%91%E5%88%86%E6%9E%90Hello%20World!%E7%A8%8B%E5%BA%8F/index.html">
<meta property="og:site_name" content="Cyberangel-blog">
<meta property="og:description" content="“Hello World!”程序大概是世界上最有名的程序了，下面调试“Hello World!”程序来开始学习逆向分析技术的旅程，希望大家能从中切身体验到逆向分析的乐趣。 2.1 Hello World!程序学过编程的人编写的第一个程序大概都是“Hello World!”，如图 2-1 所示。这个程序非常简洁，每当看到“Hello World!”的源码，都会让人回想起初次学习编程语言的情景，以及当">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-02-06T02:18:40.000Z">
<meta property="article:modified_time" content="2021-07-04T09:57:24.171Z">
<meta property="article:author" content="Cyberangel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cyberangel.cn/2020/02/06/%E7%AC%AC2%E7%AB%A0%20%E9%80%86%E5%90%91%E5%88%86%E6%9E%90Hello%20World!%E7%A8%8B%E5%BA%8F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第2章 逆向分析Hello World!程序',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-04 17:57:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Cyberangel-blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">317</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Cyberangel-blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第2章 逆向分析Hello World!程序</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-02-06T02:18:40.000Z" title="发表于 2020-02-06 10:18:40">2020-02-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-04T09:57:24.171Z" title="更新于 2021-07-04 17:57:24">2021-07-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第2章 逆向分析Hello World!程序"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>“Hello World!”程序大概是世界上最有名的程序了，下面调试“Hello World!”程序来开始学习逆向分析技术的旅程，希望大家能从中切身体验到逆向分析的乐趣。</p>
<h1 id="2-1-Hello-World"><a href="#2-1-Hello-World" class="headerlink" title="2.1 Hello World!"></a>2.1 Hello World!</h1><p>程序学过编程的人编写的第一个程序大概都是“Hello World!”，如图 2-1 所示。这个程序非常简洁，每当看到“Hello World!”的源码，都会让人回想起初次学习编程语言的情景，以及当时成功运行时的感动与兴奋。下面，我们也将通过逆向分析“HelloWorld!”程序来开始学习，它非常简单，很适合做入门例题。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580955828470-418104da-22de-43a3-896c-7d0c6c2324cc.png#align=left&display=inline&height=235&name=QQ%E6%88%AA%E5%9B%BE20200206102324.png&originHeight=235&originWidth=315&size=32307&status=done&style=none&width=315" alt="QQ截图20200206102324.png"><br>首先在 Visual C++中打开 HelloWorld 项目，如图 2-2 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580955880844-28293080-d05c-4c46-9cbb-c7f2070d3a5d.png#align=left&display=inline&height=476&name=QQ%E6%88%AA%E5%9B%BE20200206102338.png&originHeight=476&originWidth=712&size=194990&status=done&style=none&width=712" alt="QQ截图20200206102338.png"><br>在工具栏的“解决方案配置”中选择“Release”，在“生成”菜单中单击“生成 HelloWorld”，即可创建出 HelloWorld.exe 可执行文件（选择“Release”模式生成可执行文件，将使程序代码更加简洁，方便调试）。<br>提示——————————————————————————————————————<br>不熟悉 VisualC++开发工具的读者可省略上述创建过程，直接使用提供的 HelloWorld.exe 文件。</p>
<hr>
<p>调试器与汇编语言<br>如上所示，借助 Visual C++开发工具，我们可以轻松地将 HelloWorld.cpp 源码编译成 HelloWorld.exe 可执行文件。HelloWorld.cpp 源码文件是用 C 语言编写的，我们很容易理解它；而 HelloWorld.exe 可执行文件是二进制文件，计算机很容易读懂并执行。分析二进制文件时，为了更好地读懂它，常常要使用调试器（Debugger）实用工具。调试器中内嵌了反汇编（Disassembler)模块，借助它我们可以把二进制代码转换为汇编语言（Assembly）指令代码。<br>提示——————————————————————————————————————<br>不论是用哪种语言编写的程序，编译后都会生成二进制的可执行文件。借助调试器我们可以把任意一种可执行文件转换为汇编语言代码，因此，代码逆向分析人员必须掌握汇编语言。只要掌握了汇编语言，就能通过调试的方式分析可执行程序，而不用考虑程序是用哪种语言编写的。<br>汇编语言依赖于 CPU。广泛用于 PC 的 Intelx86 系列 CPU 和移动产品中常用的 ARM 系列 CPU 就具有不同形态的汇编指令。</p>
<hr>
<h1 id="2-2-调试-HelloWorld-exe-程序"><a href="#2-2-调试-HelloWorld-exe-程序" class="headerlink" title="2.2 调试 HelloWorld.exe 程序"></a>2.2 调试 HelloWorld.exe 程序</h1><h2 id="2-2-1-调试目标"><a href="#2-2-1-调试目标" class="headerlink" title="2.2.1 调试目标"></a>2.2.1 调试目标</h2><p>调试（Debugging）HelloWorld.exe 可执行文件，在转换得到的汇编语言代码中查找 main()函数。这一过程中，我们要了解基本的调试方法和汇编指令。</p>
<h2 id="2-2-2-开始调试"><a href="#2-2-2-开始调试" class="headerlink" title="2.2.2 开始调试"></a>2.2.2 开始调试</h2><p>首先使用 OllyDbg 调试工具打开 HelloWorld.exe 程序，如图 2-3 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580956715601-a783b68c-3d70-4217-80ef-c27ab1e80a5e.png#align=left&display=inline&height=1030&name=QQ%E6%88%AA%E5%9B%BE20200206103826.png&originHeight=1030&originWidth=1920&size=297969&status=done&style=none&width=1920" alt="QQ截图20200206103826.png"><br>图 2-3 OllyDbg 基本界面<br>    OllyDbg:<a target="_blank" rel="noopener" href="http://www.ollydbg.de/">http://www.ollydbg.de</a><br>提示—————————————————————————————————————–</p>
<ul>
<li>代码逆向分析人员分析程序文件时一般是没有源代码的，他们只有程序的可执行文件，分析时需要使用 OllyDbg 这类强大的 Win32 专业调试工具。</li>
<li>OllyDbg 是一种强大的 Win32 调试工具，用户界面直观、简洁，支持插件扩展功能，用户可以免费下载。它体积小，运行速度快，很多逆向分析人员都喜欢使用。</li>
<li>你的逆向分析技术达到一定水平后，我建议使用 Hex-Rays 公司的 IDAPro，它是一个非常棒的反编译工具，提供了众多实用的调试功能，但它是一个付费软件，性能越强大需要支付的费用也越高。</li>
</ul>
<hr>
<h2 id="图-2-3-为-0llyDbg-调试工具的运行界面，后面的程序调试过程中我们会经常见到。调试前，先简单介绍一下图-2-3-中的-OllyDbg-调试工具运行界面。"><a href="#图-2-3-为-0llyDbg-调试工具的运行界面，后面的程序调试过程中我们会经常见到。调试前，先简单介绍一下图-2-3-中的-OllyDbg-调试工具运行界面。" class="headerlink" title="图 2-3 为 0llyDbg 调试工具的运行界面，后面的程序调试过程中我们会经常见到。调试前，先简单介绍一下图 2-3 中的 OllyDbg 调试工具运行界面。"></a>图 2-3 为 0llyDbg 调试工具的运行界面，后面的程序调试过程中我们会经常见到。调试前，先简单介绍一下图 2-3 中的 OllyDbg 调试工具运行界面。</h2><p>代码窗口：默认用于显示反汇编代码，还用于显示各种注释、标签，分析代码时显示循环、跳转位置等<br>信息寄存器窗口：实时显示 CPU 寄存器的值，可用于修改特定的寄存器<br>数据窗口：以 Hex/ASCII/Unicode 值的形式显示进程的内存地址，也可在此修改内存地址<br>栈窗口：实时显示 ESP 寄存器指向的进程栈内存，并允许修改</p>
<hr>
<h2 id="2-2-3-入口点（EntryPoint）"><a href="#2-2-3-入口点（EntryPoint）" class="headerlink" title="2.2.3 入口点（EntryPoint）"></a>2.2.3 入口点（EntryPoint）</h2><p>调试器停止的地点即为 HelloWorld.exe 执行的<strong>起始地址</strong>（4011A0），它是一段<strong>EP（EntryPoint，入口点）</strong>代码，其中最引人注意的是 CALL 与 JMP 两个命令，如下所示。<br>Address（地址） Instruction（指令）        Disassembled code（反汇编代码）                            comment（注释）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580957182575-f41495ad-ea36-48c8-94b8-6c9720910a2c.png#align=left&display=inline&height=43&name=QQ%E6%88%AA%E5%9B%BE20200206104608.png&originHeight=43&originWidth=1170&size=8022&status=done&style=none&width=1170" alt="QQ截图20200206104608.png"></p>
<hr>
<p>地址：进程的<strong>虚拟内存地址（Virtual Address，VA）</strong><br>指令：IA32（或 x86）CPU 指令<br>反汇编代码：将<strong>OP code（操作码(Operation Code)）</strong>转换为便于查看的汇编指令<br>注释：调试器添加的注释（根据选项不同，显示的注释略有不同）</p>
<hr>
<p>上面两行汇编代码含义非常明确。<br>   “先调用（CALL）40270C 地址处的函数，再跳转至（JMP）40104F 地址处。”<br>    接下来继续调试，请记住，我们的目标是在 main()函数中找出调用 MessageBox0 函数的代码。</p>
<hr>
<h2 id="EP（EntryPoint-入口点）EP-是Windows-可执行文件（EXE、DLL、SYS-等）的代码入口点，是执行应用程序时最先执行的代码的起始位置，它依赖于-CPU。"><a href="#EP（EntryPoint-入口点）EP-是Windows-可执行文件（EXE、DLL、SYS-等）的代码入口点，是执行应用程序时最先执行的代码的起始位置，它依赖于-CPU。" class="headerlink" title="EP（EntryPoint,入口点）EP 是Windows 可执行文件（EXE、DLL、SYS 等）的代码入口点，是执行应用程序时最先执行的代码的起始位置，它依赖于 CPU。"></a>EP（EntryPoint,入口点）EP 是<strong>Windows 可执行文件（EXE、DLL、SYS 等）</strong>的代码入口点，是执行应用程序时最先执行的代码的起始位置，它依赖于 CPU。</h2><h2 id="2-2-4-跟踪-40270C-函数"><a href="#2-2-4-跟踪-40270C-函数" class="headerlink" title="2.2.4 跟踪 40270C 函数"></a>2.2.4 跟踪 40270C 函数</h2><p>正式调试前，先熟悉一下 OllyDbg 基本指令的使用方法。<br>OllyDbg 基本指令（适用于代码窗口）</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>快捷键</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Restart</td>
<td>Ctrl+F2</td>
<td>重新开始调试（终止正在调试的进程后再次运行）</td>
</tr>
<tr>
<td>Step Into</td>
<td>F7</td>
<td>执行一句 OPcode（操作码），若遇到调用命令（CALL），将进入函数代码内部</td>
</tr>
<tr>
<td>Step Over</td>
<td>F8</td>
<td>执行一句 OP code（操作码），若遇到调用命令（CALL），仅执行函数自身，不跟随进入</td>
</tr>
<tr>
<td>Execute till Return</td>
<td>Ctrl+F9</td>
<td>一直在函数代码内部运行，直到遇到 RETN 命令，跳出函数</td>
</tr>
</tbody></table>
<p>在 EP 代码的 4011A0 地址处使用 Step Into（F7）指令，进入 40270C 函数，如图 2-4 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580958399351-bc3a093a-40ad-49a5-b52a-fa331d178a29.png#align=left&display=inline&height=640&name=QQ%E6%88%AA%E5%9B%BE20200206110629.png&originHeight=640&originWidth=1170&size=105220&status=done&style=none&width=1170" alt="QQ截图20200206110629.png"><br>图 2-4 40270C 函数<br>这是一段看上去有些复杂的汇编代码。由于大家尚未掌握汇编语言，所以暂时无法全部理解这段汇编代码的含义。现在不理解没关系，不用担心，随着学习的不断深入，大家慢慢就会熟悉它，并理解它代表的含义（我刚开始学的时候就是这样的，请大家相信我）。<br>图 2-4 最右侧区域中是 OllyDbg 的注释，其中<strong>红字部分是代码中调用的 API 函数名称</strong>，在注释部分只看被调用的 API 函数名称就可以了。它们并不是我们在源代码中调用的函数，也不是我们要查找的 main()函数。<strong>其实，这些函数是 Visual C++为了保证程序正常运行而自动添加（我们的源码中并没有）的 VisualC++启动函数（Stub Code，根据不同的编译器类型与版本，启动函数也会有所不同）。</strong>现在并不需要关注它们，我们的目标是 main()函数，接下来继续查找。<br>提示——————————————————————————————————————<br>刚开始学习时可以先忽略 Win32API 函数（OllyDbg 注释中的红色 API 函数调用部分），因为它们很容易让人产生困惑，直接按 Step over（F8）命令跳过即可。</p>
<hr>
<p>4027A1 地址处有一条 RETN 指令，它用于返回到函数调用者的下一条指令，一般是被调用函数的最后一句，即返回 4011A5 地址处，如图 2-3 所示。在 4027A1 地址处的 RETN 指令上执行 Step over（F8）或 Execute till Return(Ctrl+F9)命令，继续操作。按 F7/F8 执行 RETN 指令，程序会跳转到 4011A5 地址处，如下图所示（这与 C 语言中“调用函数然后返回到调用处的下一条命令”的情形类似）。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580958956805-2a4bd3e4-2c79-449c-ae49-f3685a80a6db.png#align=left&display=inline&height=639&name=QQ%E6%88%AA%E5%9B%BE20200206111542.png&originHeight=639&originWidth=1170&size=122832&status=done&style=none&width=1170" alt="QQ截图20200206111542.png"></p>
<h2 id="2-2-5-跟踪-40104F-跳转语句"><a href="#2-2-5-跟踪-40104F-跳转语句" class="headerlink" title="2.2.5 跟踪 40104F 跳转语句"></a>2.2.5 跟踪 40104F 跳转语句</h2><p>如图 2-3 所示，执行 4011A5 地址处的跳转命令 JMP 0040104F，跳转至 40104F 地址处，结果如图 2-5 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580959195988-25d8f0d1-1314-4690-8537-7dee1a47742b.png#align=left&display=inline&height=636&name=QQ%E6%88%AA%E5%9B%BE20200206111941.png&originHeight=636&originWidth=1171&size=105813&status=done&style=none&width=1171" alt="QQ截图20200206111941.png"><br>图 2-540104F 地址处的部分代码<br>代码看上去相当复杂，它们是 Visual C++启动函数（前面也提到过：40270C 函数，看来启动函数真是挺多的）。跟踪这些代码就能发现我们要查找的目标——main()函数。<br>第一次接触上述代码时，你可能会对它们感到非常陌生，甚至分不清它们是用户代码还是启动函数。但是反复调试代码的过程中你会发现，由 Visual C++编写的可执行文件大都与上述形式类似。熟悉了这些启动函数后，再调试代码时就能快速识别并跳过。此外，不同的开发工具生成的启动函数不同，即使是同一种开发工具，产生的启动函数也随版本的不同而不同。如果有额外的时间与精力，建议大家多尝试几种开发工具，熟悉并掌握它们生成的文件特征。</p>
<h2 id="2-2-6-查找-main-函数"><a href="#2-2-6-查找-main-函数" class="headerlink" title="2.2.6 查找 main()函数"></a>2.2.6 查找 main()函数</h2><p>从图 2-5 的 40104F 地址处开始逐条分析各函数调用指令，就能够查找到我们要查找的 main()函数，虽然这种方法略显笨拙，但这是初学者学习调试时的必经阶段，后面会介绍更高效的方法。<br>提示——————————————————————————————————————<br>初学者在调试代码的过程中使用 StepIn（F7)/StepOver(F8)命令，可能会对代码感到困惑，特别是过分深入到函数调用中时，这种困惑会更加明显。此时可以使用 Restart(Ctrl+F2)命令重新打开待调试的文件，再次从头调试。前面我们已经提到过，每种编译器产生的启动函数是不同的，熟悉这些启动函数后，实际调试过程中可以快速跳过类似启动函数的部分。就像刚开始学习 C 语言时，编译文件会遇到许多错误信息，熟悉这些错误信息后，再次出现相同错误信息时，就能利用之前的经验快速解决问题。</p>
<hr>
<p>前面我们介绍过 OllyDbg 的 4 种指令，分别为 Restart(Ctrl+F2)、Step Into(F7)、Step Over(F8)、Execute till Return(Ctrl+F9)，下面用它们来查找 main()函数。<br>如图 2-6 所示，从 40104F 地址开始，每执行 1 次 Step Into（F7）命令就下移 1 行代码，移动到 401056 地址处的 CALL 402524 函数调用指令时，执行 Step Into（F7）命令，进入 402524 函数。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580960056536-c3466751-d48b-48dc-a76f-f4719a7a0237.png#align=left&display=inline&height=99&name=QQ%E6%88%AA%E5%9B%BE20200206113405.png&originHeight=99&originWidth=1171&size=17940&status=done&style=none&width=1171" alt="QQ截图20200206113405.png"><br>图 2-6 调试 40104F<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580960138791-be3416fd-414b-4930-a8cd-306063db5cbf.png#align=left&display=inline&height=640&name=QQ%E6%88%AA%E5%9B%BE20200206113530.png&originHeight=640&originWidth=1170&size=95804&status=done&style=none&width=1170" alt="QQ截图20200206113530.png"><br>图 2-7 402524 函数<br>正如在图 2-7 中看到的，<del>我们很难把 402524 函数称为 main()函数</del>（我们仍然没有发现 main 函数），因为在它的代码中并未发现调用 MessageBox()API 的代码。执行 Execute till Return(Ctrl+F9)指令，调试转到 402568 地址处的 RETN 指令，然后使用 Step Into（F7)（或者 Step Over(F8))命令执行 RETN 指令，跳出 402524 函数，返回至 40105B 地址处，如下图所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580960333833-facadad8-50d5-4a8e-902b-c11203b41dce.png#align=left&display=inline&height=638&name=QQ%E6%88%AA%E5%9B%BE20200206113844.png&originHeight=638&originWidth=1171&size=107122&status=done&style=none&width=1171" alt="QQ截图20200206113844.png"><br><del>同样，在 40104F 地址处执行 Step Into（F7）命令调试，遇到函数调用就进入函数查看代码（使用 Step Into（F7）命令）</del>同样，我们可以模仿以上做法继续调试，遇到函数调用就进入函数内部查看代码，确认是否为 main()函数。若不是 main()函数，则使用 Execute till Return（Ctrl+F9）命令跳出相关函数，继续以相同方式调试。调试过程中会遇到以下代码，如图 2-8<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580961339268-9684ed3e-23f7-4689-a571-151ec2fc4192.png#align=left&display=inline&height=222&name=QQ%E6%88%AA%E5%9B%BE20200206115526.png&originHeight=222&originWidth=1171&size=38290&status=done&style=none&width=1171" alt="QQ截图20200206115526.png"><br>图 2-8 调用 API<br>4010E4 地址处的 CALLKernel32.GetCommandLineW 指令是调用 Win32API 的代码。现在，我们还不需要进入被调用的函数，直接使用 Step Over(F8)命令跳过，继续调试。<br>提示——————————————————————————————————————<br>4010EE 地址处是调用 00401C5A 函数的指令，执行后进入函数，再按 Ctrl+F9 跳出函数，由于 00401C5A 函数中含有循环语句，所以跳出函数时需要花费一些时间。</p>
<hr>
<p>若调试一切正常，则会看到以下代码，如图 2-9 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580961772276-dd3dc405-f848-41d5-9a43-9648bd786039.png#align=left&display=inline&height=82&name=QQ%E6%88%AA%E5%9B%BE20200206120241.png&originHeight=82&originWidth=1168&size=12800&status=done&style=none&width=1168" alt="QQ截图20200206120241.png"><br>图 2-9 调用 401000 函数<br>401144 地址处有一条 CALL401000 指令，用于调用 401000 函数，使用 Step Into（F7）命令进入 401000 函数，如图 2-10 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580961912931-e32acab2-8a40-4140-bef3-87220a5499e4.png#align=left&display=inline&height=167&name=QQ%E6%88%AA%E5%9B%BE20200206120502.png&originHeight=167&originWidth=1171&size=30313&status=done&style=none&width=1171" alt="QQ截图20200206120502.png"><br>图 2-10main()函数<br>401000 函数内部出现了调用 MessageBoxW()API 的代码，该 API 函数的参数为“<a target="_blank" rel="noopener" href="http://www.reversecore.com”与“hello/">www.reversecore.com”与“Hello</a> World!”两个字符串。这与图 2-2 中 HelloWorld.cpp 的源码内容一致，由此可以断定，401000 函数就是我们一直在查找的 main()函数。<br>大家也找到 main()函数了吗?（当然找到了）没找到也没关系。通过这个调试示例，主要想让大家对调试有一个大致的感受，只要能达成这一目标就足够了。如果尚未完全掌握调试的操作与步骤也没关系，经过几次调试就会很快熟悉起来。后面会讲解更多调试器指令，它们将使整个调试更加轻松（初学者经历一定的困惑是必经过程，所以上面的调试示例并未向大家详细介绍）。</p>
<h1 id="2-3-进一步熟悉调试器"><a href="#2-3-进一步熟悉调试器" class="headerlink" title="2.3 进一步熟悉调试器"></a>2.3 进一步熟悉调试器</h1><h2 id="2-3-1-调试器指令"><a href="#2-3-1-调试器指令" class="headerlink" title="2.3.1 调试器指令"></a>2.3.1 调试器指令</h2><p>到现在为止，我们已经对调试有了大致印象，接下来学习更多调试指令。<br><strong>调试器操作命令（适用于代码窗口）</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>快捷键</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Go to</td>
<td>Ctrl+G</td>
<td>移动到指定地址，用来查看代码内存，运行时不可用</td>
</tr>
<tr>
<td>Execute till Cursor（光标）</td>
<td>F4</td>
<td>执行到光标位置，即直接转到要调试的地址</td>
</tr>
<tr>
<td>Comment</td>
<td>；</td>
<td>添加注释</td>
</tr>
<tr>
<td>User-defined comment</td>
<td></td>
<td>鼠标右键菜单 Search for User-defined comment（查找-&gt;用户定义的注释）</td>
</tr>
<tr>
<td>Label</td>
<td>:</td>
<td>添加标签</td>
</tr>
<tr>
<td>User-defined label</td>
<td></td>
<td>鼠标右键菜单 Search for User-defined label（查找-&gt;用户定义的标签）</td>
</tr>
<tr>
<td>Set/Reset BreakPoint</td>
<td>F2</td>
<td>设置或取消断点（BP）</td>
</tr>
<tr>
<td>Run</td>
<td>F9</td>
<td>运行（若设置了断点，则执行至断点处）</td>
</tr>
<tr>
<td>Show the curent EIP</td>
<td>*</td>
<td>显示当前 EIP（命令指针）位置</td>
</tr>
<tr>
<td>Show the previous Cursor</td>
<td>0</td>
<td>显示上一个光标的位置</td>
</tr>
<tr>
<td>Preview CALL/JMP address</td>
<td>Enter</td>
<td>若光标处有 CALLJMP 等指令，则跟踪并显示相关地址（运行时不可用，简单查看函数内容时非常有用）</td>
</tr>
</tbody></table>
<h2 id="2-3-2“大本营”"><a href="#2-3-2“大本营”" class="headerlink" title="2.3.2“大本营”"></a>2.3.2“大本营”</h2><p>每次重新运行调试器时，调试都会返回到 EP 处，并从此处开始新的调试，使用起来相当不方便。经验丰富的代码逆向分析专家需要在调试代码时设置某个重要的点（地址），使调试能快速转到设置点上。在代码中设置好这样的点后，再次调试时，调试流能够经过这些指定的点，快速达到目标。<br>这些在代码中设置的点就像在登山途中设置的营帐一样，以登喜马拉雅山为例，登顶过程中需要设置多个营帐充当据点，如“大本营”-“前进营 1”-“前进营 2”-“最终突击营”一“峰顶”。同样，调试代码量非常巨大时，整个调试过程可能需要好几天时间，那么在相应位置上设置这些“据点”将非常方便调试。下面向大家介绍几种在代码中设置“据点”的方法，并学习如何快速转到这些“据点”。首先运行 OllyDbg，打开 HelloWorld.exe 可执行文件并调试，将 40104F 地址设置为 basecamp（大本营）。</p>
<h2 id="2-3-3-设置“大本营”的四种方法"><a href="#2-3-3-设置“大本营”的四种方法" class="headerlink" title="2.3.3 设置“大本营”的四种方法"></a>2.3.3 设置“大本营”的四种方法</h2><h3 id="1-Goto-命令"><a href="#1-Goto-命令" class="headerlink" title="1.Goto 命令"></a>1.Goto 命令</h3><p>请记住，我们要设置为“大本营”的地址为 40104F。执行 Go to（Ctrl+G）命令，打开一个 Enterexpression to follow(输入跟踪表达式）对话框，如图 2-11 所示，在文本框中输入“40104F”，然后单击 OK 按钮。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580974371496-123e9a32-b3e6-41f6-b7a2-767e49ed1a95.png#align=left&display=inline&height=130&name=QQ%E6%88%AA%E5%9B%BE20200206153235.png&originHeight=130&originWidth=405&size=5992&status=done&style=none&width=405" alt="QQ截图20200206153235.png"><br>图 2-11 Go to 对话框<br>输入地址单击 OK 按钮后，光标自动定位到 40104F 地址处，执行 Execute till cursor(F4）命令，让调试流运行到该处，然后从 40104F 处开始调试代码就变得非常方便了。</p>
<h3 id="2-设置断点"><a href="#2-设置断点" class="headerlink" title="2.设置断点"></a>2.设置断点</h3><p>调试代码时，还可以设置 BP（Break Point，断点）（快捷键：F2)让调试流转到“大本营”（40104F），这种方法非常方便，也很常用，如图 2-12 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580974627268-2291f496-017c-4e22-8431-0b6a370bb6b0.png#align=left&display=inline&height=67&name=QQ%E6%88%AA%E5%9B%BE20200206153657.png&originHeight=67&originWidth=1171&size=10316&status=done&style=none&width=1171" alt="QQ截图20200206153657.png"><br>图 2-12 设置断点<br>设置断点后，调试运行（F9）到断点处将会暂停（若未在代码中设置断点则继续调试）。<br>在 OlyDbg 菜单栏中依次选择 View-Breakpoints 选项（快捷键（ALT+B）），打开 Breakpoints 对话框，列出代码中设置的断点，如图 2-13 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580974778565-b75c50a4-4f84-4f35-93cb-6cb590f9ac88.png#align=left&display=inline&height=326&name=QQ%E6%88%AA%E5%9B%BE20200206153926.png&originHeight=326&originWidth=910&size=18235&status=done&style=none&width=910" alt="QQ截图20200206153926.png"><br>图 2-13 断点<br>在断点列表中双击某个断点会直接跳转到相应位置。</p>
<h3 id="3-注释"><a href="#3-注释" class="headerlink" title="3.注释"></a>3.注释</h3><p>按键盘上的“；”键可以在指定地址处添加注释，还可以通过查找命令找到它。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580974934530-fa06b00c-d023-4402-8223-99262f98dfd6.png#align=left&display=inline&height=67&name=QQ%E6%88%AA%E5%9B%BE20200206154204.png&originHeight=67&originWidth=1171&size=12044&status=done&style=none&width=1171" alt="QQ截图20200206154204.png"><br>图 2-14 注释<br>调试过程中添加的注释如同编程过程中添加的注释一样重要。如图 2-14 所示，在重要代码上添加注释将会使整个调试变得非常轻松。首先移动光标到另一个位置（地址 40104F 之外的任一地方），在鼠标右键菜单中依次选择 Search for（查找）-&gt;User defined comment（用户定义的注释），这样就能看到用户输入的所有注释，如图 2-15 所示（用户输入的注释会被保存在 OlyDbg 内部，每当再次运行时就会显示，调试过程中使用起来非常方便）。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580975266018-10c846af-ca80-40dc-985f-3c9ac169327d.png#align=left&display=inline&height=311&name=QQ%E6%88%AA%E5%9B%BE20200206154615.png&originHeight=311&originWidth=663&size=18852&status=done&style=none&width=663" alt="QQ截图20200206154615.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580975266623-c704c336-c614-4277-b7af-b35242304c88.png#align=left&display=inline&height=311&name=QQ%E6%88%AA%E5%9B%BE20200206154724.png&originHeight=311&originWidth=662&size=21717&status=done&style=none&width=662" alt="QQ截图20200206154724.png"><br>图 2-15 用户的注释<br>红字显示部分即是光标所处位置。注释位置与光标位置重合时，将仅以红字方式显示（所以刚开始的时候需要把光标暂时移动到其他位置）。双击相应注释，光标将自动定位到相应位置。</p>
<h3 id="4-标签"><a href="#4-标签" class="headerlink" title="4.标签"></a>4.标签</h3><p>我们可以通过标签提供的功能在指定地址添加特定名称。移动光标至 40104F 地址处，按“：”键输入标签，如图 2-16 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580975568114-c9ae80f7-a1bc-4725-a122-c06b61c4736f.png#align=left&display=inline&height=107&name=QQ%E6%88%AA%E5%9B%BE20200206155238.png&originHeight=107&originWidth=407&size=6240&status=done&style=none&width=407" alt="QQ截图20200206155238.png"><br>图 2-16 标签<br>这样就在 40104F 地址处添加上一个“basecamp”标签。在 OllyDbg 的代码窗口中可以看到 40104F 地址处添加的标签，如图 2-17 所示。<strong>（注：在 40104F 地址处添加的标签会在 4011A5 地址处显示出来）</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580976010110-e8e53bf2-e0c1-48e3-b7a7-249f576b7d81.png#align=left&display=inline&height=61&name=QQ%E6%88%AA%E5%9B%BE20200206155957.png&originHeight=61&originWidth=1169&size=7295&status=done&style=none&width=1169" alt="QQ截图20200206155957.png"></strong><br>**<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580975696776-fbf635f7-6c10-492e-aa31-46b29b60103d.png#align=left&display=inline&height=65&name=QQ%E6%88%AA%E5%9B%BE20200206155446.png&originHeight=65&originWidth=1171&size=9014&status=done&style=none&width=1171" alt="QQ截图20200206155446.png"><br>图 2-17 添加的标签<br>图 2-17 显示出了 EP 代码（你没看错，这个也是 EP 代码），刚开始只显示地址 40104F，添加标签后，代码变得非常直观，调试起来也更加轻松。<br>提示：—————————————————————————————————————-<br>若不想如图 2-17 那样显示出标签，可以在 OllyDbg 的 Options（选项）菜单中选择调试设置（调试选项）的 Disasm（反汇编）选项卡，点选 Show symbolic address（显示符号地址）项，如图 2-18 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580976332727-b6878254-4ede-4ef3-946a-21120c7341a2.png#align=left&display=inline&height=448&name=QQ%E6%88%AA%E5%9B%BE20200206160517.png&originHeight=448&originWidth=587&size=42644&status=done&style=none&width=587" alt="QQ截图20200206160517.png"><br>图 2-18 调试选项</p>
<hr>
<p>与注释一样，标签也可以检索。单击鼠标右键，依次选择 Search for（查找）-&gt;User defined labels（用户定义的标签）菜单即可打开 User defined labels 窗口，该窗口列出了用户设置的标签，如图 2-19 所示（名为 Initial CPU selection 的部分为光标当前位置）。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580976675381-78f0f7d1-ff43-4dbd-8998-bf4535849ff5.png#align=left&display=inline&height=317&name=QQ%E6%88%AA%E5%9B%BE20200206161058.png&originHeight=317&originWidth=847&size=23458&status=done&style=none&width=847" alt="QQ截图20200206161058.png">图 2-19 User-defined labels（用户定义的标签）<br>在 User defined labels 窗口中双击某个标签，光标即移动到相应位置。光标移动到标签处的地址时，执行 Execute till cursor（F4）命令即可从该地址开始调试程序。<br>我们已经学习了如何快速转到指定地址（basecamp)并调试，这些方法在程序调试中经常使用，它们使整个调试过程变得更加轻松。希望大家牢记这些方法并多加练习，直至熟练掌握。</p>
<h1 id="2-4-快速查找指定代码的四种方法"><a href="#2-4-快速查找指定代码的四种方法" class="headerlink" title="2.4 快速查找指定代码的四种方法"></a>2.4 快速查找指定代码的四种方法</h1><p>如何在大量代码中快速查找到指定代码呢?下面为大家介绍 4 种方法。<strong>调试代码时，main()函数并不直接位于可执行文件的 EP 位置上，出现在此的是开发工具（Visual C++）生成的启动函数。</strong>我们需要查看的 main()函数距离 EP 代码很远，如果有一种方法可以帮助我们快速查找到 main() 函数，那么必定会为调试带来极大帮助。<br>每个人在调试中快速查找所需代码时都有不同方法，但是归结起来，最基本、最常用的方法只有 4 种。<br>提示—————————————————————————————————————–<br>学习这 4 种方法之前先思考一下。我们已经知道，运行 HelloWorld.exe 程序会弹出一个消息框，显示“Hello World!”信息。固然是因为我们编写了代码，可在这种情形下，只要运行一下程序，不论是谁都能轻松意识到这一点。<br>如果你是 Win32API 开发人员，看到弹出的消息框就会想到，这是调用 MessageBox0API 的结果。应用程序的功能非常明确时，只要运行一下程序，就能大致推测出其内部结构（当然这需要具备开发与分析代码的经验）。</p>
<hr>
<h2 id="2-4-1-代码执行法"><a href="#2-4-1-代码执行法" class="headerlink" title="2.4.1 代码执行法"></a>2.4.1 代码执行法</h2><p>我们需要查找的是 main()函数中调用 MessageBox()函数的代码。在调试器中调试 HelloWorld.exe(Step Over(F8))时，main()函数的 MessageBox()函数在某个时刻就会被调用执行，弹出消息对话框，显示“Hello World!”这条信息。<br>以上就是代码执行法的基本原理，程序功能非常明确时，逐条执行指令来查找需要查找的位置。<strong>代码执行法仅适用于被调试的代码量不大、且程序功能明确的情况。</strong>倘若被调试的代码量很大且比较复杂时，此种方法就不再适用了。<br>下面使用代码执行法来查找代码中的 main()函数。从“大本营”（40104F)开始，按 F8 键逐行执行命令，在某个时刻弹出消息对话框，显示“Hello World!”信息。按 Ctrl+F2 键再次载入待调试的可执行文件并重新调试，不断按 F8 键，某个时刻一定会弹出消息对话框。弹出消息对话框时调用的函数即为 main()函数。<br>如图 2-20 所示，地址 401144 处有一条函数调用指令“CALL 00401000”，被调用的函数地址为 401000，按 F7 键（Step Into)进入被调用的函数，可以发现该函数就是我们要查找的 main()函数。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580977298192-a5ab96fa-e6b1-41e9-bfb7-4f6ef44f5ebd.png#align=left&display=inline&height=65&name=QQ%E6%88%AA%E5%9B%BE20200206162120.png&originHeight=65&originWidth=1169&size=9612&status=done&style=none&width=1169" alt="QQ截图20200206162120.png">图 2-20 <strong>main()函数 EP</strong><br>地址 40100E 处有一条调用 MessageBoxW()API 的语句，如图 2-21 所示。地址 401002 与 401007 处分别有一条 PUSH 语句，它们把消息对话框的标题与显示字符串（Title=”htp://<a target="_blank" rel="noopener" href="http://www.reversecore.com”,text=“hello/">www.reversecore.com”，Text=“Hello</a> World!”)保存到<strong>栈（Stack）</strong>中，并作为参数传递给 MessageBoxW()函数。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580977640267-6098786f-2082-432f-bb8e-a03d538510a8.png#align=left&display=inline&height=108&name=QQ%E6%88%AA%E5%9B%BE20200206162709.png&originHeight=108&originWidth=1169&size=21323&status=done&style=none&width=1169" alt="QQ截图20200206162709.png"><br>图 2-21 main()函数<br>这样就准确查找到了 main()函数。<br>提示——————————————————————————————————————<br>Win32 应用程序中，API 函数的参数是通过栈传递的。VC++中默认字符串是使用 Unicode 码表示的，并且，处理字符串的 API 函数也全部变更为 Unicode 系列函数。</p>
<hr>
<h2 id="2-4-2-字符串检索法"><a href="#2-4-2-字符串检索法" class="headerlink" title="2.4.2 字符串检索法"></a>2.4.2 字符串检索法</h2><p>鼠标右键菜单-Search for（查找）-All referenced text strings（所有参考文本字串）在程序中查找指定字符串的方法很多，这里向大家介绍 OllyDbg 中提供的字符串检索法。<br>OllyDbg 初次载入待调试的程序时，都会先经历一个预分析过程。此过程中会查看进程内存，程序中引用的字符串和调用的 API 都会被摘录出来，整理到另外一个列表中，这样的列表对调试是相当有用的。使用 All referenced text strings 命令会弹出一个窗口，其中<strong>列出了程序代码引用的字符串</strong>，如图 2-22 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580978568338-58991a5c-ac4e-46cf-be97-e2931c006f43.png#align=left&display=inline&height=458&name=QQ%E6%88%AA%E5%9B%BE20200206163634.png&originHeight=458&originWidth=1284&size=103153&status=done&style=none&width=1284" alt="QQ截图20200206163634.png"><br>图 2-22 All referenced text strings<br>地址 401007 处有一条 PUSH004092A0 命令，该命令中引用的 004092A0 处即是字符串“HelloWorld!”。双击字符串，光标定位到 mainO 函数中调用 MessageBoxWO 函数的代码处，请参照图 2-21。<br>在 OllyDbg 的<strong>Dump 窗口（数据窗口）</strong>中使用 Go to（Ctrl+G)命令，可以进一步查看位于内存 4092A0 地址处的字符串。首先使用鼠标单击 Dump 窗口，然后按 Ctrl+G 快捷键，打开 Enter expression to follow in Dump 窗口，如图 2-23 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580978925667-6eff8fb7-d0f4-48cd-bb25-4fe0f4e9845c.png#align=left&display=inline&height=130&name=QQ%E6%88%AA%E5%9B%BE20200206164827.png&originHeight=130&originWidth=405&size=6892&status=done&style=none&width=405" alt="QQ截图20200206164827.png"><br>图 2-23“Hello World!”字符串<br>灰色部分即是“Hello World!”字符串，它是以<strong>Unicode 码</strong>形式表示的，并且字符串的后面被填充上了 NULL 值（后面将讲解如何把“Hello World!”字符串更改为其他字符串，届时会再次涉及这块地址空间）。<br>提示——————————————————————————————————————<br><strong>VC+中，static 字符串会被默认保存为 Unicode 码形式，static 字符串是指在程序内部被硬编码（Hard Coding）的字符串。</strong></p>
<hr>
<p>图 2-23 中还需要注意的是 4092A0 这个地址，它与我们之前看到的代码区域地址（401XXX）不同。在<strong>HelloWorld.exe 进程中，409XXX 地址空间被用来保存程序使用的数据。大家要明白一点，代码与数据所在的区域是彼此分开的。</strong><br>提示——————————————————————————————————————<br>若想了解代码与数据在文件中是如何保存的，以及如何加载到内存的，就需要学习 WindowsPE 文件格式的相关内容（请参考第 13 章）。</p>
<hr>
<h2 id="2-4-3API-检索法（1）：在调用代码中设置断点"><a href="#2-4-3API-检索法（1）：在调用代码中设置断点" class="headerlink" title="2.4.3API 检索法（1）：在调用代码中设置断点"></a>2.4.3API 检索法（1）：在调用代码中设置断点</h2><p>鼠标右键莱单-Search for-All intermodular calls<br>Windows 编程中，若想向显示器显示内容，则需要使用 Win32API 向 OS 请求显示输出。<strong>换言之，应用程序向显示器画面输出内容时，需要在程序内部调用 Win32API。</strong>认真观察一个程序的功能后，我们能够大致推测出它在运行时调用的 Win32API，若能进一步查找到调用的 Win32API，则会为程序调试带来极大便利。以 HelloWorld.exe 为例，它在运行时会弹出一个消息窗口，由此我们可以推断出该程序调用了 user32.MessageBoxW()API。<br>在 OllyDbg 的预分析中，不仅可以分析出程序中使用的字符串，还可以摘录出程序运行时调用的 API 函数列表。若只想查看程序代码中调用了哪些 API 函数，可以直接使用 All intermodula rcalls 命令。如图 2-24 所示，窗口中列出了程序中调用的所有 API（根据 OlyDbg 选项设置的不同，显示形式会略微不同）。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580979449081-ef563f15-c80a-4909-afa2-0719e6c8ca28.png#align=left&display=inline&height=1030&name=QQ%E6%88%AA%E5%9B%BE20200206165719.png&originHeight=1030&originWidth=1920&size=328803&status=done&style=none&width=1920" alt="QQ截图20200206165719.png"><br>可以看到调用 MessageBoxW()的代码，该函数位于 40100E 地址处，它是 user32.MessageBoxW()API。双击它，光标即定位到调用它的地址处（40100E）。观察一个程序的行为特征，若能事先推测出代码中使用的 API，则使用上述方法能够帮助我们快速查找到需要的部分。<br>提示——————————————————————————————————————<br>对于程序中调用的 API，OllyDbg 如何准确摘录出它们的名称呢?首先，它不是通过查看源代码来摘取的，若要了解其中的原理，需要理解 PE 文件格式的<strong>IAT（Import Address Table,导入地址表）</strong>结构（请参考第 13 章）。</p>
<hr>
<h2 id="2-4-4API-检索法（2）：在-API-代码中设置断点"><a href="#2-4-4API-检索法（2）：在-API-代码中设置断点" class="headerlink" title="2.4.4API 检索法（2）：在 API 代码中设置断点"></a>2.4.4API 检索法（2）：在 API 代码中设置断点</h2><p>鼠标右键菜单-Search for-Name in all callsollyDbg 并不能为所有可执行文件都列出 API 函数调用列表。使用压缩器/保护器工具对可执行文件进行压缩或保护之后，文件结构就会改变，此时 OllyDbg 就无法列出 API 调用列表了（甚至连调试都会变得十分困难）。<br>提示——————————————————————————————————————</p>
<ul>
<li>压缩器（Run time Packer，运行时压缩器）压缩器是一个实用压缩工具，能够压缩可执行文件的代码、数据、资源等，与普通压缩不同，它压缩后的文件本身就是一个可执行文件。</li>
<li>保护器保护器不仅具有压缩功能，还添加了反调试、反模拟、反转储等功能，能够有效保护进程。若想仔细分析保护器，分析者需要具有高级逆向知识。</li>
</ul>
<hr>
<p>这种情况下，DLL 代码库被加载到进程内存后，我们可以直接向 DLL 代码库添加断点。API 是操作系统对用户应用程序提供的一系列函数，它们实现于 C:Windows\systems32 文件夹中的*.dll 文件（如 kernel32.dll、user32.dll、gdi32.dll、advapi32.dll、ws2_32.dll 等）内部。<strong>简言之，我们编写的应用程序执行某种操作时（如各种 I/O 操作），必须使用 OS 提供的 API 向 OS 提出请求，然后与被调用 API 对应的系统 DLL 文件就会被加载到应用程序的进程内存。</strong><br>在 OllyDbg 菜单栏中依次选择 View（查看）-&gt;Memory（内存）菜单（快捷键 Alt+M），打开内存映射窗口。<br>如图 2-25 所示，内存映射窗口中显示了一部分 HelloWorld.exe 进程内存。在图底部的方框中可以看到，USER32 库被加载到了内存。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580980014232-c70e0d2b-fdef-49da-a699-8bee15131fc0.png#align=left&display=inline&height=1030&name=QQ%E6%88%AA%E5%9B%BE20200206170645.png&originHeight=1030&originWidth=1920&size=266724&status=done&style=none&width=1920" alt="QQ截图20200206170645.png"><br>图 2-25 内存映射窗口<br>使用 OllyDbg 中的 Name in all modules 命令可以列出被加载的 DLL 文件中提供的所有 API。使用 Name in all modules 命令打开 All names 窗口，单击 Name 栏目按名称排序，通过键盘敲出 MessageBoxW 后，光标会自动定位到 MessageBoxW 上，如图 2-26 所示。<strong>（鼠标右键-&gt;查找-&gt;当前模块中的名称（标签））</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580980552880-b828333b-e3bd-449f-9b41-9c707f9ec90d.png#align=left&display=inline&height=1030&name=QQ%E6%88%AA%E5%9B%BE20200206171538.png&originHeight=1030&originWidth=1920&size=285343&status=done&style=none&width=1920" alt="QQ截图20200206171538.png"><br>图 2-26 All names 窗口<br>USER32 模块中有一个 Export（输出）类型的 MessageBoxW 函数（不同系统环境下函数地址不同）。双击 MessageBoxW 函数后就会显示其代码，它实现于 USER32.dl 库中，如图 2-27 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580981285175-76e21f8e-98db-4fda-9f4f-11bfce570c5d.png#align=left&display=inline&height=640&name=QQ%E6%88%AA%E5%9B%BE20200206172051.png&originHeight=640&originWidth=1193&size=121183&status=done&style=none&width=1193" alt="QQ截图20200206172051.png"><br>（Windows 10 家庭中文版-2004-19041.21）图 2-27 USER32.MessageBoxW 代码<br>观察 MessageBoxW 函数的地址空间可以发现，它与 HelloWorld.exe 使用的地址空间完全不同。在函数起始地址上按 F2 键，设置好断点后按 F9 继续执行，如图 2-28 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580981434508-ce1a68d6-8a72-41b6-9e4a-eca2ace248e9.png#align=left&display=inline&height=1030&name=QQ%E6%88%AA%E5%9B%BE20200206173020.png&originHeight=1030&originWidth=1920&size=278031&status=done&style=none&width=1920" alt="QQ截图20200206173020.png"><br>提示——————————————————————————————————————<br>若 HelloWorld.exe 应用程序中调用了 MessageBoxW()API，则调试时程序运行到该处就会暂停。</p>
<hr>
<p>与预测的一样，程序执行到 MesageBoxW 代码的断点处就停了下来，此时寄存器窗口中 ESP 的值为<del>12FF30</del>（191760），它是进程栈的地址。在右下角的栈窗口中能够看到更详细的信息。<br>提示——————————————————————————————————————<br>第 5 章和第 7 章中将详细讲解函数调用及栈动作原理。</p>
<hr>
<p><del>ESP 值的 12FF30 处对应一个返回地址 401014</del>，HelloWorld.exe 的 main()函数调用完 MessageBoxW 函数后，程序执行流将返回到该地址处。按 Ctrl+F9 快捷键使程序运行到 MessageBoxW 函数的 RETN 命令处，然后按 F7 键也可以返回到 401014 地址处。地址 401014 的上方就是地址 40100E，它正是调用 MessageBoxW 函数的地方，如图 2-21 所示。<br>上面就是快速查找代码的 4 种方法，接下来，我们将学习使用调试器更改“Hello World!”字符串。</p>
<h1 id="2-5-使用“打补丁”方式修改“Hello-World-”字符串"><a href="#2-5-使用“打补丁”方式修改“Hello-World-”字符串" class="headerlink" title="2.5 使用“打补丁”方式修改“Hello World!”字符串"></a>2.5 使用“打补丁”方式修改“Hello World!”字符串</h1><p>下面我们将学习如何通过调试器简单修改程序内容。</p>
<h2 id="2-5-1“打补丁”"><a href="#2-5-1“打补丁”" class="headerlink" title="2.5.1“打补丁”"></a>2.5.1“打补丁”</h2><p>代码逆向分析中，“打补丁”操作是不可或缺的重要主题。利用“打补丁”技术不仅可以修复已有程序中的 Bug，还可以向程序中添加新功能。<strong>“打补丁”的对象可以是文件、内存，还可以是程序的代码、数据等</strong>。本示例中，我们将使用“打补丁”技术把 HelloWorld.exe 程序消息窗口显示的“Hello World!”字符串更改为其他字符串<br>提示—————————————————————————————————————–<br>其他章节中有更多“打补丁”技术使用示例。</p>
<hr>
<p>请记住，我们的目标是把消息对话框中显示的“Hello World!”字符串更改为其他字符串。前面我们已经查找到了调用 MessageBoxW 的部分和“Hello World!”字符串的地址，这已经算成功了一半。按 Ctrl+F2 快捷键重新调试，并使调试流运行到 main 函数的起始地址处（401000）（Ctrl+G-&gt;F2（断点）-&gt;F9-&gt;F2（取消断点））。<del>在 401000 地址处按 F2 键设置断点，再按 F9 执行程序。</del>main()函数的地址 401000 被用作“大本营”（40104F)后第一个“前进营”，如图 2-29 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580982631990-a67cf796-cc8a-4530-bbac-a0f8b223f7b0.png#align=left&display=inline&height=109&name=QQ%E6%88%AA%E5%9B%BE20200206175022.png&originHeight=109&originWidth=1170&size=21488&status=done&style=none&width=1170" alt="QQ截图20200206175022.png"><br>图 2-29main ()函数</p>
<h2 id="2-5-2-修改字符串的两种方法"><a href="#2-5-2-修改字符串的两种方法" class="headerlink" title="2.5.2 修改字符串的两种方法"></a>2.5.2 修改字符串的两种方法</h2><p>下面介绍 2 种简单的修改字符串的方法。<br>① 直接修改字符串<strong>缓冲区（buffer）</strong>。<br>② 在其他内存区域生成新字符串并传递给消息函数。<br>以上 2 种方法各有优缺点，下面分别了解一下。</p>
<h3 id="1-直接修改字符串缓冲区"><a href="#1-直接修改字符串缓冲区" class="headerlink" title="1.直接修改字符串缓冲区"></a>1.直接修改字符串缓冲区</h3><p>MessageBoxW 函数的字符串参数“Hello World!”保存在地址 4092A0 处的一段缓冲区中，只要修改这段内容，就可以修改 MessageBoxW 函数显示出的字符串。在 Dump 窗口中按 Ctrl+G 快捷键执行 Go to 命令，在弹出窗口中输入 4092A0 进入字符串缓冲区。然后使用鼠标选中 4092A0 地址处的字符串，按 Ctrl+E 快捷键打开编辑窗口，如图 2-30 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580983320683-59e6d171-c0a0-4a01-93f8-a1761dba5589.png#align=left&display=inline&height=300&name=QQ%E6%88%AA%E5%9B%BE20200206180144.png&originHeight=300&originWidth=761&size=50726&status=done&style=none&width=761" alt="QQ截图20200206180144.png"><br>图 2-30“Hello World!”字符串<br>从图 2-30 可以看出,Unicode 形式的“Hello World!”字符串占据的区域为 4092A0-4092B0(Unicode 编码中用 2 个字节表示 1 个字罗马母)。用新字符串覆写该区域。<br>注意——————————————————————————————————————<br><strong>若新字符串长度大于原有字符串，执行覆盖操作时可能损坏字符串后面的数据，所以一定要小心。特别是字符串后面有非常重要的数据时，覆盖操作导致数据损坏就会引发程序内存引用错误。</strong></p>
<hr>
<p>在弹出的编辑窗口 UNICODE 文本框中输入“Hello Reversing”字符串（<strong>将保持大小取消勾选</strong>），如图 2-31 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580983614233-c860c71e-ddf2-4656-a7bd-adb0a8c9ecc7.png#align=left&display=inline&height=297&name=QQ%E6%88%AA%E5%9B%BE20200206180623.png&originHeight=297&originWidth=761&size=53062&status=done&style=none&width=761" alt="QQ截图20200206180623.png"><br>图 2-31 更改字符串为“Hello Reversing”<br>请注意，**Unicode 字符串必须以 NULL 结束，它占据 2 个字节(添加 NULL 时不能直接在 UNICODE 文本框中进行，而要在 HEX 项目中添加)**。<br>提示——————————————————————————————————————<br><strong>更改后的字符串“Hello Reversing”的长度要比原字符串“Hello World！”更长一些。原字符串后一般会存在某些有意义的数据，使用更长的字符串覆盖原字符串时，数据可能会遭到损坏，这是十分危险的。本示例中之所以采用更长的字符串覆盖仅仅是为了更好地向大家演示，实际操作中不建议这样做。</strong></p>
<hr>
<p>再返回 main()函数中，如图 2-32 所示。（还记得第一个“前进营”吧？）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580983859142-8eb4e241-3beb-48d3-a60c-2150b6cc2465.png#align=left&display=inline&height=103&name=QQ%E6%88%AA%E5%9B%BE20200206181049.png&originHeight=103&originWidth=1167&size=21979&status=done&style=none&width=1167" alt="QQ截图20200206181049.png"><br>图 2-32main()函数中被修改的字符串<br>虽然指令保持不变，但原字符串已经被新字符串取代，用作 MessageBoxW()函数的参数，并且参数的地址仍为 4092A0，只是该地址空间中的内容（字符串）发生了改变。按 F9 键运行程序后，将弹出图 2-33 所示的消息窗口，可以看到显示出的新字符串。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580983945540-32220790-73b7-4aef-897d-b17a8e97a116.png#align=left&display=inline&height=188&name=QQ%E6%88%AA%E5%9B%BE20200206181216.png&originHeight=188&originWidth=217&size=6343&status=done&style=none&width=217" alt="QQ截图20200206181216.png"><br>图 2-33 显示新字符串<br>以上就是直接更改字符串缓冲区来修改的方法。<strong>这种方法的优点是使用起来十分简单，但缺点是它对新字符串的长度有限制，新字符串的长度不应比原字符串长。</strong><br>提示—————————————————————————————————————–<br><strong>可执行文件保存字符串时一般会给字符串多留出一些空间，图 2-30 中的 HelloWorld.exe 程序就是如此。所以，如果你的运气足够好，使用更长的字符串覆盖原字符串时，即使原字符串后面的部分空间被侵占，程序仍然能正常运行。但是我们不建议大家这样做，随着这些不安定因素逐渐增多，整个系统的稳定性最终会遭到破坏。**<strong>请记住，我们是解决问题的人，而不是制造麻烦的。</strong><br>———————————————————————————————————————–保存更改到可执行文件<br>上面的调试中，我们通过修改字符串缓冲区更改了程序显示的消息内容，但是这种更改只是暂时的，终止调试（即 HelloWolrd.exe 进程结束）后，程序中的原字符串仍然没有改变。如果想把这种更改永久保存下来，就要把更改后的程序另保存为一个可执行文件。<br>图 2-31 的 Dump 窗口中，</strong>选中更改后的“Hello Reversing”字符串**，单击鼠标右键，在弹出的菜单中选择 Copy to executable file 菜单，打开图 2-34 所示的 Hex 窗口。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580988932564-23c2d636-d24f-4712-ab1b-886c66b79e6c.png#align=left&display=inline&height=347&name=QQ%E6%88%AA%E5%9B%BE20200206193518.png&originHeight=347&originWidth=592&size=74630&status=done&style=none&width=592" alt="QQ截图20200206193518.png"><br>图 2-34 Copy to executable file<br>在弹出的 Hex 窗口中单击鼠标右键，选择 Savefile 菜单，在 Save file as 对话框中输入文件名“Hello Reversing.exe”后保存为.exe 可执行文件。然后运行该文件，弹出图 2-33 所示的消息窗口，显示的字符串已经变为“Hello Reversing”。</p>
<h3 id="2-在其他内存区域新建字符串并传递给消息函数"><a href="#2-在其他内存区域新建字符串并传递给消息函数" class="headerlink" title="2.在其他内存区域新建字符串并传递给消息函数"></a>2.在其他内存区域新建字符串并传递给消息函数</h3><p>如果要用“Hello Reversing World!!！”替换原字符串“Hello World！”，上述方法就不适用了。此时我们可以换一种方法。<br>按 Ctrl+F2 快捷键重启调试，再按 F9 运行，由于之前在 main()函数的起始地址处（401000）设置了断点，所以调试流自动转到 main()函数处。再看一下 main()函数，如图 2-35 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580982631990-a67cf796-cc8a-4530-bbac-a0f8b223f7b0.png#align=left&display=inline&height=109&name=QQ%E6%88%AA%E5%9B%BE20200206175022.png&originHeight=109&originWidth=1170&size=21488&status=done&style=none&width=1170" alt="QQ截图20200206175022.png"><br>图 2-35 main ()函数<br>401007 地址处有一条 PUSH 004092A0 命令，它把 4092A0 地址处的“Hello World！”字符串以参数形式传递给 MessageBoxW()函数。<br>向 MessageBoxW()函数传递字符串参数时，传递的是字符串所在区域的首地址。如果改变了字符串地址，消息框就会显示变更后的字符串。在内存的某个区域新建一个长字符串，并把新字符串的首地址传递给 MessageBoxW()函数，可以认为传递的是完全不同的字符串地址。<br>提示上面的想法相当不错，但还要考虑另一个问题：“应该在内存的哪块区域创建新字符串呢?”要想解开答案，需要掌握 PE 文件格式与虚拟地址（Virtual Address)结构的相关知识，后面章节中会详细讲解。此处任选一块区域即可。<br>我们在方法 ① 中修改的<strong>字符串地址为 4092A0</strong>，下面再用 Dump 窗口查看该部分（参见图 2-30）。<br>向下拖动滑动条，相应内存区域由 NULL 填充（NULL padding)结束，如图 2-36 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580989437050-55c99282-ba94-4151-abb3-f225939af4ab.png#align=left&display=inline&height=299&name=QQ%E6%88%AA%E5%9B%BE20200206194346.png&originHeight=299&originWidth=742&size=17902&status=done&style=none&width=742" alt="QQ截图20200206194346.png"><br>图 2-36 内存中的 NULL 填充区域<br>这就是程序中未使用的 NULL 填充区域。<br>提示—————————————————————————————————————–<br><strong>应用程序被加载到内存时有一个最小的内存分配大小，一般为 1000。即使程序运行时只占用 100 内存，它被加载到内存时仍然会分到 1000 左右的内存，这些内存一部分被程序占用，其余部分为空余区域，全部被填充为 NULL。</strong></p>
<hr>
<p>最好将此处用作字符串缓冲区并传递给 MessageBoxW 函数，用快捷键 Ctrl+E 向结尾部分适当位置（409F50)写入新字符串（“Hello Reversing World!！”）即可，如图 2-37 所示。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580989799935-ad9ef3d3-9aba-457f-8547-8becdc676960.png#align=left&display=inline&height=352&name=QQ%E6%88%AA%E5%9B%BE20200206194953.png&originHeight=352&originWidth=760&size=53493&status=done&style=none&width=760" alt="QQ截图20200206194953.png"><br>图 2-37“Hello Reversing World!”<br>字符串仅进行上述操作无法更改消息框中的字符串。既然已经新建了缓冲区，接下来就应该把新的缓冲区地址（409F50）作为参数传递给 MessageBoxW()函数。为此，我们需要在代码窗口中使用汇编命令修改代码。如图 2-38 所示，将光标置于地址 401007 处，<strong>按空格键打开 Assemble 窗口</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580989940446-9d707ebd-178d-468d-bd36-b07c08ed1815.png#align=left&display=inline&height=131&name=QQ%E6%88%AA%E5%9B%BE20200206195159.png&originHeight=131&originWidth=405&size=8058&status=done&style=none&width=405" alt="QQ截图20200206195159.png"><br>图 2-38“Hello Reversing World!!!”字符串地址<br>在打开的 Assemble 窗口中输入“PUSH 409F50”指令，地址 409F50 为新字符串“Hello ReversingWorld!!！”的<strong>首地址</strong>。<img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580990137129-72c0e1a2-853e-4f42-83ba-0cbb05470352.png#align=left&display=inline&height=143&name=QQ%E6%88%AA%E5%9B%BE20200206195525.png&originHeight=143&originWidth=1167&size=25607&status=done&style=none&width=1167" alt="QQ截图20200206195525.png"><br>提示——————————————————————————————————————<br>用户可以在 Assemble 窗口中输入任何想输入的汇编指令，输入当时就能在代码中体现出来，也可以被执行。这种“在运行过程中动态修改进程代码”的方式正是调试最强大的功能之一。</p>
<hr>
<p>在 OllyDbg 中按 F9 键运行程序，弹出如图 2-39 所示的消息窗口。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1580990168783-edcccc08-a279-4104-80ee-69edf593e7e4.png#align=left&display=inline&height=188&name=QQ%E6%88%AA%E5%9B%BE20200206195600.png&originHeight=188&originWidth=223&size=8957&status=done&style=none&width=223" alt="QQ截图20200206195600.png"><br>图 2-39 显示新字符串<br>现在，我们就可以修改长字符串了（当然还需要积累更多更准确的基础知识）。<br>提示——————————————————————————————————————<br><strong>若把修改后的代码重新保存为程序文件，可以发现程序无法正常运行，这是由 409F50 这一地址引起的。可执行文件被加载到内存并以进程形式运行时，文件并非原封不动地被载入内存，而是要遵循一定规则进行。这一过程中，通常进程的内存是存在的，但是相应的文件偏移（offset)并不存在。上面示例中，与内存 409F50 对应的文件偏移就不存在，所以修改后的程序无法正常运行。若想进一步了解其中原理，需要学习 PE 文件格式相关知识。学过第 13 章后就可以理解了。</strong></p>
<hr>
<h1 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h1><p>大家学到这里都很辛苦了，要想一次性理解前面学的全部内容是很难的，希望各位能够反复阅读、亲自操作。学习 C 语言编程时，我们总是会从编写 Hello World!这个简单的程序开始。同样，学习调试时，我们仍然从它开始调试。希望读者们能够像征服 C 编程一样征服调试。<br>其实，调试在代码逆向分析中占据着非常大的比重，也是最有意思的。希望本书能够为大家传递些许调试的乐趣。</p>
<h2 id="归纳整理：OllyDbg-常用命令"><a href="#归纳整理：OllyDbg-常用命令" class="headerlink" title="归纳整理：OllyDbg 常用命令"></a>归纳整理：OllyDbg 常用命令</h2><table>
<thead>
<tr>
<th>指令</th>
<th>快捷键</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Step Into</td>
<td>F7</td>
<td>执行一条 OP Code(操作码），遇到 CALL 命令时，进入函数代码内部。</td>
</tr>
<tr>
<td>Step Over</td>
<td>F8</td>
<td>执行一条 OP Code(操作码），遇到 CALL 命令时，不进入函数代码内部，仅执行函数本身。</td>
</tr>
<tr>
<td>Restart</td>
<td>Ctrl+F2</td>
<td>再次从头调试（终止调试中的进程，重新载入调试程序）</td>
</tr>
<tr>
<td>Go to</td>
<td>Ctrl+G</td>
<td>移动到指定地址，用来查看代码内存，运行时不可用</td>
</tr>
<tr>
<td>Run</td>
<td>F9</td>
<td>运行（若设置了断点，则执行至断点处）</td>
</tr>
<tr>
<td>Execute till return</td>
<td>Ctrl+F9</td>
<td>执行函数代码内的命令，直到遇到 RETN 命令，用于跳出函数体</td>
</tr>
<tr>
<td>Execute till Cursor</td>
<td>F4</td>
<td>执行到光标位置，即直接转到要调试的地址</td>
</tr>
<tr>
<td>Comment</td>
<td>；</td>
<td>添加注释</td>
</tr>
<tr>
<td>User-defined comment</td>
<td></td>
<td>鼠标右键菜单 Search for User-defined comment</td>
</tr>
<tr>
<td>Label</td>
<td>:</td>
<td>添加标签</td>
</tr>
<tr>
<td>User-defined label</td>
<td></td>
<td>鼠标右键菜单 Search for User-defined label</td>
</tr>
<tr>
<td>Set/Reset BreakPoint</td>
<td>F2</td>
<td>设置或取消断点（BP）</td>
</tr>
<tr>
<td>Show the curent EIP</td>
<td>*</td>
<td>显示当前 EIP（命令指针）位置</td>
</tr>
<tr>
<td>Show the previous Cursor</td>
<td>0</td>
<td>显示上一个光标的位置</td>
</tr>
<tr>
<td>Preview CALL/JMP address</td>
<td>Enter</td>
<td>若光标处有 CALLJMP 等指令，则跟踪并显示相关地址（运行时不可用，简单查看函数内容时非常有用）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>指令</th>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>User-defined comment</td>
<td>鼠标右键菜单 Search for- User-defined comment</td>
<td>查看用户输入的注释目录</td>
</tr>
<tr>
<td>Label</td>
<td>:</td>
<td>添加标签</td>
</tr>
<tr>
<td>User-defined label</td>
<td>鼠标右键菜单 Search for-User-defined label</td>
<td>查看用户输入的标签目录</td>
</tr>
<tr>
<td>Breakpoint</td>
<td>F2</td>
<td>设置或取消断点</td>
</tr>
<tr>
<td>All referenced text strings</td>
<td>鼠标右键菜单 Search for- All referenced text strings</td>
<td>查看代码中引用的字符串</td>
</tr>
<tr>
<td>All intermodular calls</td>
<td>鼠标右键菜单 Search for All intermodular calls</td>
<td>查看代码中调用的所有 API 函数</td>
</tr>
<tr>
<td>Name in all modules</td>
<td>鼠标右键菜单 Search for- Name in all modules</td>
<td>查看所有 API 函数</td>
</tr>
<tr>
<td>Edit data</td>
<td>Ctrl+E</td>
<td>编辑数据</td>
</tr>
<tr>
<td>Assemble</td>
<td>Space</td>
<td>编写汇编代码</td>
</tr>
<tr>
<td>Copy to executable file</td>
<td>鼠标右键菜单 Copy to  executable file</td>
<td>创建文本副本（修改的项目被保留）</td>
</tr>
</tbody></table>
<h2 id="归纳整理：Assembly（汇编语言）基础指令"><a href="#归纳整理：Assembly（汇编语言）基础指令" class="headerlink" title="归纳整理：Assembly（汇编语言）基础指令"></a>归纳整理：Assembly（汇编语言）基础指令</h2><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CALLXXXX</td>
<td>调用 XXXX 地址处的函数</td>
</tr>
<tr>
<td>JMPXXXX</td>
<td>跳转到 XXXX 地址处</td>
</tr>
<tr>
<td>PUSH XXXX</td>
<td>保存 XXXX 到栈</td>
</tr>
<tr>
<td>RETN</td>
<td>跳转到栈中保持的地址</td>
</tr>
</tbody></table>
<h2 id="修改（Patch）进程数据与代码的方法"><a href="#修改（Patch）进程数据与代码的方法" class="headerlink" title="修改（Patch）进程数据与代码的方法"></a>修改（Patch）进程数据与代码的方法</h2><p>使用 OlyDbg 的编辑数据与汇编功能。</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>VA(Virtual Address)</td>
<td>进程的虚拟地址</td>
</tr>
<tr>
<td>OP code（OPeration code)</td>
<td>CPU 指令（字节码 byte code)</td>
</tr>
<tr>
<td>PE(Portable Executable)</td>
<td><strong>Windows 可执行文件（EXE、DLL、SYS 等）</strong></td>
</tr>
</tbody></table>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h3 id="Q-我使用的-OllyDbg-软件的用户界面与书中不同，需要设置某个特别的显示选项吗？"><a href="#Q-我使用的-OllyDbg-软件的用户界面与书中不同，需要设置某个特别的显示选项吗？" class="headerlink" title="Q.我使用的 OllyDbg 软件的用户界面与书中不同，需要设置某个特别的显示选项吗？"></a>Q.我使用的 OllyDbg 软件的用户界面与书中不同，需要设置某个特别的显示选项吗？</h3><p>A.在 OllyDbg 软件窗口中选择鼠标右键菜单的 Appearance 选项，可以为 OllyDbg 设置颜色、字体、高亮等，定制个性化的用户环境。大家可以在本书源文件包 OllyDbg.ini 文件中看到我使用的设置，也可以直接登录<a target="_blank" rel="noopener" href="http://www.reversecore.com网站下载ollydbg.ini文件./">www.reversecore.com网站下载OllyDbg.ini文件。</a></p>
<h3 id="Q-OllyDbg-软件中，快捷键-F4-与-F9-的区别是什么？"><a href="#Q-OllyDbg-软件中，快捷键-F4-与-F9-的区别是什么？" class="headerlink" title="Q.OllyDbg 软件中，快捷键 F4 与 F9 的区别是什么？"></a>Q.OllyDbg 软件中，快捷键 F4 与 F9 的区别是什么？</h3><p>A.首先，两个都是“运行”命令，F9 为 Run（运行），F4 为 Run to Cursor（运行到光标处），F9 是运行整个程序的命令，而 F4 仅运行到当前光标所在位置，可以把 F4 看作断点与 F9 命令的组合。</p>
<h3 id="Q-什么是启动函数"><a href="#Q-什么是启动函数" class="headerlink" title="Q.什么是启动函数?"></a>Q.什么是启动函数?</h3><p>A.首先，启动函数（Stubcode)不是用户编写的代码，而是编译器任意添加的代码。编译程序时，不同编译器会根据自身特点添加不同启动函数，<strong>特别是 EP 代码区域中存在着许多启动函数，它们也被称为启动代码（StartUp code)。</strong>调试程序时，我们不需要仔细分析这些启动函数，但是初学者有必要分清程序中哪些是启动函数，哪些是用户代码。希望大家调试时多看一看这些代码，熟悉后就能轻松区分。</p>
<h3 id="Q-到底什么是-PE-文件，为什么要等到后面才讲解？如果不懂得-PE-文件是否就无法调试？"><a href="#Q-到底什么是-PE-文件，为什么要等到后面才讲解？如果不懂得-PE-文件是否就无法调试？" class="headerlink" title="Q.到底什么是 PE 文件，为什么要等到后面才讲解？如果不懂得 PE 文件是否就无法调试？"></a>Q.到底什么是 PE 文件，为什么要等到后面才讲解？如果不懂得 PE 文件是否就无法调试？</h3><p>A.PE 是 Portable Executable 的简称，它是 Windows 操作系统下的可执行文件的格式，主要包含了对文件规格的描述，代码逆向分析技术的初学者学习它会感到非常吃力、无趣。所以我们并没有在前面详细讲解，更重要的是先让大家感受到调试的乐趣，然后再一点点地学习。此外，如果不了解 PE 文件结构的相关知识，将无法进行高级调试。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Cyberangel</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cyberangel.cn/2020/02/06/%E7%AC%AC2%E7%AB%A0%20%E9%80%86%E5%90%91%E5%88%86%E6%9E%90Hello%20World!%E7%A8%8B%E5%BA%8F/">https://cyberangel.cn/2020/02/06/%E7%AC%AC2%E7%AB%A0%20%E9%80%86%E5%90%91%E5%88%86%E6%9E%90Hello%20World!%E7%A8%8B%E5%BA%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cyberangel.cn" target="_blank">Cyberangel-blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/02/07/%E7%AC%AC3%E7%AB%A0%20%E5%B0%8F%E7%AB%AF%E5%BA%8F%E6%A0%87%E8%AE%B0%E6%B3%95/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第3章 小端序标记法</div></div></a></div><div class="next-post pull-right"><a href="/2020/02/06/%E7%AC%AC1%E7%AB%A0%20%E5%85%B3%E4%BA%8E%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第1章 关于逆向工程</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Cyberangel</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">317</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2-1-Hello-World"><span class="toc-number">1.</span> <span class="toc-text">2.1 Hello World!</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-2-%E8%B0%83%E8%AF%95-HelloWorld-exe-%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">2.2 调试 HelloWorld.exe 程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-1-%E8%B0%83%E8%AF%95%E7%9B%AE%E6%A0%87"><span class="toc-number">2.1.</span> <span class="toc-text">2.2.1 调试目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-2-%E5%BC%80%E5%A7%8B%E8%B0%83%E8%AF%95"><span class="toc-number">2.2.</span> <span class="toc-text">2.2.2 开始调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE-2-3-%E4%B8%BA-0llyDbg-%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E7%9A%84%E8%BF%90%E8%A1%8C%E7%95%8C%E9%9D%A2%EF%BC%8C%E5%90%8E%E9%9D%A2%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%88%91%E4%BB%AC%E4%BC%9A%E7%BB%8F%E5%B8%B8%E8%A7%81%E5%88%B0%E3%80%82%E8%B0%83%E8%AF%95%E5%89%8D%EF%BC%8C%E5%85%88%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%9B%BE-2-3-%E4%B8%AD%E7%9A%84-OllyDbg-%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E8%BF%90%E8%A1%8C%E7%95%8C%E9%9D%A2%E3%80%82"><span class="toc-number">2.3.</span> <span class="toc-text">图 2-3 为 0llyDbg 调试工具的运行界面，后面的程序调试过程中我们会经常见到。调试前，先简单介绍一下图 2-3 中的 OllyDbg 调试工具运行界面。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-3-%E5%85%A5%E5%8F%A3%E7%82%B9%EF%BC%88EntryPoint%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">2.2.3 入口点（EntryPoint）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EP%EF%BC%88EntryPoint-%E5%85%A5%E5%8F%A3%E7%82%B9%EF%BC%89EP-%E6%98%AFWindows-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%EF%BC%88EXE%E3%80%81DLL%E3%80%81SYS-%E7%AD%89%EF%BC%89%E7%9A%84%E4%BB%A3%E7%A0%81%E5%85%A5%E5%8F%A3%E7%82%B9%EF%BC%8C%E6%98%AF%E6%89%A7%E8%A1%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%97%B6%E6%9C%80%E5%85%88%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E7%9A%84%E8%B5%B7%E5%A7%8B%E4%BD%8D%E7%BD%AE%EF%BC%8C%E5%AE%83%E4%BE%9D%E8%B5%96%E4%BA%8E-CPU%E3%80%82"><span class="toc-number">2.5.</span> <span class="toc-text">EP（EntryPoint,入口点）EP 是Windows 可执行文件（EXE、DLL、SYS 等）的代码入口点，是执行应用程序时最先执行的代码的起始位置，它依赖于 CPU。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-4-%E8%B7%9F%E8%B8%AA-40270C-%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.</span> <span class="toc-text">2.2.4 跟踪 40270C 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-5-%E8%B7%9F%E8%B8%AA-40104F-%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.7.</span> <span class="toc-text">2.2.5 跟踪 40104F 跳转语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-6-%E6%9F%A5%E6%89%BE-main-%E5%87%BD%E6%95%B0"><span class="toc-number">2.8.</span> <span class="toc-text">2.2.6 查找 main()函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-3-%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%86%9F%E6%82%89%E8%B0%83%E8%AF%95%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">2.3 进一步熟悉调试器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-1-%E8%B0%83%E8%AF%95%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">3.1.</span> <span class="toc-text">2.3.1 调试器指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-2%E2%80%9C%E5%A4%A7%E6%9C%AC%E8%90%A5%E2%80%9D"><span class="toc-number">3.2.</span> <span class="toc-text">2.3.2“大本营”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-3-%E8%AE%BE%E7%BD%AE%E2%80%9C%E5%A4%A7%E6%9C%AC%E8%90%A5%E2%80%9D%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">2.3.3 设置“大本营”的四种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Goto-%E5%91%BD%E4%BB%A4"><span class="toc-number">3.3.1.</span> <span class="toc-text">1.Goto 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9"><span class="toc-number">3.3.2.</span> <span class="toc-text">2.设置断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B3%A8%E9%87%8A"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A0%87%E7%AD%BE"><span class="toc-number">3.3.4.</span> <span class="toc-text">4.标签</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-4-%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">2.4 快速查找指定代码的四种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-1-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">2.4.1 代码执行法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A3%80%E7%B4%A2%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">2.4.2 字符串检索法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-3API-%E6%A3%80%E7%B4%A2%E6%B3%95%EF%BC%881%EF%BC%89%EF%BC%9A%E5%9C%A8%E8%B0%83%E7%94%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9"><span class="toc-number">4.3.</span> <span class="toc-text">2.4.3API 检索法（1）：在调用代码中设置断点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-4API-%E6%A3%80%E7%B4%A2%E6%B3%95%EF%BC%882%EF%BC%89%EF%BC%9A%E5%9C%A8-API-%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9"><span class="toc-number">4.4.</span> <span class="toc-text">2.4.4API 检索法（2）：在 API 代码中设置断点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-5-%E4%BD%BF%E7%94%A8%E2%80%9C%E6%89%93%E8%A1%A5%E4%B8%81%E2%80%9D%E6%96%B9%E5%BC%8F%E4%BF%AE%E6%94%B9%E2%80%9CHello-World-%E2%80%9D%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.</span> <span class="toc-text">2.5 使用“打补丁”方式修改“Hello World!”字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-1%E2%80%9C%E6%89%93%E8%A1%A5%E4%B8%81%E2%80%9D"><span class="toc-number">5.1.</span> <span class="toc-text">2.5.1“打补丁”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-2-%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">2.5.2 修改字符串的两种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">5.2.1.</span> <span class="toc-text">1.直接修改字符串缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9C%A8%E5%85%B6%E4%BB%96%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E6%96%B0%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B6%E4%BC%A0%E9%80%92%E7%BB%99%E6%B6%88%E6%81%AF%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.在其他内存区域新建字符串并传递给消息函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-6-%E5%B0%8F%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">2.6 小结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E7%BA%B3%E6%95%B4%E7%90%86%EF%BC%9AOllyDbg-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">6.1.</span> <span class="toc-text">归纳整理：OllyDbg 常用命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E7%BA%B3%E6%95%B4%E7%90%86%EF%BC%9AAssembly%EF%BC%88%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4"><span class="toc-number">6.2.</span> <span class="toc-text">归纳整理：Assembly（汇编语言）基础指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%EF%BC%88Patch%EF%BC%89%E8%BF%9B%E7%A8%8B%E6%95%B0%E6%8D%AE%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">修改（Patch）进程数据与代码的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Q-amp-A"><span class="toc-number">8.</span> <span class="toc-text">Q&amp;A</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q-%E6%88%91%E4%BD%BF%E7%94%A8%E7%9A%84-OllyDbg-%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%B8%8E%E4%B9%A6%E4%B8%AD%E4%B8%8D%E5%90%8C%EF%BC%8C%E9%9C%80%E8%A6%81%E8%AE%BE%E7%BD%AE%E6%9F%90%E4%B8%AA%E7%89%B9%E5%88%AB%E7%9A%84%E6%98%BE%E7%A4%BA%E9%80%89%E9%A1%B9%E5%90%97%EF%BC%9F"><span class="toc-number">8.0.1.</span> <span class="toc-text">Q.我使用的 OllyDbg 软件的用户界面与书中不同，需要设置某个特别的显示选项吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q-OllyDbg-%E8%BD%AF%E4%BB%B6%E4%B8%AD%EF%BC%8C%E5%BF%AB%E6%8D%B7%E9%94%AE-F4-%E4%B8%8E-F9-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.0.2.</span> <span class="toc-text">Q.OllyDbg 软件中，快捷键 F4 与 F9 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q-%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%AF%E5%8A%A8%E5%87%BD%E6%95%B0"><span class="toc-number">8.0.3.</span> <span class="toc-text">Q.什么是启动函数?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q-%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF-PE-%E6%96%87%E4%BB%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%AD%89%E5%88%B0%E5%90%8E%E9%9D%A2%E6%89%8D%E8%AE%B2%E8%A7%A3%EF%BC%9F%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%87%82%E5%BE%97-PE-%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%B0%B1%E6%97%A0%E6%B3%95%E8%B0%83%E8%AF%95%EF%BC%9F"><span class="toc-number">8.0.4.</span> <span class="toc-text">Q.到底什么是 PE 文件，为什么要等到后面才讲解？如果不懂得 PE 文件是否就无法调试？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/06/10/%E5%88%A9%E7%94%A8mprotect%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E6%AE%B5%E6%9D%83%E9%99%90%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C/" title="利用mprotect修改程序段权限为可执行"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="利用mprotect修改程序段权限为可执行"/></a><div class="content"><a class="title" href="/2021/06/10/%E5%88%A9%E7%94%A8mprotect%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E6%AE%B5%E6%9D%83%E9%99%90%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C/" title="利用mprotect修改程序段权限为可执行">利用mprotect修改程序段权限为可执行</a><time datetime="2021-06-10T07:59:46.000Z" title="发表于 2021-06-10 15:59:46">2021-06-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/31/SROP%EF%BC%881%EF%BC%89--%E4%BB%8E%E4%B8%A4%E9%81%93%E9%A2%98%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86SROP%20attack/" title="SROP（1）--从两道题重新认识SROP attack"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SROP（1）--从两道题重新认识SROP attack"/></a><div class="content"><a class="title" href="/2021/05/31/SROP%EF%BC%881%EF%BC%89--%E4%BB%8E%E4%B8%A4%E9%81%93%E9%A2%98%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86SROP%20attack/" title="SROP（1）--从两道题重新认识SROP attack">SROP（1）--从两道题重新认识SROP attack</a><time datetime="2021-05-31T02:14:53.000Z" title="发表于 2021-05-31 10:14:53">2021-05-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/18/how2heap(14)-unsortedbin%20attack/" title="how2heap(14)-unsortedbin attack"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="how2heap(14)-unsortedbin attack"/></a><div class="content"><a class="title" href="/2021/05/18/how2heap(14)-unsortedbin%20attack/" title="how2heap(14)-unsortedbin attack">how2heap(14)-unsortedbin attack</a><time datetime="2021-05-18T07:48:53.000Z" title="发表于 2021-05-18 15:48:53">2021-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/17/how2heap(13)-tcache_stashing_unlink_attack/" title="how2heap(13)-tcache_stashing_unlink_attack"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="how2heap(13)-tcache_stashing_unlink_attack"/></a><div class="content"><a class="title" href="/2021/05/17/how2heap(13)-tcache_stashing_unlink_attack/" title="how2heap(13)-tcache_stashing_unlink_attack">how2heap(13)-tcache_stashing_unlink_attack</a><time datetime="2021-05-17T02:16:40.000Z" title="发表于 2021-05-17 10:16:40">2021-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/14/how2heap(12)-house%20of%20lore/" title="how2heap(12)-house of lore"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="how2heap(12)-house of lore"/></a><div class="content"><a class="title" href="/2021/05/14/how2heap(12)-house%20of%20lore/" title="how2heap(12)-house of lore">how2heap(12)-house of lore</a><time datetime="2021-05-14T08:02:54.000Z" title="发表于 2021-05-14 16:02:54">2021-05-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Cyberangel</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>